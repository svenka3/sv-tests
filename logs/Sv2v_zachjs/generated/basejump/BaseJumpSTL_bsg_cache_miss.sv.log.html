<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_miss.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_miss.v</a>
defines: 
time_elapsed: 1.051s
ram usage: 17148 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_miss.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_miss.v</a>
module bsg_cache_miss (
	clk_i,
	reset_i,
	miss_v_i,
	decode_v_i,
	addr_v_i,
	tag_v_i,
	valid_v_i,
	lock_v_i,
	tag_hit_v_i,
	tag_hit_way_id_i,
	tag_hit_found_i,
	sbuf_empty_i,
	dma_cmd_o,
	dma_way_o,
	dma_addr_o,
	dma_done_i,
	stat_info_i,
	stat_mem_v_o,
	stat_mem_w_o,
	stat_mem_addr_o,
	stat_mem_data_o,
	stat_mem_w_mask_o,
	tag_mem_v_o,
	tag_mem_w_o,
	tag_mem_addr_o,
	tag_mem_data_o,
	tag_mem_w_mask_o,
	done_o,
	recover_o,
	chosen_way_o,
	select_snoop_data_r_o,
	ack_i
);
	localparam [3:0] e_cache_amo_swap = 4&#39;b0000;
	localparam [3:0] e_cache_amo_add = 4&#39;b0001;
	localparam [3:0] e_cache_amo_xor = 4&#39;b0010;
	localparam [3:0] e_cache_amo_and = 4&#39;b0011;
	localparam [3:0] e_cache_amo_or = 4&#39;b0100;
	localparam [3:0] e_cache_amo_min = 4&#39;b0101;
	localparam [3:0] e_cache_amo_max = 4&#39;b0110;
	localparam [3:0] e_cache_amo_minu = 4&#39;b0111;
	localparam [3:0] e_cache_amo_maxu = 4&#39;b1000;
	localparam amo_support_level_none_lp = 1&#39;sb0;
	localparam amo_support_level_swap_lp = amo_support_level_none_lp | (1 &lt;&lt; e_cache_amo_swap);
	localparam amo_support_level_logical_lp = ((amo_support_level_swap_lp | (1 &lt;&lt; e_cache_amo_xor)) | (1 &lt;&lt; e_cache_amo_and)) | (1 &lt;&lt; e_cache_amo_or);
	localparam amo_support_level_arithmetic_lp = ((((amo_support_level_logical_lp | (1 &lt;&lt; e_cache_amo_add)) | (1 &lt;&lt; e_cache_amo_min)) | (1 &lt;&lt; e_cache_amo_max)) | (1 &lt;&lt; e_cache_amo_minu)) | (1 &lt;&lt; e_cache_amo_maxu);
	localparam [5:0] LB = 6&#39;b000000;
	localparam [5:0] LH = 6&#39;b000001;
	localparam [5:0] LW = 6&#39;b000010;
	localparam [5:0] LD = 6&#39;b000011;
	localparam [5:0] LBU = 6&#39;b000100;
	localparam [5:0] LHU = 6&#39;b000101;
	localparam [5:0] LWU = 6&#39;b000110;
	localparam [5:0] LDU = 6&#39;b000111;
	localparam [5:0] SB = 6&#39;b001000;
	localparam [5:0] SH = 6&#39;b001001;
	localparam [5:0] SW = 6&#39;b001010;
	localparam [5:0] SD = 6&#39;b001011;
	localparam [5:0] LM = 6&#39;b001100;
	localparam [5:0] SM = 6&#39;b001101;
	localparam [5:0] TAGST = 6&#39;b010000;
	localparam [5:0] TAGFL = 6&#39;b010001;
	localparam [5:0] TAGLV = 6&#39;b010010;
	localparam [5:0] TAGLA = 6&#39;b010011;
	localparam [5:0] AFL = 6&#39;b011000;
	localparam [5:0] AFLINV = 6&#39;b011001;
	localparam [5:0] AINV = 6&#39;b011010;
	localparam [5:0] ALOCK = 6&#39;b011011;
	localparam [5:0] AUNLOCK = 6&#39;b011100;
	localparam [5:0] AMOSWAP_W = 6&#39;b100000;
	localparam [5:0] AMOADD_W = 6&#39;b100001;
	localparam [5:0] AMOXOR_W = 6&#39;b100010;
	localparam [5:0] AMOAND_W = 6&#39;b100011;
	localparam [5:0] AMOOR_W = 6&#39;b100100;
	localparam [5:0] AMOMIN_W = 6&#39;b100101;
	localparam [5:0] AMOMAX_W = 6&#39;b100110;
	localparam [5:0] AMOMINU_W = 6&#39;b100111;
	localparam [5:0] AMOMAXU_W = 6&#39;b101000;
	localparam [5:0] AMOSWAP_D = 6&#39;b110000;
	localparam [5:0] AMOADD_D = 6&#39;b110001;
	localparam [5:0] AMOXOR_D = 6&#39;b110010;
	localparam [5:0] AMOAND_D = 6&#39;b110011;
	localparam [5:0] AMOOR_D = 6&#39;b110100;
	localparam [5:0] AMOMIN_D = 6&#39;b110101;
	localparam [5:0] AMOMAX_D = 6&#39;b110110;
	localparam [5:0] AMOMINU_D = 6&#39;b110111;
	localparam [5:0] AMOMAXU_D = 6&#39;b111000;
	localparam [3:0] e_dma_nop = 4&#39;b0000;
	localparam [3:0] e_dma_send_fill_addr = 4&#39;b0001;
	localparam [3:0] e_dma_send_evict_addr = 4&#39;b0010;
	localparam [3:0] e_dma_get_fill_data = 4&#39;b0100;
	localparam [3:0] e_dma_send_evict_data = 4&#39;b1000;
	parameter _sv2v_width_addr_width_p = 24;
	parameter [_sv2v_width_addr_width_p - 1:0] addr_width_p = &#34;inv&#34;;
	parameter _sv2v_width_data_width_p = 24;
	parameter [_sv2v_width_data_width_p - 1:0] data_width_p = &#34;inv&#34;;
	parameter _sv2v_width_block_size_in_words_p = 24;
	parameter [_sv2v_width_block_size_in_words_p - 1:0] block_size_in_words_p = &#34;inv&#34;;
	parameter _sv2v_width_sets_p = 24;
	parameter [_sv2v_width_sets_p - 1:0] sets_p = &#34;inv&#34;;
	parameter _sv2v_width_ways_p = 24;
	parameter [_sv2v_width_ways_p - 1:0] ways_p = &#34;inv&#34;;
	parameter lg_block_size_in_words_lp = (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p));
	parameter lg_sets_lp = (sets_p == 1 ? 1 : $clog2(sets_p));
	parameter lg_data_mask_width_lp = ((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3));
	parameter tag_width_lp = ((addr_width_p - lg_data_mask_width_lp) - lg_sets_lp) - lg_block_size_in_words_lp;
	parameter tag_info_width_lp = tag_width_lp + 2;
	parameter lg_ways_lp = (ways_p == 1 ? 1 : $clog2(ways_p));
	parameter stat_info_width_lp = (ways_p + ways_p) - 1;
	input clk_i;
	input reset_i;
	input miss_v_i;
	input wire [20:0] decode_v_i;
	input [addr_width_p - 1:0] addr_v_i;
	input [(ways_p * tag_width_lp) - 1:0] tag_v_i;
	input [ways_p - 1:0] valid_v_i;
	input [ways_p - 1:0] lock_v_i;
	input [ways_p - 1:0] tag_hit_v_i;
	input [lg_ways_lp - 1:0] tag_hit_way_id_i;
	input tag_hit_found_i;
	input sbuf_empty_i;
	output reg [3:0] dma_cmd_o;
	output wire [lg_ways_lp - 1:0] dma_way_o;
	output reg [addr_width_p - 1:0] dma_addr_o;
	input dma_done_i;
	input [stat_info_width_lp - 1:0] stat_info_i;
	output reg stat_mem_v_o;
	output reg stat_mem_w_o;
	output wire [lg_sets_lp - 1:0] stat_mem_addr_o;
	output wire [stat_info_width_lp - 1:0] stat_mem_data_o;
	output wire [stat_info_width_lp - 1:0] stat_mem_w_mask_o;
	output reg tag_mem_v_o;
	output reg tag_mem_w_o;
	output wire [lg_sets_lp - 1:0] tag_mem_addr_o;
	output wire [(ways_p * tag_info_width_lp) - 1:0] tag_mem_data_o;
	output wire [(ways_p * tag_info_width_lp) - 1:0] tag_mem_w_mask_o;
	output reg done_o;
	output reg recover_o;
	output wire [lg_ways_lp - 1:0] chosen_way_o;
	output wire select_snoop_data_r_o;
	input ack_i;
	wire [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] stat_info_in;
	assign stat_info_in = stat_info_i;
	reg [(ways_p * (2 + tag_width_lp)) - 1:0] tag_mem_data_out;
	reg [(ways_p * (2 + tag_width_lp)) - 1:0] tag_mem_w_mask_out;
	reg [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] stat_mem_data_out;
	reg [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] stat_mem_w_mask_out;
	assign tag_mem_data_o = tag_mem_data_out;
	assign stat_mem_data_o = stat_mem_data_out;
	assign tag_mem_w_mask_o = tag_mem_w_mask_out;
	assign stat_mem_w_mask_o = stat_mem_w_mask_out;
	wire [lg_ways_lp - 1:0] invalid_way_id;
	wire invalid_exist;
	bsg_priority_encode #(
		.width_p(ways_p),
		.lo_to_hi_p(1)
	) invalid_way_pe(
		.i(~valid_v_i &amp; ~lock_v_i),
		.addr_o(invalid_way_id),
		.v_o(invalid_exist)
	);
	wire [lg_ways_lp - 1:0] lru_way_id;
	bsg_lru_pseudo_tree_encode #(.ways_p(ways_p)) lru_encode(
		.lru_i(stat_info_in[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)]),
		.way_id_o(lru_way_id)
	);
	reg [3:0] miss_state_r;
	reg [3:0] miss_state_n;
	reg [lg_ways_lp - 1:0] chosen_way_r;
	reg [lg_ways_lp - 1:0] chosen_way_n;
	reg [lg_ways_lp - 1:0] flush_way_r;
	reg [lg_ways_lp - 1:0] flush_way_n;
	reg select_snoop_data_r;
	reg select_snoop_data_n;
	wire goto_flush_op;
	wire goto_lock_op;
	assign goto_flush_op = ((decode_v_i[13] | decode_v_i[8]) | decode_v_i[10]) | decode_v_i[9];
	assign goto_lock_op = decode_v_i[6] | (decode_v_i[7] &amp; tag_hit_found_i);
	wire [tag_width_lp - 1:0] addr_tag_v;
	wire [lg_sets_lp - 1:0] addr_index_v;
	wire [lg_ways_lp - 1:0] addr_way_v;
	wire [lg_block_size_in_words_lp - 1:0] addr_block_offset_v;
	assign addr_index_v = addr_v_i[lg_data_mask_width_lp + lg_block_size_in_words_lp+:lg_sets_lp];
	assign addr_tag_v = addr_v_i[(lg_data_mask_width_lp + lg_block_size_in_words_lp) + lg_sets_lp+:tag_width_lp];
	assign addr_way_v = addr_v_i[(lg_sets_lp + lg_block_size_in_words_lp) + lg_data_mask_width_lp+:lg_ways_lp];
	assign addr_block_offset_v = addr_v_i[lg_data_mask_width_lp+:lg_block_size_in_words_lp];
	assign stat_mem_addr_o = addr_index_v;
	assign tag_mem_addr_o = addr_index_v;
	assign chosen_way_o = chosen_way_r;
	assign dma_way_o = (goto_flush_op ? flush_way_r : chosen_way_r);
	wire [ways_p - 2:0] chosen_way_lru_data;
	wire [ways_p - 2:0] chosen_way_lru_mask;
	bsg_lru_pseudo_tree_decode #(.ways_p(ways_p)) chosen_way_lru_decode(
		.way_id_i(chosen_way_r),
		.data_o(chosen_way_lru_data),
		.mask_o(chosen_way_lru_mask)
	);
	wire [lg_ways_lp - 1:0] backup_lru_way_id;
	bsg_priority_encode #(
		.width_p(ways_p),
		.lo_to_hi_p(1)
	) backup_lru_pe(
		.i(~lock_v_i),
		.addr_o(backup_lru_way_id),
		.v_o()
	);
	wire [ways_p - 1:0] chosen_way_decode;
	bsg_decode #(.num_out_p(ways_p)) chosen_way_demux(
		.i(chosen_way_n),
		.o(chosen_way_decode)
	);
	wire [ways_p - 1:0] addr_way_v_decode;
	bsg_decode #(.num_out_p(ways_p)) addr_way_v_demux(
		.i(addr_way_v),
		.o(addr_way_v_decode)
	);
	wire [ways_p - 1:0] flush_way_decode;
	assign flush_way_decode = (decode_v_i[13] ? addr_way_v_decode : tag_hit_v_i);
	assign select_snoop_data_r_o = select_snoop_data_r;
	localparam [3:0] DONE = 8;
	localparam [3:0] FLUSH_OP = 1;
	localparam [3:0] GET_FILL_DATA = 6;
	localparam [3:0] LOCK_OP = 2;
	localparam [3:0] RECOVER = 7;
	localparam [3:0] SEND_EVICT_ADDR = 3;
	localparam [3:0] SEND_EVICT_DATA = 5;
	localparam [3:0] SEND_FILL_ADDR = 4;
	localparam [3:0] START = 0;
	always @(*) begin
		stat_mem_v_o = 1&#39;b0;
		stat_mem_w_o = 1&#39;b0;
		stat_mem_data_out = {ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) {1&#39;sb0}};
		stat_mem_w_mask_out = {ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) {1&#39;sb0}};
		tag_mem_v_o = 1&#39;b0;
		tag_mem_w_o = 1&#39;b0;
		tag_mem_data_out = {ways_p * (2 + tag_width_lp) {1&#39;sb0}};
		tag_mem_w_mask_out = {ways_p * (2 + tag_width_lp) {1&#39;sb0}};
		chosen_way_n = chosen_way_r;
		flush_way_n = flush_way_r;
		dma_addr_o = {addr_width_p {1&#39;sb0}};
		dma_cmd_o = e_dma_nop;
		recover_o = 1&#39;sb0;
		done_o = 1&#39;sb0;
		select_snoop_data_n = select_snoop_data_r;
		case (miss_state_r)
			START: begin
				stat_mem_v_o = miss_v_i;
				miss_state_n = (miss_v_i ? (goto_flush_op ? FLUSH_OP : (goto_lock_op ? LOCK_OP : SEND_FILL_ADDR)) : START);
			end
			SEND_FILL_ADDR: begin
				chosen_way_n = (invalid_exist ? invalid_way_id : (lock_v_i[lru_way_id] ? backup_lru_way_id : lru_way_id));
				dma_cmd_o = e_dma_send_fill_addr;
				dma_addr_o = {addr_tag_v, addr_index_v, {lg_data_mask_width_lp + lg_block_size_in_words_lp {1&#39;b0}}};
				miss_state_n = (dma_done_i ? (stat_info_in[(ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 1) - chosen_way_n)] &amp; valid_v_i[chosen_way_n] ? SEND_EVICT_ADDR : GET_FILL_DATA) : SEND_FILL_ADDR);
			end
			FLUSH_OP: begin
				flush_way_n = (decode_v_i[13] ? addr_way_v : tag_hit_way_id_i);
				stat_mem_v_o = 1&#39;b1;
				stat_mem_w_o = 1&#39;b1;
				stat_mem_data_out[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = {ways_p {1&#39;b0}};
				stat_mem_data_out[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = {ways_p - 1 {1&#39;b0}};
				stat_mem_w_mask_out[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = flush_way_decode;
				stat_mem_w_mask_out[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = {ways_p - 1 {1&#39;b0}};
				tag_mem_v_o = 1&#39;b1;
				tag_mem_w_o = 1&#39;b1;
				begin : sv2v_autoblock_1
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							tag_mem_data_out[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)] = 1&#39;b0;
							tag_mem_data_out[(i * (2 + tag_width_lp)) + tag_width_lp] = 1&#39;b0;
							tag_mem_data_out[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp] = {tag_width_lp {1&#39;b0}};
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)] = (decode_v_i[8] | decode_v_i[9]) &amp; flush_way_decode[i];
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + tag_width_lp] = (decode_v_i[8] | decode_v_i[9]) &amp; flush_way_decode[i];
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp] = {tag_width_lp {1&#39;b0}};
						end
				end
				miss_state_n = ((~decode_v_i[8] &amp; stat_info_in[(ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 1) - flush_way_n)]) &amp; valid_v_i[flush_way_n] ? SEND_EVICT_ADDR : RECOVER);
			end
			LOCK_OP: begin
				tag_mem_v_o = 1&#39;b1;
				tag_mem_w_o = 1&#39;b1;
				begin : sv2v_autoblock_2
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							tag_mem_data_out[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)] = 1&#39;b0;
							tag_mem_data_out[(i * (2 + tag_width_lp)) + tag_width_lp] = decode_v_i[7];
							tag_mem_data_out[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp] = {tag_width_lp {1&#39;b0}};
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)] = 1&#39;b0;
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + tag_width_lp] = tag_hit_v_i[i];
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp] = {tag_width_lp {1&#39;b0}};
						end
				end
				miss_state_n = RECOVER;
			end
			SEND_EVICT_ADDR: begin
				dma_cmd_o = e_dma_send_evict_addr;
				dma_addr_o = {tag_v_i[dma_way_o * tag_width_lp+:tag_width_lp], addr_index_v, {lg_data_mask_width_lp + lg_block_size_in_words_lp {1&#39;b0}}};
				miss_state_n = (dma_done_i ? SEND_EVICT_DATA : SEND_EVICT_ADDR);
			end
			SEND_EVICT_DATA: begin
				dma_cmd_o = (sbuf_empty_i ? e_dma_send_evict_data : e_dma_nop);
				dma_addr_o = {tag_v_i[dma_way_o * tag_width_lp+:tag_width_lp], addr_index_v, {lg_data_mask_width_lp + lg_block_size_in_words_lp {1&#39;b0}}};
				miss_state_n = (dma_done_i ? ((decode_v_i[13] | decode_v_i[9]) | decode_v_i[10] ? RECOVER : GET_FILL_DATA) : SEND_EVICT_DATA);
			end
			GET_FILL_DATA: begin
				dma_cmd_o = (sbuf_empty_i ? e_dma_get_fill_data : e_dma_nop);
				dma_addr_o = {addr_tag_v, addr_index_v, addr_block_offset_v, {lg_data_mask_width_lp {1&#39;b0}}};
				stat_mem_v_o = dma_done_i;
				stat_mem_w_o = dma_done_i;
				stat_mem_data_out[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = {ways_p {decode_v_i[15] | decode_v_i[4]}};
				stat_mem_data_out[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = chosen_way_lru_data;
				stat_mem_w_mask_out[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = chosen_way_decode;
				stat_mem_w_mask_out[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = chosen_way_lru_mask;
				tag_mem_v_o = dma_done_i;
				tag_mem_w_o = dma_done_i;
				begin : sv2v_autoblock_3
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							tag_mem_data_out[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp] = addr_tag_v;
							tag_mem_data_out[(i * (2 + tag_width_lp)) + tag_width_lp] = decode_v_i[7];
							tag_mem_data_out[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)] = 1&#39;b1;
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp] = {tag_width_lp {chosen_way_decode[i]}};
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + tag_width_lp] = chosen_way_decode[i];
							tag_mem_w_mask_out[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)] = chosen_way_decode[i];
						end
				end
				select_snoop_data_n = (dma_done_i ? 1&#39;b1 : select_snoop_data_r);
				miss_state_n = (dma_done_i ? RECOVER : GET_FILL_DATA);
			end
			RECOVER: begin
				recover_o = 1&#39;b1;
				miss_state_n = DONE;
			end
			DONE: begin
				done_o = 1&#39;b1;
				miss_state_n = (ack_i ? START : DONE);
				select_snoop_data_n = (ack_i ? 1&#39;b0 : select_snoop_data_r);
			end
			default: miss_state_n = START;
		endcase
	end
	always @(posedge clk_i)
		if (reset_i) begin
			miss_state_r &lt;= START;
			chosen_way_r &lt;= {lg_ways_lp {1&#39;sb0}};
			flush_way_r &lt;= {lg_ways_lp {1&#39;sb0}};
			select_snoop_data_r &lt;= 1&#39;b0;
		end
		else begin
			miss_state_r &lt;= miss_state_n;
			chosen_way_r &lt;= chosen_way_n;
			flush_way_r &lt;= flush_way_n;
			select_snoop_data_r &lt;= select_snoop_data_n;
		end
endmodule

</pre>
</body>
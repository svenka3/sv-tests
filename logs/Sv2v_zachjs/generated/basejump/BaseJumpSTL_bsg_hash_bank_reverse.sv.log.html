<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_hash_bank_reverse.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_hash_bank_reverse.v</a>
defines: 
time_elapsed: 0.262s
ram usage: 13900 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_hash_bank_reverse.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_hash_bank_reverse.v</a>
module bsg_hash_bank_reverse (
	index_i,
	bank_i,
	o
);
	parameter _sv2v_width_banks_p = 24;
	parameter [_sv2v_width_banks_p - 1:0] banks_p = &#34;inv&#34;;
	parameter _sv2v_width_width_p = 24;
	parameter [_sv2v_width_width_p - 1:0] width_p = &#34;inv&#34;;
	parameter index_width_lp = $clog2((((2 ** width_p) + banks_p) - 1) / banks_p);
	parameter lg_banks_lp = (banks_p == 1 ? 1 : $clog2(banks_p));
	parameter debug_lp = 0;
	input [index_width_lp - 1:0] index_i;
	input [lg_banks_lp - 1:0] bank_i;
	output [width_p - 1:0] o;
	generate
		if (banks_p == 1) begin : hash1
			assign o = index_i;
		end
		else if (banks_p == 2) begin : hash2
			assign o = {bank_i, index_i};
		end
		else if (~banks_p[0]) begin : hashpow2
			assign o[width_p - 1] = bank_i[0];
			bsg_hash_bank_reverse #(
				._sv2v_width_banks_p(_sv2v_width_banks_p),
				.banks_p(banks_p &gt;&gt; 1),
				._sv2v_width_width_p((_sv2v_width_width_p &gt;= 32 ? _sv2v_width_width_p : 32)),
				.width_p(width_p - 1)
			) bhbr(
				.index_i(index_i[index_width_lp - 1:0]),
				.bank_i(bank_i[lg_banks_lp - 1:1]),
				.o(o[width_p - 2:0])
			);
		end
		else if ((banks_p &amp; (banks_p + 1)) == 0) begin : hash3
			if (width_p % lg_banks_lp) begin : odd
				wire _unused;
				bsg_hash_bank_reverse #(
					._sv2v_width_banks_p(_sv2v_width_banks_p),
					.banks_p(banks_p),
					._sv2v_width_width_p((_sv2v_width_width_p &gt;= 32 ? _sv2v_width_width_p : 32)),
					.width_p(width_p + 1)
				) rhf(
					.index_i({index_i, 1&#39;b0}),
					.bank_i(bank_i),
					.o({o[width_p - 1:0], _unused})
				);
			end
			else begin : even
				localparam frac_width_lp = width_p / lg_banks_lp;
				wire [(lg_banks_lp * frac_width_lp) - 1:0] unzippered;
				function automatic [width_p - 1:0] sv2v_cast_89401;
					input reg [width_p - 1:0] inp;
					sv2v_cast_89401 = inp;
				endfunction
				wire [width_p - 1:0] index_i_ext = sv2v_cast_89401(index_i);
				bsg_transpose #(
					.width_p(lg_banks_lp),
					.els_p(frac_width_lp)
				) unzip(
					.i(index_i_ext),
					.o(unzippered)
				);
				genvar j;
				wire [frac_width_lp - 1:0] zero_pair;
				bsg_reduce_segmented #(
					.segments_p(frac_width_lp),
					.segment_width_p(lg_banks_lp),
					.nor_p(1)
				) brs(
					.i(index_i_ext),
					.o(zero_pair)
				);
				wire [frac_width_lp - 1:0] zero_pair_or_scan;
				bsg_scan #(
					.width_p(frac_width_lp),
					.or_p(1)
				) scan(
					.i(zero_pair),
					.o(zero_pair_or_scan)
				);
				wire [frac_width_lp - 1:0] first_one;
				if (frac_width_lp &gt; 1) assign first_one = zero_pair_or_scan &amp; ~{1&#39;b0, zero_pair_or_scan[frac_width_lp - 1:1]};
				else assign first_one = zero_pair_or_scan;
				wire [(lg_banks_lp * frac_width_lp) - 1:0] bits;
				for (j = 0; j &lt; lg_banks_lp; j = j + 1) begin : rof2
					assign bits[j * frac_width_lp+:frac_width_lp] = (((zero_pair_or_scan &amp; ~first_one) &amp; unzippered[j * frac_width_lp+:frac_width_lp]) | (first_one &amp; {frac_width_lp {bank_i[j]}})) | ~zero_pair_or_scan;
				end
				wire [width_p - 1:0] transpose_lo;
				bsg_transpose #(
					.els_p(lg_banks_lp),
					.width_p(frac_width_lp)
				) zip(
					.i(bits),
					.o(transpose_lo)
				);
				assign o = transpose_lo[width_p - 1:0];
			end
		end
	endgenerate
endmodule

</pre>
</body>
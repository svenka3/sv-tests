<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache.v</a>
defines: 
time_elapsed: 1.498s
ram usage: 27324 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache.v</a>
module bsg_cache (
	clk_i,
	reset_i,
	cache_pkt_i,
	v_i,
	ready_o,
	data_o,
	v_o,
	yumi_i,
	dma_pkt_o,
	dma_pkt_v_o,
	dma_pkt_yumi_i,
	dma_data_i,
	dma_data_v_i,
	dma_data_ready_o,
	dma_data_o,
	dma_data_v_o,
	dma_data_yumi_i,
	v_we_o
);
	localparam [3:0] e_cache_amo_swap = 4&#39;b0000;
	localparam [3:0] e_cache_amo_add = 4&#39;b0001;
	localparam [3:0] e_cache_amo_xor = 4&#39;b0010;
	localparam [3:0] e_cache_amo_and = 4&#39;b0011;
	localparam [3:0] e_cache_amo_or = 4&#39;b0100;
	localparam [3:0] e_cache_amo_min = 4&#39;b0101;
	localparam [3:0] e_cache_amo_max = 4&#39;b0110;
	localparam [3:0] e_cache_amo_minu = 4&#39;b0111;
	localparam [3:0] e_cache_amo_maxu = 4&#39;b1000;
	localparam amo_support_level_none_lp = 1&#39;sb0;
	localparam amo_support_level_swap_lp = amo_support_level_none_lp | (1 &lt;&lt; e_cache_amo_swap);
	localparam amo_support_level_logical_lp = ((amo_support_level_swap_lp | (1 &lt;&lt; e_cache_amo_xor)) | (1 &lt;&lt; e_cache_amo_and)) | (1 &lt;&lt; e_cache_amo_or);
	localparam amo_support_level_arithmetic_lp = ((((amo_support_level_logical_lp | (1 &lt;&lt; e_cache_amo_add)) | (1 &lt;&lt; e_cache_amo_min)) | (1 &lt;&lt; e_cache_amo_max)) | (1 &lt;&lt; e_cache_amo_minu)) | (1 &lt;&lt; e_cache_amo_maxu);
	localparam [5:0] LB = 6&#39;b000000;
	localparam [5:0] LH = 6&#39;b000001;
	localparam [5:0] LW = 6&#39;b000010;
	localparam [5:0] LD = 6&#39;b000011;
	localparam [5:0] LBU = 6&#39;b000100;
	localparam [5:0] LHU = 6&#39;b000101;
	localparam [5:0] LWU = 6&#39;b000110;
	localparam [5:0] LDU = 6&#39;b000111;
	localparam [5:0] SB = 6&#39;b001000;
	localparam [5:0] SH = 6&#39;b001001;
	localparam [5:0] SW = 6&#39;b001010;
	localparam [5:0] SD = 6&#39;b001011;
	localparam [5:0] LM = 6&#39;b001100;
	localparam [5:0] SM = 6&#39;b001101;
	localparam [5:0] TAGST = 6&#39;b010000;
	localparam [5:0] TAGFL = 6&#39;b010001;
	localparam [5:0] TAGLV = 6&#39;b010010;
	localparam [5:0] TAGLA = 6&#39;b010011;
	localparam [5:0] AFL = 6&#39;b011000;
	localparam [5:0] AFLINV = 6&#39;b011001;
	localparam [5:0] AINV = 6&#39;b011010;
	localparam [5:0] ALOCK = 6&#39;b011011;
	localparam [5:0] AUNLOCK = 6&#39;b011100;
	localparam [5:0] AMOSWAP_W = 6&#39;b100000;
	localparam [5:0] AMOADD_W = 6&#39;b100001;
	localparam [5:0] AMOXOR_W = 6&#39;b100010;
	localparam [5:0] AMOAND_W = 6&#39;b100011;
	localparam [5:0] AMOOR_W = 6&#39;b100100;
	localparam [5:0] AMOMIN_W = 6&#39;b100101;
	localparam [5:0] AMOMAX_W = 6&#39;b100110;
	localparam [5:0] AMOMINU_W = 6&#39;b100111;
	localparam [5:0] AMOMAXU_W = 6&#39;b101000;
	localparam [5:0] AMOSWAP_D = 6&#39;b110000;
	localparam [5:0] AMOADD_D = 6&#39;b110001;
	localparam [5:0] AMOXOR_D = 6&#39;b110010;
	localparam [5:0] AMOAND_D = 6&#39;b110011;
	localparam [5:0] AMOOR_D = 6&#39;b110100;
	localparam [5:0] AMOMIN_D = 6&#39;b110101;
	localparam [5:0] AMOMAX_D = 6&#39;b110110;
	localparam [5:0] AMOMINU_D = 6&#39;b110111;
	localparam [5:0] AMOMAXU_D = 6&#39;b111000;
	localparam [3:0] e_dma_nop = 4&#39;b0000;
	localparam [3:0] e_dma_send_fill_addr = 4&#39;b0001;
	localparam [3:0] e_dma_send_evict_addr = 4&#39;b0010;
	localparam [3:0] e_dma_get_fill_data = 4&#39;b0100;
	localparam [3:0] e_dma_send_evict_data = 4&#39;b1000;
	parameter _sv2v_width_addr_width_p = 24;
	parameter [_sv2v_width_addr_width_p - 1:0] addr_width_p = &#34;inv&#34;;
	parameter _sv2v_width_data_width_p = 24;
	parameter [_sv2v_width_data_width_p - 1:0] data_width_p = &#34;inv&#34;;
	parameter _sv2v_width_block_size_in_words_p = 24;
	parameter [_sv2v_width_block_size_in_words_p - 1:0] block_size_in_words_p = &#34;inv&#34;;
	parameter _sv2v_width_sets_p = 24;
	parameter [_sv2v_width_sets_p - 1:0] sets_p = &#34;inv&#34;;
	parameter _sv2v_width_ways_p = 24;
	parameter [_sv2v_width_ways_p - 1:0] ways_p = &#34;inv&#34;;
	parameter amo_support_p = (1 &lt;&lt; e_cache_amo_swap) | (1 &lt;&lt; e_cache_amo_or);
	parameter dma_data_width_p = data_width_p;
	parameter bsg_cache_pkt_width_lp = ((6 + addr_width_p) + data_width_p) + (data_width_p &gt;&gt; 3);
	parameter bsg_cache_dma_pkt_width_lp = 1 + addr_width_p;
	parameter debug_p = 0;
	input clk_i;
	input reset_i;
	input [bsg_cache_pkt_width_lp - 1:0] cache_pkt_i;
	input v_i;
	output wire ready_o;
	output reg [data_width_p - 1:0] data_o;
	output wire v_o;
	input yumi_i;
	output wire [bsg_cache_dma_pkt_width_lp - 1:0] dma_pkt_o;
	output wire dma_pkt_v_o;
	input dma_pkt_yumi_i;
	input [dma_data_width_p - 1:0] dma_data_i;
	input dma_data_v_i;
	output wire dma_data_ready_o;
	output wire [dma_data_width_p - 1:0] dma_data_o;
	output wire dma_data_v_o;
	input dma_data_yumi_i;
	output wire v_we_o;
	localparam lg_sets_lp = (sets_p == 1 ? 1 : $clog2(sets_p));
	localparam data_mask_width_lp = data_width_p &gt;&gt; 3;
	localparam lg_data_mask_width_lp = (data_mask_width_lp == 1 ? 1 : $clog2(data_mask_width_lp));
	localparam lg_block_size_in_words_lp = (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p));
	localparam tag_width_lp = ((addr_width_p - lg_data_mask_width_lp) - lg_sets_lp) - lg_block_size_in_words_lp;
	localparam tag_info_width_lp = tag_width_lp + 2;
	localparam lg_ways_lp = (ways_p == 1 ? 1 : $clog2(ways_p));
	localparam stat_info_width_lp = (ways_p + ways_p) - 1;
	localparam data_sel_mux_els_lp = (4 &lt; (lg_data_mask_width_lp + 1) ? 4 : lg_data_mask_width_lp + 1);
	localparam lg_data_sel_mux_els_lp = (data_sel_mux_els_lp == 1 ? 1 : $clog2(data_sel_mux_els_lp));
	localparam burst_size_in_words_lp = dma_data_width_p / data_width_p;
	localparam lg_burst_size_in_words_lp = (burst_size_in_words_lp == 1 ? 1 : $clog2(burst_size_in_words_lp));
	localparam burst_len_lp = (block_size_in_words_p * data_width_p) / dma_data_width_p;
	localparam lg_burst_len_lp = (burst_len_lp == 1 ? 1 : $clog2(burst_len_lp));
	localparam dma_data_mask_width_lp = dma_data_width_p &gt;&gt; 3;
	localparam data_mem_els_lp = sets_p * burst_len_lp;
	localparam lg_data_mem_els_lp = (data_mem_els_lp == 1 ? 1 : $clog2(data_mem_els_lp));
	wire [lg_ways_lp - 1:0] addr_way;
	wire [lg_sets_lp - 1:0] addr_index;
	wire [lg_block_size_in_words_lp - 1:0] addr_block_offset;
	wire [(((6 + addr_width_p) + data_width_p) + (data_width_p &gt;&gt; 3)) - 1:0] cache_pkt;
	assign cache_pkt = cache_pkt_i;
	wire [20:0] decode;
	bsg_cache_decode decode0(
		.opcode_i(cache_pkt[6 + (addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))-:((6 + (addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))) &gt;= (addr_width_p + (data_width_p + (data_width_p &gt;&gt; 3))) ? ((6 + (addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))) - (addr_width_p + (data_width_p + (data_width_p &gt;&gt; 3)))) + 1 : ((addr_width_p + (data_width_p + (data_width_p &gt;&gt; 3))) - (6 + (addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))) + 1)]),
		.decode_o(decode)
	);
	assign addr_way = cache_pkt[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - ((addr_width_p - 1) - ((lg_data_mask_width_lp + lg_block_size_in_words_lp) + lg_sets_lp))+:lg_ways_lp];
	assign addr_index = cache_pkt[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - ((addr_width_p - 1) - (lg_data_mask_width_lp + lg_block_size_in_words_lp))+:lg_sets_lp];
	assign addr_block_offset = cache_pkt[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - ((addr_width_p - 1) - lg_data_mask_width_lp)+:lg_block_size_in_words_lp];
	wire [lg_data_mem_els_lp - 1:0] ld_data_mem_addr;
	generate
		if (burst_len_lp == 1) assign ld_data_mem_addr = addr_index;
		else if (burst_len_lp == block_size_in_words_p) assign ld_data_mem_addr = {addr_index, cache_pkt[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - ((addr_width_p - 1) - lg_data_mask_width_lp)+:lg_block_size_in_words_lp]};
		else assign ld_data_mem_addr = {addr_index, cache_pkt[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - ((addr_width_p - 1) - (lg_data_mask_width_lp + lg_burst_size_in_words_lp))+:lg_burst_len_lp]};
	endgenerate
	reg v_tl_r;
	reg [20:0] decode_tl_r;
	reg [data_mask_width_lp - 1:0] mask_tl_r;
	reg [addr_width_p - 1:0] addr_tl_r;
	reg [data_width_p - 1:0] data_tl_r;
	wire sbuf_hazard;
	always @(posedge clk_i)
		if (reset_i) begin
			v_tl_r &lt;= 1&#39;b0;
			{mask_tl_r, addr_tl_r, data_tl_r, decode_tl_r} &lt;= {((data_mask_width_lp + addr_width_p) + data_width_p) + 21 {1&#39;sb0}};
		end
		else if (ready_o) begin
			v_tl_r &lt;= v_i;
			if (v_i) begin
				mask_tl_r &lt;= cache_pkt[(data_width_p &gt;&gt; 3) - 1-:data_width_p &gt;&gt; 3];
				addr_tl_r &lt;= cache_pkt[addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))-:((addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) &gt;= (data_width_p + (data_width_p &gt;&gt; 3)) ? ((addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - (data_width_p + (data_width_p &gt;&gt; 3))) + 1 : ((data_width_p + (data_width_p &gt;&gt; 3)) - (addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))) + 1)];
				data_tl_r &lt;= cache_pkt[data_width_p + ((data_width_p &gt;&gt; 3) - 1)-:((data_width_p + ((data_width_p &gt;&gt; 3) - 1)) &gt;= (data_width_p &gt;&gt; 3) ? ((data_width_p + ((data_width_p &gt;&gt; 3) - 1)) - (data_width_p &gt;&gt; 3)) + 1 : ((data_width_p &gt;&gt; 3) - (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) + 1)];
				decode_tl_r &lt;= decode;
			end
		end
		else if (sbuf_hazard)
			v_tl_r &lt;= 1&#39;b0;
	wire [lg_sets_lp - 1:0] addr_index_tl;
	wire [lg_block_size_in_words_lp - 1:0] addr_block_offset_tl;
	assign addr_index_tl = addr_tl_r[lg_data_mask_width_lp + lg_block_size_in_words_lp+:lg_sets_lp];
	assign addr_block_offset_tl = addr_tl_r[lg_data_mask_width_lp+:lg_block_size_in_words_lp];
	wire [lg_data_mem_els_lp - 1:0] recover_data_mem_addr;
	generate
		if (burst_len_lp == 1) assign recover_data_mem_addr = addr_index_tl;
		else if (burst_len_lp == block_size_in_words_p) assign recover_data_mem_addr = {addr_index_tl, addr_tl_r[lg_data_mask_width_lp+:lg_block_size_in_words_lp]};
		else assign recover_data_mem_addr = {addr_index_tl, addr_tl_r[lg_data_mask_width_lp + lg_burst_size_in_words_lp+:lg_burst_len_lp]};
	endgenerate
	wire tag_mem_v_li;
	wire tag_mem_w_li;
	reg [lg_sets_lp - 1:0] tag_mem_addr_li;
	reg [(ways_p * (2 + tag_width_lp)) - 1:0] tag_mem_data_li;
	reg [(ways_p * (2 + tag_width_lp)) - 1:0] tag_mem_w_mask_li;
	wire [(ways_p * (2 + tag_width_lp)) - 1:0] tag_mem_data_lo;
	wire clk_i;
	wire reset_i;
	bsg_mem_1rw_sync_mask_write_bit #(
		.width_p(tag_info_width_lp * ways_p),
		.els_p(sets_p),
		.latch_last_read_p(1)
	) tag_mem(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(tag_mem_v_li),
		.w_i(tag_mem_w_li),
		.addr_i(tag_mem_addr_li),
		.data_i(tag_mem_data_li),
		.w_mask_i(tag_mem_w_mask_li),
		.data_o(tag_mem_data_lo)
	);
	wire [ways_p - 1:0] valid_tl;
	wire [(ways_p * tag_width_lp) - 1:0] tag_tl;
	wire [ways_p - 1:0] lock_tl;
	generate
		genvar i;
		for (i = 0; i &lt; ways_p; i = i + 1) begin
			assign valid_tl[i] = tag_mem_data_lo[(i * (2 + tag_width_lp)) + (tag_width_lp + 1)];
			assign tag_tl[i * tag_width_lp+:tag_width_lp] = tag_mem_data_lo[(i * (2 + tag_width_lp)) + (tag_width_lp - 1)-:tag_width_lp];
			assign lock_tl[i] = tag_mem_data_lo[(i * (2 + tag_width_lp)) + tag_width_lp];
		end
	endgenerate
	wire data_mem_v_li;
	wire data_mem_w_li;
	wire [lg_data_mem_els_lp - 1:0] data_mem_addr_li;
	wire [(ways_p * dma_data_width_p) - 1:0] data_mem_data_li;
	wire [(ways_p * dma_data_mask_width_lp) - 1:0] data_mem_w_mask_li;
	wire [(ways_p * dma_data_width_p) - 1:0] data_mem_data_lo;
	bsg_mem_1rw_sync_mask_write_byte #(
		.data_width_p(dma_data_width_p * ways_p),
		.els_p(data_mem_els_lp),
		.latch_last_read_p(1)
	) data_mem(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(data_mem_v_li),
		.w_i(data_mem_w_li),
		.addr_i(data_mem_addr_li),
		.data_i(data_mem_data_li),
		.write_mask_i(data_mem_w_mask_li),
		.data_o(data_mem_data_lo)
	);
	wire v_we;
	reg v_v_r;
	reg [20:0] decode_v_r;
	reg [data_mask_width_lp - 1:0] mask_v_r;
	reg [addr_width_p - 1:0] addr_v_r;
	reg [data_width_p - 1:0] data_v_r;
	reg [ways_p - 1:0] valid_v_r;
	reg [ways_p - 1:0] lock_v_r;
	reg [(ways_p * tag_width_lp) - 1:0] tag_v_r;
	reg [(ways_p * dma_data_width_p) - 1:0] ld_data_v_r;
	wire retval_op_v;
	always @(posedge clk_i)
		if (reset_i) begin
			v_v_r &lt;= 1&#39;b0;
			{mask_v_r, decode_v_r, addr_v_r, data_v_r, valid_v_r, lock_v_r, tag_v_r} &lt;= {(((((data_mask_width_lp + 21) + addr_width_p) + data_width_p) + ways_p) + ways_p) + (ways_p * tag_width_lp) {1&#39;sb0}};
		end
		else if (v_we) begin
			v_v_r &lt;= v_tl_r;
			if (v_tl_r) begin
				mask_v_r &lt;= mask_tl_r;
				decode_v_r &lt;= decode_tl_r;
				addr_v_r &lt;= addr_tl_r;
				data_v_r &lt;= data_tl_r;
				valid_v_r &lt;= valid_tl;
				tag_v_r &lt;= tag_tl;
				lock_v_r &lt;= lock_tl;
				ld_data_v_r &lt;= data_mem_data_lo;
			end
		end
	assign v_we_o = v_we;
	wire [tag_width_lp - 1:0] addr_tag_v;
	wire [lg_sets_lp - 1:0] addr_index_v;
	wire [lg_ways_lp - 1:0] addr_way_v;
	wire [ways_p - 1:0] tag_hit_v;
	assign addr_tag_v = addr_v_r[(lg_data_mask_width_lp + lg_block_size_in_words_lp) + lg_sets_lp+:tag_width_lp];
	assign addr_index_v = addr_v_r[lg_data_mask_width_lp + lg_block_size_in_words_lp+:lg_sets_lp];
	assign addr_way_v = addr_v_r[(lg_sets_lp + lg_block_size_in_words_lp) + lg_data_mask_width_lp+:lg_ways_lp];
	generate
		for (i = 0; i &lt; ways_p; i = i + 1) assign tag_hit_v[i] = (addr_tag_v == tag_v_r[i * tag_width_lp+:tag_width_lp]) &amp; valid_v_r[i];
	endgenerate
	wire [lg_ways_lp - 1:0] tag_hit_way_id;
	wire tag_hit_found;
	bsg_priority_encode #(
		.width_p(ways_p),
		.lo_to_hi_p(1)
	) tag_hit_pe(
		.i(tag_hit_v),
		.addr_o(tag_hit_way_id),
		.v_o(tag_hit_found)
	);
	wire ld_st_miss = ~tag_hit_found &amp; (decode_v_r[16] | decode_v_r[15]);
	wire tagfl_hit = decode_v_r[13] &amp; valid_v_r[addr_way_v];
	wire aflinv_hit = ((decode_v_r[10] | decode_v_r[9]) | decode_v_r[8]) &amp; tag_hit_found;
	wire alock_miss = decode_v_r[7] &amp; (tag_hit_found ? ~lock_v_r[tag_hit_way_id] : 1&#39;b1);
	wire aunlock_hit = decode_v_r[6] &amp; (tag_hit_found ? lock_v_r[tag_hit_way_id] : 1&#39;b0);
	wire atomic_miss = decode_v_r[4] &amp; ~tag_hit_found;
	wire miss_v = (~decode_v_r[14] &amp; v_v_r) &amp; (((((ld_st_miss | tagfl_hit) | aflinv_hit) | alock_miss) | aunlock_hit) | atomic_miss);
	assign retval_op_v = ((decode_v_r[16] | decode_v_r[12]) | decode_v_r[11]) | decode_v_r[4];
	reg stat_mem_v_li;
	reg stat_mem_w_li;
	reg [lg_sets_lp - 1:0] stat_mem_addr_li;
	reg [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] stat_mem_data_li;
	reg [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] stat_mem_w_mask_li;
	wire [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] stat_mem_data_lo;
	bsg_mem_1rw_sync_mask_write_bit #(
		.width_p(stat_info_width_lp),
		.els_p(sets_p),
		.latch_last_read_p(1)
	) stat_mem(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(stat_mem_v_li),
		.w_i(stat_mem_w_li),
		.addr_i(stat_mem_addr_li),
		.data_i(stat_mem_data_li),
		.w_mask_i(stat_mem_w_mask_li),
		.data_o(stat_mem_data_lo)
	);
	wire [3:0] dma_cmd_lo;
	wire [addr_width_p - 1:0] dma_addr_lo;
	wire [lg_ways_lp - 1:0] dma_way_lo;
	wire dma_done_li;
	wire recover_lo;
	wire miss_done_lo;
	wire miss_stat_mem_v_lo;
	wire miss_stat_mem_w_lo;
	wire [lg_sets_lp - 1:0] miss_stat_mem_addr_lo;
	wire [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] miss_stat_mem_data_lo;
	wire [(ways_p + ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) - 1:0] miss_stat_mem_w_mask_lo;
	wire miss_tag_mem_v_lo;
	wire miss_tag_mem_w_lo;
	wire [lg_sets_lp - 1:0] miss_tag_mem_addr_lo;
	wire [(ways_p * (2 + tag_width_lp)) - 1:0] miss_tag_mem_data_lo;
	wire [(ways_p * (2 + tag_width_lp)) - 1:0] miss_tag_mem_w_mask_lo;
	wire sbuf_empty_li;
	wire [lg_ways_lp - 1:0] chosen_way_lo;
	wire select_snoop_data_r_lo;
	bsg_cache_miss #(
		.addr_width_p(addr_width_p),
		.data_width_p(data_width_p),
		.sets_p(sets_p),
		.block_size_in_words_p(block_size_in_words_p),
		.ways_p(ways_p)
	) miss(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.miss_v_i(miss_v),
		.decode_v_i(decode_v_r),
		.addr_v_i(addr_v_r),
		.tag_v_i(tag_v_r),
		.valid_v_i(valid_v_r),
		.lock_v_i(lock_v_r),
		.tag_hit_way_id_i(tag_hit_way_id),
		.tag_hit_v_i(tag_hit_v),
		.tag_hit_found_i(tag_hit_found),
		.sbuf_empty_i(sbuf_empty_li),
		.dma_cmd_o(dma_cmd_lo),
		.dma_way_o(dma_way_lo),
		.dma_addr_o(dma_addr_lo),
		.dma_done_i(dma_done_li),
		.stat_info_i(stat_mem_data_lo),
		.stat_mem_v_o(miss_stat_mem_v_lo),
		.stat_mem_w_o(miss_stat_mem_w_lo),
		.stat_mem_addr_o(miss_stat_mem_addr_lo),
		.stat_mem_data_o(miss_stat_mem_data_lo),
		.stat_mem_w_mask_o(miss_stat_mem_w_mask_lo),
		.tag_mem_v_o(miss_tag_mem_v_lo),
		.tag_mem_w_o(miss_tag_mem_w_lo),
		.tag_mem_addr_o(miss_tag_mem_addr_lo),
		.tag_mem_data_o(miss_tag_mem_data_lo),
		.tag_mem_w_mask_o(miss_tag_mem_w_mask_lo),
		.recover_o(recover_lo),
		.done_o(miss_done_lo),
		.chosen_way_o(chosen_way_lo),
		.ack_i(v_o &amp; yumi_i),
		.select_snoop_data_r_o(select_snoop_data_r_lo)
	);
	wire [data_width_p - 1:0] snoop_word_lo;
	wire dma_data_mem_v_lo;
	wire dma_data_mem_w_lo;
	wire [lg_data_mem_els_lp - 1:0] dma_data_mem_addr_lo;
	wire [(ways_p * dma_data_mask_width_lp) - 1:0] dma_data_mem_w_mask_lo;
	wire [(ways_p * dma_data_width_p) - 1:0] dma_data_mem_data_lo;
	wire dma_evict_lo;
	wire dma_pkt_yumi_i;
	wire dma_data_v_i;
	wire dma_data_yumi_i;
	bsg_cache_dma #(
		.addr_width_p(addr_width_p),
		.data_width_p(data_width_p),
		.block_size_in_words_p(block_size_in_words_p),
		.sets_p(sets_p),
		.ways_p(ways_p),
		.dma_data_width_p(dma_data_width_p),
		.debug_p(debug_p)
	) dma(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.dma_cmd_i(dma_cmd_lo),
		.dma_way_i(dma_way_lo),
		.dma_addr_i(dma_addr_lo),
		.done_o(dma_done_li),
		.snoop_word_o(snoop_word_lo),
		.dma_pkt_o(dma_pkt_o),
		.dma_pkt_v_o(dma_pkt_v_o),
		.dma_pkt_yumi_i(dma_pkt_yumi_i),
		.dma_data_i(dma_data_i),
		.dma_data_v_i(dma_data_v_i),
		.dma_data_ready_o(dma_data_ready_o),
		.dma_data_o(dma_data_o),
		.dma_data_v_o(dma_data_v_o),
		.dma_data_yumi_i(dma_data_yumi_i),
		.data_mem_v_o(dma_data_mem_v_lo),
		.data_mem_w_o(dma_data_mem_w_lo),
		.data_mem_addr_o(dma_data_mem_addr_lo),
		.data_mem_w_mask_o(dma_data_mem_w_mask_lo),
		.data_mem_data_o(dma_data_mem_data_lo),
		.data_mem_data_i(data_mem_data_lo),
		.dma_evict_o(dma_evict_lo)
	);
	wire sbuf_v_li;
	reg [(((addr_width_p + data_width_p) + (data_width_p &gt;&gt; 3)) + (ways_p == 1 ? 1 : $clog2(ways_p))) - 1:0] sbuf_entry_li;
	wire sbuf_v_lo;
	wire sbuf_yumi_li;
	wire [(((addr_width_p + data_width_p) + (data_width_p &gt;&gt; 3)) + (ways_p == 1 ? 1 : $clog2(ways_p))) - 1:0] sbuf_entry_lo;
	wire [addr_width_p - 1:0] bypass_addr_li;
	wire bypass_v_li;
	wire [data_width_p - 1:0] bypass_data_lo;
	wire [data_mask_width_lp - 1:0] bypass_mask_lo;
	wire sbuf_full_lo;
	bsg_cache_sbuf #(
		.data_width_p(data_width_p),
		.addr_width_p(addr_width_p),
		.ways_p(ways_p)
	) sbuf(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.sbuf_entry_i(sbuf_entry_li),
		.v_i(sbuf_v_li),
		.sbuf_entry_o(sbuf_entry_lo),
		.v_o(sbuf_v_lo),
		.yumi_i(sbuf_yumi_li),
		.empty_o(sbuf_empty_li),
		.full_o(sbuf_full_lo),
		.bypass_addr_i(bypass_addr_li),
		.bypass_v_i(bypass_v_li),
		.bypass_data_o(bypass_data_lo),
		.bypass_mask_o(bypass_mask_lo)
	);
	wire [ways_p - 1:0] sbuf_way_decode;
	bsg_decode #(.num_out_p(ways_p)) sbuf_way_demux(
		.i(sbuf_entry_lo[(ways_p == 1 ? 1 : $clog2(ways_p)) - 1-:(ways_p == 1 ? 1 : $clog2(ways_p))]),
		.o(sbuf_way_decode)
	);
	wire [burst_size_in_words_lp - 1:0] sbuf_burst_offset_decode;
	bsg_decode #(.num_out_p(burst_size_in_words_lp)) sbuf_bo_demux(
		.i(sbuf_entry_lo[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) - ((addr_width_p - 1) - lg_data_mask_width_lp)+:lg_burst_size_in_words_lp]),
		.o(sbuf_burst_offset_decode)
	);
	wire [dma_data_mask_width_lp - 1:0] sbuf_expand_mask;
	bsg_expand_bitmask #(
		.in_width_p(burst_size_in_words_lp),
		.expand_p(data_mask_width_lp)
	) expand0(
		.i(sbuf_burst_offset_decode),
		.o(sbuf_expand_mask)
	);
	wire [(ways_p * dma_data_mask_width_lp) - 1:0] sbuf_data_mem_w_mask;
	wire [(ways_p * dma_data_width_p) - 1:0] sbuf_data_mem_data;
	wire [lg_data_mem_els_lp - 1:0] sbuf_data_mem_addr;
	generate
		for (i = 0; i &lt; ways_p; i = i + 1) begin
			assign sbuf_data_mem_data[i * dma_data_width_p+:dma_data_width_p] = {burst_size_in_words_lp {sbuf_entry_lo[data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))-:((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) &gt;= ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) ? ((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) - ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p)))) + 1 : (((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) - (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) + 1)]}};
			assign sbuf_data_mem_w_mask[i * dma_data_mask_width_lp+:dma_data_mask_width_lp] = (sbuf_way_decode[i] ? sbuf_expand_mask &amp; {burst_size_in_words_lp {sbuf_entry_lo[(data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)-:(((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)) &gt;= (ways_p == 1 ? 1 : $clog2(ways_p)) ? (((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)) - (ways_p == 1 ? 1 : $clog2(ways_p))) + 1 : ((ways_p == 1 ? 1 : $clog2(ways_p)) - ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) + 1)]}} : {dma_data_mask_width_lp {1&#39;sb0}});
		end
	endgenerate
	generate
		if (burst_len_lp == 1) assign sbuf_data_mem_addr = sbuf_entry_lo[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) - ((addr_width_p - 1) - (lg_data_mask_width_lp + lg_block_size_in_words_lp))+:lg_sets_lp];
		else if (burst_len_lp == block_size_in_words_p) assign sbuf_data_mem_addr = sbuf_entry_lo[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) - ((addr_width_p - 1) - lg_data_mask_width_lp)+:lg_block_size_in_words_lp + lg_sets_lp];
		else assign sbuf_data_mem_addr = sbuf_entry_lo[(addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) - ((addr_width_p - 1) - (lg_data_mask_width_lp + lg_burst_size_in_words_lp))+:lg_burst_len_lp + lg_sets_lp];
	endgenerate
	wire [(data_sel_mux_els_lp * data_width_p) - 1:0] sbuf_data_in_mux_li;
	wire [(data_sel_mux_els_lp * data_mask_width_lp) - 1:0] sbuf_mask_in_mux_li;
	wire [data_width_p - 1:0] sbuf_data_in;
	wire [data_mask_width_lp - 1:0] sbuf_mask_in;
	wire [data_width_p - 1:0] snoop_or_ld_data;
	wire [(data_sel_mux_els_lp * data_width_p) - 1:0] ld_data_final_li;
	wire [data_width_p - 1:0] ld_data_final_lo;
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(data_sel_mux_els_lp)
	) sbuf_data_in_mux(
		.data_i(sbuf_data_in_mux_li),
		.sel_i(decode_v_r[19+:lg_data_sel_mux_els_lp]),
		.data_o(sbuf_data_in)
	);
	bsg_mux #(
		.width_p(data_mask_width_lp),
		.els_p(data_sel_mux_els_lp)
	) sbuf_mask_in_mux(
		.data_i(sbuf_mask_in_mux_li),
		.sel_i(decode_v_r[19+:lg_data_sel_mux_els_lp]),
		.data_o(sbuf_mask_in)
	);
	wire [(data_width_p &lt; 64 ? data_width_p : 64) - 1:0] atomic_reg_data;
	wire [(data_width_p &lt; 64 ? data_width_p : 64) - 1:0] atomic_mem_data;
	reg [(data_width_p &lt; 64 ? data_width_p : 64) - 1:0] atomic_alu_result;
	wire [(data_width_p &lt; 64 ? data_width_p : 64) - 1:0] atomic_result;
	generate
		if (data_width_p &gt;= 64) begin : atomic_64
			wire [63:0] amo32_reg_in = data_v_r[0+:32] &lt;&lt; 32;
			wire [63:0] amo64_reg_in = data_v_r[0+:64];
			assign atomic_reg_data = (decode_v_r[19] ? amo64_reg_in : amo32_reg_in);
			wire [63:0] amo32_mem_in = ld_data_final_li[2 * data_width_p+:data_width_p] &lt;&lt; 32;
			wire [63:0] amo64_mem_in = ld_data_final_li[3 * data_width_p+:data_width_p];
			assign atomic_mem_data = (decode_v_r[19] ? amo64_mem_in : amo32_mem_in);
		end
		else if (data_width_p &gt;= 32) begin : atomic_32
			assign atomic_reg_data = data_v_r[0+:32];
			assign atomic_mem_data = ld_data_final_li[2 * data_width_p+:data_width_p];
		end
	endgenerate
	always @(*)
		casez ({amo_support_p[decode_v_r[3-:4]], decode_v_r[3-:4]})
			{1&#39;b1, e_cache_amo_swap}: atomic_alu_result = atomic_reg_data;
			{1&#39;b1, e_cache_amo_and}: atomic_alu_result = atomic_reg_data &amp; atomic_mem_data;
			{1&#39;b1, e_cache_amo_or}: atomic_alu_result = atomic_reg_data | atomic_mem_data;
			{1&#39;b1, e_cache_amo_xor}: atomic_alu_result = atomic_reg_data ^ atomic_mem_data;
			{1&#39;b1, e_cache_amo_add}: atomic_alu_result = atomic_reg_data + atomic_mem_data;
			{1&#39;b1, e_cache_amo_min}: atomic_alu_result = ($signed(atomic_reg_data) &lt; $signed(atomic_mem_data) ? atomic_reg_data : atomic_mem_data);
			{1&#39;b1, e_cache_amo_max}: atomic_alu_result = ($signed(atomic_reg_data) &gt; $signed(atomic_mem_data) ? atomic_reg_data : atomic_mem_data);
			{1&#39;b1, e_cache_amo_minu}: atomic_alu_result = (atomic_reg_data &lt; atomic_mem_data ? atomic_reg_data : atomic_mem_data);
			{1&#39;b1, e_cache_amo_maxu}: atomic_alu_result = (atomic_reg_data &gt; atomic_mem_data ? atomic_reg_data : atomic_mem_data);
			{1&#39;b0, 4&#39;bzzzz}: atomic_alu_result = {(data_width_p &lt; 64 ? data_width_p : 64) {1&#39;sbx}};
			default: atomic_alu_result = {(data_width_p &lt; 64 ? data_width_p : 64) {1&#39;sb0}};
		endcase
	generate
		if (data_width_p &gt;= 64) begin : fi
			wire [63:0] amo32_out = atomic_alu_result &gt;&gt; 32;
			wire [63:0] amo64_out = atomic_alu_result;
			assign atomic_result = (decode_v_r[19] ? amo64_out : amo32_out);
		end
		else assign atomic_result = atomic_alu_result;
	endgenerate
	generate
		for (i = 0; i &lt; data_sel_mux_els_lp; i = i + 1) begin : sbuf_in_sel
			localparam slice_width_lp = 8 * (2 ** i);
			wire [slice_width_lp - 1:0] slice_data;
			if ((i == 2&#39;b10) || (i == 2&#39;b11)) begin : atomic_in_sel
				assign slice_data = (decode_v_r[4] ? atomic_result[0+:slice_width_lp] : data_v_r[0+:slice_width_lp]);
			end
			else assign slice_data = data_v_r[0+:slice_width_lp];
			assign sbuf_data_in_mux_li[i * data_width_p+:data_width_p] = {data_width_p / slice_width_lp {slice_data}};
			if (i == (data_sel_mux_els_lp - 1)) begin : max_size
				assign sbuf_mask_in_mux_li[i * data_mask_width_lp+:data_mask_width_lp] = {data_mask_width_lp {1&#39;b1}};
			end
			else begin : non_max_size
				wire [(data_width_p / slice_width_lp) - 1:0] decode_lo;
				bsg_decode #(.num_out_p(data_width_p / slice_width_lp)) dec(
					.i(addr_v_r[i+:((lg_data_mask_width_lp - i) &gt; 1 ? lg_data_mask_width_lp - i : 1)]),
					.o(decode_lo)
				);
				bsg_expand_bitmask #(
					.in_width_p(data_width_p / slice_width_lp),
					.expand_p(2 ** i)
				) exp(
					.i(decode_lo),
					.o(sbuf_mask_in_mux_li[i * data_mask_width_lp+:data_mask_width_lp])
				);
			end
		end
	endgenerate
	always @(*)
		if (decode_v_r[17]) begin
			sbuf_entry_li[data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))-:((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) &gt;= ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) ? ((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) - ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p)))) + 1 : (((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) - (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) + 1)] = data_v_r;
			sbuf_entry_li[(data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)-:(((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)) &gt;= (ways_p == 1 ? 1 : $clog2(ways_p)) ? (((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)) - (ways_p == 1 ? 1 : $clog2(ways_p))) + 1 : ((ways_p == 1 ? 1 : $clog2(ways_p)) - ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) + 1)] = mask_v_r;
		end
		else begin
			sbuf_entry_li[data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))-:((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) &gt;= ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) ? ((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) - ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p)))) + 1 : (((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) - (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) + 1)] = sbuf_data_in;
			sbuf_entry_li[(data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)-:(((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)) &gt;= (ways_p == 1 ? 1 : $clog2(ways_p)) ? (((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)) - (ways_p == 1 ? 1 : $clog2(ways_p))) + 1 : ((ways_p == 1 ? 1 : $clog2(ways_p)) - ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) + 1)] = sbuf_mask_in;
		end
	wire [dma_data_width_p - 1:0] ld_data_way_picked;
	wire [data_width_p - 1:0] ld_data_offset_picked;
	wire [data_width_p - 1:0] bypass_data_masked;
	wire [data_width_p - 1:0] ld_data_masked;
	bsg_mux #(
		.width_p(dma_data_width_p),
		.els_p(ways_p)
	) ld_data_mux(
		.data_i(ld_data_v_r),
		.sel_i(tag_hit_way_id),
		.data_o(ld_data_way_picked)
	);
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(burst_size_in_words_lp)
	) mux00(
		.data_i(ld_data_way_picked),
		.sel_i(addr_v_r[lg_data_mask_width_lp+:lg_burst_size_in_words_lp]),
		.data_o(ld_data_offset_picked)
	);
	bsg_mux_segmented #(
		.segments_p(data_mask_width_lp),
		.segment_width_p(8)
	) bypass_mux_segmented(
		.data0_i(ld_data_offset_picked),
		.data1_i(bypass_data_lo),
		.sel_i(bypass_mask_lo),
		.data_o(bypass_data_masked)
	);
	assign snoop_or_ld_data = (select_snoop_data_r_lo ? snoop_word_lo : bypass_data_masked);
	wire [data_width_p - 1:0] expanded_mask_v;
	bsg_expand_bitmask #(
		.in_width_p(data_mask_width_lp),
		.expand_p(8)
	) mask_v_expand(
		.i(mask_v_r),
		.o(expanded_mask_v)
	);
	assign ld_data_masked = snoop_or_ld_data &amp; expanded_mask_v;
	generate
		for (i = 0; i &lt; data_sel_mux_els_lp; i = i + 1) begin : ld_data_sel
			if (i == (data_sel_mux_els_lp - 1)) begin : max_size
				assign ld_data_final_li[i * data_width_p+:data_width_p] = snoop_or_ld_data;
			end
			else begin : non_max_size
				wire [(8 * (2 ** i)) - 1:0] byte_sel;
				bsg_mux #(
					.width_p(8 * (2 ** i)),
					.els_p(data_width_p / (8 * (2 ** i)))
				) byte_mux(
					.data_i(snoop_or_ld_data),
					.sel_i(addr_v_r[i+:((lg_data_mask_width_lp - i) &gt; 1 ? lg_data_mask_width_lp - i : 1)]),
					.data_o(byte_sel)
				);
				assign ld_data_final_li[i * data_width_p+:data_width_p] = {{data_width_p - (8 * (2 ** i)) {decode_v_r[18] &amp; byte_sel[(8 * (2 ** i)) - 1]}}, byte_sel};
			end
		end
	endgenerate
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(data_sel_mux_els_lp)
	) ld_data_size_mux(
		.data_i(ld_data_final_li),
		.sel_i(decode_v_r[19+:lg_data_sel_mux_els_lp]),
		.data_o(ld_data_final_lo)
	);
	always @(*)
		if (retval_op_v) begin
			if (decode_v_r[12])
				data_o = {{data_width_p - 2 {1&#39;b0}}, lock_v_r[addr_way_v], valid_v_r[addr_way_v]};
			else if (decode_v_r[11])
				data_o = {tag_v_r[addr_way_v * tag_width_lp+:tag_width_lp], addr_index_v, {lg_block_size_in_words_lp + lg_data_mask_width_lp {1&#39;b0}}};
			else if (decode_v_r[17])
				data_o = ld_data_masked;
			else
				data_o = ld_data_final_lo;
		end
		else
			data_o = {data_width_p {1&#39;sb0}};
	assign v_o = v_v_r &amp; (miss_v ? miss_done_lo : 1&#39;b1);
	assign v_we = (v_v_r ? v_o &amp; yumi_i : 1&#39;b1);
	assign sbuf_hazard = (sbuf_full_lo &amp; ((v_o &amp; yumi_i) &amp; (decode_v_r[15] | decode_v_r[4]))) &amp; (v_i &amp; (decode[16] | decode[4]));
	wire tl_ready = (miss_v ? (((~(decode[14] &amp; v_i) &amp; ~miss_tag_mem_v_lo) &amp; ~dma_data_mem_v_lo) &amp; ~recover_lo) &amp; ~dma_evict_lo : 1&#39;b1) &amp; ~sbuf_hazard;
	assign ready_o = (v_tl_r ? v_we &amp; tl_ready : tl_ready);
	wire tagst_valid;
	wire tagst_lock;
	wire [tag_width_lp - 1:0] tagst_tag;
	wire tagst_write_en;
	assign tagst_valid = cache_pkt[(data_width_p + ((data_width_p &gt;&gt; 3) - 1)) - ((data_width_p - 1) - (data_width_p - 1))];
	assign tagst_lock = cache_pkt[(data_width_p + ((data_width_p &gt;&gt; 3) - 1)) - ((data_width_p - 1) - (data_width_p - 2))];
	assign tagst_tag = cache_pkt[(data_width_p + ((data_width_p &gt;&gt; 3) - 1)) - (data_width_p - 1)+:tag_width_lp];
	assign tagst_write_en = (decode[14] &amp; ready_o) &amp; v_i;
	wire [ways_p - 1:0] addr_way_decode;
	bsg_decode #(.num_out_p(ways_p)) addr_way_demux(
		.i(addr_way),
		.o(addr_way_decode)
	);
	assign tag_mem_v_li = ((((decode[5] &amp; ready_o) &amp; v_i) | ((recover_lo &amp; decode_tl_r[5]) &amp; v_tl_r)) | miss_tag_mem_v_lo) | ((decode[14] &amp; ready_o) &amp; v_i);
	assign tag_mem_w_li = (miss_v ? miss_tag_mem_w_lo : tagst_write_en);
	always @(*)
		if (miss_v) begin
			tag_mem_addr_li = (recover_lo ? addr_index_tl : (miss_tag_mem_v_lo ? miss_tag_mem_addr_lo : addr_index));
			tag_mem_data_li = miss_tag_mem_data_lo;
			tag_mem_w_mask_li = miss_tag_mem_w_mask_lo;
		end
		else begin
			tag_mem_addr_li = addr_index;
			begin : sv2v_autoblock_1
				integer i;
				for (i = 0; i &lt; ways_p; i = i + 1)
					begin
						tag_mem_data_li[i * (2 + tag_width_lp)+:2 + tag_width_lp] = {tagst_valid, tagst_lock, tagst_tag};
						tag_mem_w_mask_li[i * (2 + tag_width_lp)+:2 + tag_width_lp] = {tag_info_width_lp {addr_way_decode[i]}};
					end
			end
		end
	assign data_mem_v_li = ((((v_i &amp; ready_o) &amp; (decode[16] | decode[4])) | ((v_tl_r &amp; recover_lo) &amp; (decode_tl_r[16] | decode_tl_r[4]))) | dma_data_mem_v_lo) | (sbuf_v_lo &amp; sbuf_yumi_li);
	assign data_mem_w_li = dma_data_mem_w_lo | (sbuf_v_lo &amp; sbuf_yumi_li);
	assign data_mem_data_li = (dma_data_mem_w_lo ? dma_data_mem_data_lo : sbuf_data_mem_data);
	assign data_mem_addr_li = (recover_lo ? recover_data_mem_addr : (dma_data_mem_v_lo ? dma_data_mem_addr_lo : (((decode[16] | decode[4]) &amp; v_i) &amp; ready_o ? ld_data_mem_addr : sbuf_data_mem_addr)));
	assign data_mem_w_mask_li = (dma_data_mem_w_lo ? dma_data_mem_w_mask_lo : sbuf_data_mem_w_mask);
	wire [ways_p - 2:0] plru_decode_data_lo;
	wire [ways_p - 2:0] plru_decode_mask_lo;
	bsg_lru_pseudo_tree_decode #(.ways_p(ways_p)) plru_decode(
		.way_id_i(tag_hit_way_id),
		.data_o(plru_decode_data_lo),
		.mask_o(plru_decode_mask_lo)
	);
	always @(*)
		if (miss_v) begin
			stat_mem_v_li = miss_stat_mem_v_lo;
			stat_mem_w_li = miss_stat_mem_w_lo;
			stat_mem_addr_li = miss_stat_mem_addr_lo;
			stat_mem_data_li = miss_stat_mem_data_lo;
			stat_mem_w_mask_li = miss_stat_mem_w_mask_lo;
		end
		else begin
			stat_mem_v_li = ((((decode_v_r[15] | decode_v_r[16]) | decode_v_r[14]) | decode_v_r[4]) &amp; v_o) &amp; yumi_i;
			stat_mem_w_li = ((((decode_v_r[15] | decode_v_r[16]) | decode_v_r[14]) | decode_v_r[4]) &amp; v_o) &amp; yumi_i;
			stat_mem_addr_li = addr_index_v;
			if (decode_v_r[14]) begin
				stat_mem_data_li[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = {ways_p {1&#39;b0}};
				stat_mem_data_li[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = {ways_p - 1 {1&#39;b0}};
				stat_mem_w_mask_li[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = {ways_p {1&#39;b1}};
				stat_mem_w_mask_li[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = {ways_p - 1 {1&#39;b1}};
			end
			else begin
				stat_mem_data_li[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = {ways_p {decode_v_r[15] | decode_v_r[4]}};
				stat_mem_data_li[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = plru_decode_data_lo;
				stat_mem_w_mask_li[ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)-:((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) &gt;= ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) ? ((ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1)) - ((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)) + 1 : (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - (ways_p + (((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1))) + 1)] = {ways_p {decode_v_r[15] | decode_v_r[4]}} &amp; tag_hit_v;
				stat_mem_w_mask_li[((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p) - 1-:((ways_p - 2) &gt;= 0 ? ways_p - 1 : 3 - ways_p)] = plru_decode_mask_lo;
			end
		end
	assign sbuf_v_li = ((decode_v_r[15] | decode_v_r[4]) &amp; v_o) &amp; yumi_i;
	always @(*) sbuf_entry_li[(ways_p == 1 ? 1 : $clog2(ways_p)) - 1-:(ways_p == 1 ? 1 : $clog2(ways_p))] = (miss_v ? chosen_way_lo : tag_hit_way_id);
	always @(*) sbuf_entry_li[addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))-:((addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) &gt;= (data_width_p + ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p)))) ? ((addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) - (data_width_p + ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))))) + 1 : ((data_width_p + ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p)))) - (addr_width_p + (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))))) + 1)] = addr_v_r;
	assign sbuf_yumi_li = ((sbuf_v_lo &amp; ~(((decode[16] | decode[4]) &amp; v_i) &amp; ready_o)) &amp; ~dma_data_mem_v_lo) &amp; ~(((v_tl_r &amp; (decode_tl_r[16] | decode_tl_r[4])) &amp; ~v_we) &amp; ~miss_v);
	assign bypass_addr_li = addr_tl_r;
	assign bypass_v_li = ((decode_tl_r[16] | decode_tl_r[4]) &amp; v_tl_r) &amp; v_we;
	always @(negedge clk_i)
		if (~reset_i)
			if (v_v_r)
				;
	generate
		if (debug_p) always @(posedge clk_i) begin
			if (v_o &amp; yumi_i) begin
				if (decode_v_r[16])
					$display(&#34;&lt;VCACHE&gt; M[%4h] == %8h // %8t&#34;, addr_v_r, data_o, $time);
				if (decode_v_r[15])
					$display(&#34;&lt;VCACHE&gt; M[%4h] := %8h // %8t&#34;, addr_v_r, sbuf_entry_li[data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))-:((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) &gt;= ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) ? ((data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1))) - ((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p)))) + 1 : (((data_width_p &gt;&gt; 3) + (ways_p == 1 ? 1 : $clog2(ways_p))) - (data_width_p + ((data_width_p &gt;&gt; 3) + ((ways_p == 1 ? 1 : $clog2(ways_p)) - 1)))) + 1)], $time);
			end
			if (tag_mem_v_li &amp; tag_mem_w_li)
				$display(&#34;&lt;VCACHE&gt; tag_mem_write. addr=%8h data_1=%8h data_0=%8h mask_1=%8h mask_0=%8h // %8t&#34;, tag_mem_addr_li, tag_mem_data_li[(2 + tag_width_lp) * (1 + tag_width_lp)+:(2 + tag_width_lp) * (1 + tag_width_lp)], tag_mem_data_li[0+:(2 + tag_width_lp) * (1 + tag_width_lp)], tag_mem_w_mask_li[(2 + tag_width_lp) * (1 + tag_width_lp)+:(2 + tag_width_lp) * (1 + tag_width_lp)], tag_mem_w_mask_li[0+:(2 + tag_width_lp) * (1 + tag_width_lp)], $time);
		end
	endgenerate
endmodule

</pre>
</body>
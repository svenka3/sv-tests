<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_data_mem.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_data_mem.v</a>
defines: 
time_elapsed: 0.710s
ram usage: 14992 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_data_mem.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_data_mem.v</a>
module bsg_cache_non_blocking_data_mem (
	clk_i,
	reset_i,
	v_i,
	data_mem_pkt_i,
	data_o
);
	localparam [4:0] LB = 5&#39;b00000;
	localparam [4:0] LH = 5&#39;b00001;
	localparam [4:0] LW = 5&#39;b00010;
	localparam [4:0] LD = 5&#39;b00011;
	localparam [4:0] LBU = 5&#39;b00100;
	localparam [4:0] LHU = 5&#39;b00101;
	localparam [4:0] LWU = 5&#39;b00110;
	localparam [4:0] SB = 5&#39;b01000;
	localparam [4:0] SH = 5&#39;b01001;
	localparam [4:0] SW = 5&#39;b01010;
	localparam [4:0] SD = 5&#39;b01011;
	localparam [4:0] SM = 5&#39;b01101;
	localparam [4:0] BLOCK_LD = 5&#39;b01110;
	localparam [4:0] TAGST = 5&#39;b10000;
	localparam [4:0] TAGFL = 5&#39;b10001;
	localparam [4:0] TAGLV = 5&#39;b10010;
	localparam [4:0] TAGLA = 5&#39;b10011;
	localparam [4:0] AFL = 5&#39;b11000;
	localparam [4:0] AFLINV = 5&#39;b11001;
	localparam [4:0] AINV = 5&#39;b11010;
	localparam [4:0] ALOCK = 5&#39;b11011;
	localparam [4:0] AUNLOCK = 5&#39;b11100;
	localparam [2:0] e_tag_read = 0;
	localparam [2:0] e_tag_store = 1;
	localparam [2:0] e_tag_set_tag = 2;
	localparam [2:0] e_tag_set_tag_and_lock = 3;
	localparam [2:0] e_tag_invalidate = 4;
	localparam [2:0] e_tag_lock = 5;
	localparam [2:0] e_tag_unlock = 6;
	localparam [2:0] e_stat_read = 0;
	localparam [2:0] e_stat_clear_dirty = 1;
	localparam [2:0] e_stat_set_lru = 2;
	localparam [2:0] e_stat_set_lru_and_dirty = 3;
	localparam [2:0] e_stat_set_lru_and_clear_dirty = 4;
	localparam [2:0] e_stat_reset = 5;
	localparam [1:0] e_miss_fifo_dequeue = 0;
	localparam [1:0] e_miss_fifo_skip = 1;
	localparam [1:0] e_miss_fifo_invalidate = 2;
	localparam [3:0] MHU_IDLE = 0;
	localparam [3:0] MGMT_OP = 1;
	localparam [3:0] SEND_MGMT_DMA = 2;
	localparam [3:0] WAIT_MGMT_DMA = 3;
	localparam [3:0] READ_TAG1 = 4;
	localparam [3:0] SEND_DMA_REQ1 = 5;
	localparam [3:0] WAIT_DMA_DONE = 6;
	localparam [3:0] DEQUEUE_MODE = 7;
	localparam [3:0] READ_TAG2 = 8;
	localparam [3:0] SEND_DMA_REQ2 = 9;
	localparam [3:0] SCAN_MODE = 10;
	localparam [3:0] RECOVER = 11;
	parameter _sv2v_width_data_width_p = 24;
	parameter [_sv2v_width_data_width_p - 1:0] data_width_p = &#34;inv&#34;;
	parameter _sv2v_width_ways_p = 24;
	parameter [_sv2v_width_ways_p - 1:0] ways_p = &#34;inv&#34;;
	parameter _sv2v_width_sets_p = 24;
	parameter [_sv2v_width_sets_p - 1:0] sets_p = &#34;inv&#34;;
	parameter _sv2v_width_block_size_in_words_p = 24;
	parameter [_sv2v_width_block_size_in_words_p - 1:0] block_size_in_words_p = &#34;inv&#34;;
	parameter lg_ways_lp = (ways_p == 1 ? 1 : $clog2(ways_p));
	parameter lg_sets_lp = (sets_p == 1 ? 1 : $clog2(sets_p));
	parameter lg_block_size_in_words_lp = (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p));
	parameter byte_sel_width_lp = ((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3));
	parameter data_mem_pkt_width_lp = (((((5 + ((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3))) + (ways_p == 1 ? 1 : $clog2(ways_p))) + (sets_p == 1 ? 1 : $clog2(sets_p))) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + data_width_p) + (data_width_p &gt;&gt; 3);
	input clk_i;
	input reset_i;
	input v_i;
	input [data_mem_pkt_width_lp - 1:0] data_mem_pkt_i;
	output wire [data_width_p - 1:0] data_o;
	localparam data_mask_width_lp = data_width_p &gt;&gt; 3;
	localparam data_bank_addr_width_lp = (lg_ways_lp + lg_sets_lp) + lg_block_size_in_words_lp;
	localparam data_sel_mux_els_lp = (4 &lt; (byte_sel_width_lp + 1) ? 4 : byte_sel_width_lp + 1);
	localparam lg_data_sel_mux_els_lp = (data_sel_mux_els_lp == 1 ? 1 : $clog2(data_sel_mux_els_lp));
	wire [(((((5 + ((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3))) + (ways_p == 1 ? 1 : $clog2(ways_p))) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p)))) + data_width_p) + (data_width_p &gt;&gt; 3)) - 1:0] data_mem_pkt;
	assign data_mem_pkt = data_mem_pkt_i;
	wire [data_bank_addr_width_lp - 1:0] addr_li;
	wire [data_width_p - 1:0] data_li;
	wire [data_mask_width_lp - 1:0] mask_li;
	wire [data_width_p - 1:0] data_lo;
	assign addr_li = {data_mem_pkt[(ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))-:(((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))) &gt;= (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3))) ? (((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))) - (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3)))) + 1 : ((((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3))) - ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))) + 1)], data_mem_pkt[((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))-:((((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) &gt;= (data_width_p + (data_width_p &gt;&gt; 3)) ? ((((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) - (data_width_p + (data_width_p &gt;&gt; 3))) + 1 : ((data_width_p + (data_width_p &gt;&gt; 3)) - (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))) + 1)]};
	bsg_mem_1rw_sync_mask_write_byte #(
		.data_width_p(data_width_p),
		.els_p((block_size_in_words_p * sets_p) * ways_p),
		.latch_last_read_p(1)
	) data_mem(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(v_i),
		.w_i(data_mem_pkt[5 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))]),
		.addr_i(addr_li),
		.data_i(data_li),
		.write_mask_i(mask_li),
		.data_o(data_lo)
	);
	wire [(data_sel_mux_els_lp * data_width_p) - 1:0] input_mux_data_li;
	wire [(data_sel_mux_els_lp * data_mask_width_lp) - 1:0] input_mux_mask_li;
	wire [data_width_p - 1:0] input_mux_data_lo;
	wire [data_mask_width_lp - 1:0] input_mux_mask_lo;
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(data_sel_mux_els_lp)
	) input_data_mux(
		.data_i(input_mux_data_li),
		.sel_i(data_mem_pkt[(2 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))) - 1+:lg_data_sel_mux_els_lp]),
		.data_o(input_mux_data_lo)
	);
	bsg_mux #(
		.width_p(data_mask_width_lp),
		.els_p(data_sel_mux_els_lp)
	) input_mask_mux(
		.data_i(input_mux_mask_li),
		.sel_i(data_mem_pkt[(2 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))) - 1+:lg_data_sel_mux_els_lp]),
		.data_o(input_mux_mask_lo)
	);
	generate
		genvar i;
		for (i = 0; i &lt; data_sel_mux_els_lp; i = i + 1) begin : input_sel
			assign input_mux_data_li[i * data_width_p+:data_width_p] = {data_width_p / (8 * (2 ** i)) {data_mem_pkt[(data_width_p + ((data_width_p &gt;&gt; 3) - 1)) - (data_width_p - 1)+:8 * (2 ** i)]}};
			if (i == (data_sel_mux_els_lp - 1)) begin : max_size
				assign input_mux_mask_li[i * data_mask_width_lp+:data_mask_width_lp] = {data_mask_width_lp {1&#39;b1}};
			end
			else begin : non_max_size
				wire [(data_width_p / (8 * (2 ** i))) - 1:0] decode_lo;
				bsg_decode #(.num_out_p(data_width_p / (8 * (2 ** i)))) dec(
					.i(data_mem_pkt[(((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))) - ((((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) - 1) - i)+:((byte_sel_width_lp - i) &gt; 1 ? byte_sel_width_lp - i : 1)]),
					.o(decode_lo)
				);
				bsg_expand_bitmask #(
					.in_width_p(data_width_p / (8 * (2 ** i))),
					.expand_p(2 ** i)
				) exp(
					.i(decode_lo),
					.o(input_mux_mask_li[i * data_mask_width_lp+:data_mask_width_lp])
				);
			end
		end
	endgenerate
	assign data_li = (data_mem_pkt[3 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))] ? data_mem_pkt[data_width_p + ((data_width_p &gt;&gt; 3) - 1)-:((data_width_p + ((data_width_p &gt;&gt; 3) - 1)) &gt;= (data_width_p &gt;&gt; 3) ? ((data_width_p + ((data_width_p &gt;&gt; 3) - 1)) - (data_width_p &gt;&gt; 3)) + 1 : ((data_width_p &gt;&gt; 3) - (data_width_p + ((data_width_p &gt;&gt; 3) - 1))) + 1)] : input_mux_data_lo);
	assign mask_li = (data_mem_pkt[3 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))] ? data_mem_pkt[(data_width_p &gt;&gt; 3) - 1-:data_width_p &gt;&gt; 3] : input_mux_mask_lo);
	wire load_en = v_i &amp; ~data_mem_pkt[5 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))];
	wire sigext_op_r;
	wire [1:0] size_op_r;
	wire [byte_sel_width_lp - 1:0] byte_sel_r;
	bsg_dff_en #(.width_p(3 + byte_sel_width_lp)) op_dff(
		.clk_i(clk_i),
		.en_i(load_en),
		.data_i({data_mem_pkt[4 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))], data_mem_pkt[2 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))-:((2 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))) &gt;= (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3))))) ? ((2 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))) - (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3)))))) + 1 : ((((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3))))) - (2 + (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))))) + 1)], data_mem_pkt[((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))-:((((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))) &gt;= ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3)))) ? ((((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1))))) - ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3))))) + 1 : (((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + (data_width_p &gt;&gt; 3)))) - (((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3)) + ((ways_p == 1 ? 1 : $clog2(ways_p)) + (((sets_p == 1 ? 1 : $clog2(sets_p)) + (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p))) + (data_width_p + ((data_width_p &gt;&gt; 3) - 1)))))) + 1)]}),
		.data_o({sigext_op_r, size_op_r, byte_sel_r})
	);
	wire [(data_sel_mux_els_lp * data_width_p) - 1:0] output_mux_data_li;
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(data_sel_mux_els_lp)
	) output_mux(
		.data_i(output_mux_data_li),
		.sel_i(size_op_r[0+:lg_data_sel_mux_els_lp]),
		.data_o(data_o)
	);
	generate
		for (i = 0; i &lt; data_sel_mux_els_lp; i = i + 1) begin : output_sel
			if (i == (data_sel_mux_els_lp - 1)) begin : max_size
				assign output_mux_data_li[i * data_width_p+:data_width_p] = data_lo;
			end
			else begin : non_max_size
				wire [(8 * (2 ** i)) - 1:0] selected_bytes;
				bsg_mux #(
					.width_p(8 * (2 ** i)),
					.els_p(data_width_p / (8 * (2 ** i)))
				) byte_mux(
					.data_i(data_lo),
					.sel_i(byte_sel_r[i+:((byte_sel_width_lp - i) &gt; 1 ? byte_sel_width_lp - i : 1)]),
					.data_o(selected_bytes)
				);
				assign output_mux_data_li[i * data_width_p+:data_width_p] = {{data_width_p - (8 * (2 ** i)) {sigext_op_r &amp; selected_bytes[(8 * (2 ** i)) - 1]}}, selected_bytes};
			end
		end
	endgenerate
endmodule

</pre>
</body>
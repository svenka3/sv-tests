<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_comm_link
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_slave.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_slave.v</a>
defines: 
time_elapsed: 0.511s
ram usage: 15700 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_comm_link <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_slave.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_slave.v</a>
module bsg_source_sync_channel_control_slave (
	out_clk_i,
	out_reset_i,
	out_clk_init_r_o,
	out_override_en_o,
	out_override_valid_data_o,
	in_snoop_valid_data_i,
	in_clk_i,
	in_trigger_mode_en_o,
	in_trigger_mode_alt_en_o,
	out_infinite_credits_o,
	core_clk_i,
	core_loopback_en_o,
	out_channel_active_o
);
	parameter width_p = -1;
	parameter _sv2v_width_lg_token_width_p = 24;
	parameter [_sv2v_width_lg_token_width_p - 1:0] lg_token_width_p = &#34;inv&#34;;
	input out_clk_i;
	input out_reset_i;
	output reg out_clk_init_r_o;
	output out_override_en_o;
	output [width_p:0] out_override_valid_data_o;
	input [width_p:0] in_snoop_valid_data_i;
	input in_clk_i;
	output in_trigger_mode_en_o;
	output in_trigger_mode_alt_en_o;
	output reg out_infinite_credits_o;
	input core_clk_i;
	output core_loopback_en_o;
	output out_channel_active_o;
	wire [4:0] out_snoop_valid_data;
	wire out_active_mismatch;
	wire [(((width_p + 1) &gt;&gt; 1) &lt;&lt; 1) - 1:0] out_active_pattern = {(width_p + 1) &gt;&gt; 1 {2&#39;b10}};
	generate
		if (width_p &gt;= 4) assign out_snoop_valid_data = in_snoop_valid_data_i[width_p-:5];
		else assign out_snoop_valid_data = {in_snoop_valid_data_i[width_p-:4], 1&#39;b0};
	endgenerate
	generate
		if (width_p &lt;= 4) assign out_active_mismatch = 1&#39;b0;
		else assign out_active_mismatch = |(out_active_pattern[width_p - 5:0] ^ in_snoop_valid_data_i[width_p - 5:0]);
	endgenerate
	reg [3:0] out_state_n;
	reg [3:0] out_state_r;
	localparam [3:0] sBegin = 0;
	always @(posedge out_clk_i)
		if (out_reset_i)
			out_state_r &lt;= sBegin;
		else
			out_state_r &lt;= out_state_n;
	localparam [3:0] sActive = 5;
	localparam [3:0] sInactive = 6;
	localparam [3:0] sPhase1 = 1;
	localparam [3:0] sPhase2 = 2;
	localparam [3:0] sPhase3 = 3;
	localparam [3:0] sPhase4 = 4;
	localparam [3:0] sResetClock = 7;
	always @(*) begin
		out_state_n = out_state_r;
		if (out_state_r == sBegin)
			casez (out_snoop_valid_data)
				5&#39;b0z111: out_state_n = sResetClock;
				5&#39;b01z10: out_state_n = sResetClock;
				5&#39;b01011: out_state_n = sResetClock;
				5&#39;b01101: out_state_n = sResetClock;
				5&#39;b11111: out_state_n = sResetClock;
				5&#39;b00100: out_state_n = sPhase1;
				5&#39;b00101: out_state_n = sPhase2;
				5&#39;b00010: out_state_n = sPhase3;
				5&#39;b00011: out_state_n = sPhase4;
				5&#39;b00110: out_state_n = (out_active_mismatch ? sInactive : sActive);
				5&#39;b0100z: out_state_n = sInactive;
				default: out_state_n = sPhase3;
			endcase
	end
	localparam counter_min_bits_lp = 24;
	localparam counter_bits_lp = (counter_min_bits_lp &gt; (((width_p + 1) * 2) + 1) ? counter_min_bits_lp : ((width_p + 1) * 2) + 1);
	reg [counter_bits_lp - 1:0] out_ctr_r;
	reg [counter_bits_lp - 1:0] out_ctr_n;
	reg [7:0] out_rot_r;
	reg [7:0] out_rot_n;
	reg [width_p:0] out_override_valid_data_r;
	reg [width_p:0] out_override_valid_data_n;
	reg out_override_en_r;
	reg out_override_en_n;
	assign out_override_valid_data_o = out_override_valid_data_r;
	wire out_override_en_o;
	assign out_override_en_o = out_override_en_r;
	reg out_reset_r;
	function automatic [counter_bits_lp - 1:0] sv2v_cast_2CCCC;
		input reg [counter_bits_lp - 1:0] inp;
		sv2v_cast_2CCCC = inp;
	endfunction
	always @(posedge out_clk_i) begin
		out_reset_r &lt;= out_reset_i;
		out_clk_init_r_o &lt;= (~out_reset_i &amp; (out_state_n == sResetClock)) &amp; (out_state_r == sBegin);
		out_override_en_r &lt;= out_override_en_n;
		if (out_reset_i ^ out_reset_r) begin
			out_ctr_r &lt;= sv2v_cast_2CCCC(0);
			out_override_valid_data_r &lt;= {width_p + 1 {1&#39;b0}};
		end
		else begin
			out_ctr_r &lt;= out_ctr_n;
			out_override_valid_data_r &lt;= out_override_valid_data_n;
		end
		if (out_state_r == sBegin)
			out_rot_r &lt;= 8&#39;b10100101;
		else
			out_rot_r &lt;= out_rot_n;
	end
	always @(out_state_r)
		$display(&#34;## Slave %m entering state %s with in_snoop_valid_data_i %b&#34;, out_state_r.name, in_snoop_valid_data_i);
	wire out_channel_active_o;
	assign out_channel_active_o = out_state_r == sActive;
	wire out_loopback_en = (out_state_r == sPhase3) || (out_state_r == sPhase4);
	wire out_trigger_mode_alt_en = out_state_r == sPhase4;
	wire out_clk_i;
	wire core_clk_i;
	wire core_loopback_en_o;
	bsg_launch_sync_sync #(.width_p(1)) out_to_core_lss(
		.iclk_i(out_clk_i),
		.iclk_reset_i(1&#39;b0),
		.oclk_i(core_clk_i),
		.iclk_data_i(out_loopback_en),
		.iclk_data_o(),
		.oclk_data_o(core_loopback_en_o)
	);
	wire AWC_ignore;
	wire in_clk_i;
	bsg_launch_sync_sync #(.width_p(3)) out_to_in_lss(
		.iclk_i(out_clk_i),
		.iclk_reset_i(1&#39;b0),
		.oclk_i(in_clk_i),
		.iclk_data_i({out_loopback_en, out_trigger_mode_alt_en, out_infinite_credits_o}),
		.iclk_data_o(),
		.oclk_data_o({in_trigger_mode_en_o, in_trigger_mode_alt_en_o, AWC_ignore})
	);
	wire [counter_bits_lp - 1:0] out_ctr_r_p1 = out_ctr_r + 1&#39;b1;
	wire [(((width_p + 1) &gt;&gt; 1) &lt;&lt; 1) - 1:0] inactive_pattern = {(width_p + 1) &gt;&gt; 1 {2&#39;b10}};
	always @(*) begin
		out_infinite_credits_o = 1&#39;b0;
		out_ctr_n = out_ctr_r;
		out_rot_n = out_rot_r;
		out_override_en_n = 1&#39;b0;
		out_override_valid_data_n = {1&#39;b0, inactive_pattern[0+:width_p]};
		case (out_state_r)
			sBegin: begin
				out_ctr_n = out_ctr_r_p1;
				out_override_en_n = 1&#39;b1;
				if (out_ctr_r[counter_min_bits_lp - 1:lg_token_width_p] == 1&#39;b1)
					out_override_valid_data_n = {1&#39;b1, 1&#39;b1, {width_p - 1 {1&#39;b0}}};
			end
			sPhase1: begin
				out_rot_n = {out_rot_r[6:0], out_rot_r[7]};
				out_override_en_n = 1&#39;b1;
				out_override_valid_data_n = {width_p + 1 {out_rot_r[7]}};
			end
			sPhase2: begin
				out_ctr_n = out_ctr_r_p1;
				out_override_en_n = 1&#39;b1;
				out_override_valid_data_n = (out_ctr_r[0] ? out_ctr_r[1 + (width_p + 1)+:width_p + 1] : out_ctr_r[1+:width_p + 1]);
			end
			sPhase3: out_infinite_credits_o = 1&#39;b1;
			sPhase4: out_infinite_credits_o = 1&#39;b1;
			default:
				;
		endcase
	end
endmodule

</pre>
</body>
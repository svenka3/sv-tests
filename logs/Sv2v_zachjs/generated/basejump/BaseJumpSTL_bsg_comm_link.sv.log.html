<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_comm_link
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_comm_link/bsg_comm_link.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_comm_link/bsg_comm_link.v</a>
defines: 
time_elapsed: 0.839s
ram usage: 19116 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_comm_link <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_comm_link/bsg_comm_link.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_comm_link/bsg_comm_link.v</a>
module bsg_comm_link (
	core_clk_i,
	async_reset_i,
	io_master_clk_i,
	core_node_reset_r_o,
	core_node_en_r_o,
	core_node_v_o,
	core_node_data_o,
	core_node_ready_i,
	core_node_v_i,
	core_node_data_i,
	core_node_yumi_o,
	core_calib_reset_r_o,
	io_valid_tline_i,
	io_data_tline_i,
	io_clk_tline_i,
	io_token_clk_tline_o,
	im_valid_tline_o,
	im_data_tline_o,
	im_clk_tline_o,
	im_slave_reset_tline_r_o,
	token_clk_tline_i,
	core_async_reset_danger_o
);
	parameter _sv2v_width_channel_width_p = 24;
	parameter [_sv2v_width_channel_width_p - 1:0] channel_width_p = &#34;inv&#34;;
	parameter _sv2v_width_core_channels_p = 24;
	parameter [_sv2v_width_core_channels_p - 1:0] core_channels_p = &#34;inv&#34;;
	parameter _sv2v_width_link_channels_p = 24;
	parameter [_sv2v_width_link_channels_p - 1:0] link_channels_p = &#34;inv&#34;;
	parameter _sv2v_width_nodes_p = 24;
	parameter [_sv2v_width_nodes_p - 1:0] nodes_p = &#34;inv&#34;;
	parameter _sv2v_width_master_p = 24;
	parameter [_sv2v_width_master_p - 1:0] master_p = &#34;inv&#34;;
	parameter channel_mask_p = (1 &lt;&lt; link_channels_p) - 1;
	parameter master_to_slave_speedup_p = 100;
	function automatic [nodes_p - 1:0] sv2v_cast_86548;
		input reg [nodes_p - 1:0] inp;
		sv2v_cast_86548 = inp;
	endfunction
	parameter enabled_at_start_vec_p = sv2v_cast_86548(0);
	parameter sbox_pipeline_in_p = 1&#39;b1;
	parameter sbox_pipeline_out_p = 1&#39;b1;
	parameter snoop_vec_p = sv2v_cast_86548(0);
	parameter master_bypass_test_p = 5&#39;b00000;
	parameter lg_credit_to_token_decimation_p = 3;
	parameter master_lg_token_width_p = lg_credit_to_token_decimation_p + 2;
	parameter slave_lg_token_width_p = lg_credit_to_token_decimation_p + 2;
	parameter master_lg_wait_after_reset_p = $clog2(1 + (master_to_slave_speedup_p * 128));
	parameter master_calib_prepare_cycles_p = (master_to_slave_speedup_p * 2) * ((2 ** (master_lg_token_width_p + 1)) + (2 ** (slave_lg_token_width_p + 1)));
	parameter master_lg_out_prepare_hold_cycles_p = $clog2((5 * master_to_slave_speedup_p) + 10);
	parameter master_calib_timeout_cycles_p = master_to_slave_speedup_p * 25;
	input core_clk_i;
	input async_reset_i;
	input io_master_clk_i;
	output [nodes_p - 1:0] core_node_reset_r_o;
	output [nodes_p - 1:0] core_node_en_r_o;
	output [nodes_p - 1:0] core_node_v_o;
	output [(nodes_p * (core_channels_p * channel_width_p)) - 1:0] core_node_data_o;
	input [nodes_p - 1:0] core_node_ready_i;
	input [nodes_p - 1:0] core_node_v_i;
	input [(nodes_p * (core_channels_p * channel_width_p)) - 1:0] core_node_data_i;
	output [nodes_p - 1:0] core_node_yumi_o;
	output core_calib_reset_r_o;
	input [link_channels_p - 1:0] io_valid_tline_i;
	input [(link_channels_p * channel_width_p) - 1:0] io_data_tline_i;
	input [link_channels_p - 1:0] io_clk_tline_i;
	output [link_channels_p - 1:0] io_token_clk_tline_o;
	output [link_channels_p - 1:0] im_valid_tline_o;
	output [(link_channels_p * channel_width_p) - 1:0] im_data_tline_o;
	output [link_channels_p - 1:0] im_clk_tline_o;
	output reg im_slave_reset_tline_r_o;
	input [link_channels_p - 1:0] token_clk_tline_i;
	output core_async_reset_danger_o;
	localparam bao_narrow_lp = (((core_channels_p / 2) &gt;= link_channels_p) &amp; ((core_channels_p % 2) == 0) ? 2 : 1);
	localparam lg_input_fifo_depth_lp = 5;
	wire [link_channels_p - 1:0] io_reset;
	wire [link_channels_p - 1:0] io_calib_done;
	wire im_reset;
	wire [link_channels_p - 1:0] im_clk_init;
	wire im_slave_reset_tline_n;
	wire core_reset_i;
	assign core_async_reset_danger_o = core_reset_i;
	bsg_sync_sync #(.width_p(1)) core_reset_ss(
		.oclk_i(core_clk_i),
		.iclk_data_i(async_reset_i),
		.oclk_data_o(core_reset_i)
	);
	bsg_sync_sync #(.width_p(1)) im_reset_ss(
		.oclk_i(io_master_clk_i),
		.iclk_data_i(async_reset_i),
		.oclk_data_o(im_reset)
	);
	always @(posedge io_master_clk_i) im_slave_reset_tline_r_o &lt;= im_slave_reset_tline_n;
	wire [link_channels_p - 1:0] core_asm_to_sso_valid;
	wire [(link_channels_p * channel_width_p) - 1:0] core_asm_to_sso_data;
	wire [link_channels_p - 1:0] core_asm_to_sso_ready;
	wire [link_channels_p - 1:0] core_ssi_to_asm_valid;
	wire [(link_channels_p * channel_width_p) - 1:0] core_ssi_to_asm_data;
	wire [link_channels_p - 1:0] core_ssi_to_asm_yumi;
	wire [link_channels_p - 1:0] core_asm_to_sso_valid_sbox;
	wire [link_channels_p - 1:0] core_ssi_to_asm_valid_sbox;
	wire [(link_channels_p * channel_width_p) - 1:0] core_asm_to_sso_data_sbox;
	wire [(link_channels_p * channel_width_p) - 1:0] core_ssi_to_asm_data_sbox;
	wire [link_channels_p - 1:0] core_asm_to_sso_ready_sbox;
	wire [link_channels_p - 1:0] core_ssi_to_asm_yumi_sbox;
	wire [link_channels_p - 1:0] im_override_en;
	wire [channel_width_p:0] im_override_valid_data [link_channels_p - 1:0];
	wire [link_channels_p - 1:0] im_override_is_posedge;
	wire [link_channels_p - 1:0] im_infinite_credits_en;
	wire [channel_width_p:0] io_snoop_valid_data_pos [link_channels_p - 1:0];
	wire [channel_width_p:0] io_snoop_valid_data_neg [link_channels_p - 1:0];
	wire [link_channels_p - 1:0] io_trigger_mode_en;
	wire [link_channels_p - 1:0] io_trigger_mode_alt_en;
	wire [link_channels_p - 1:0] core_loopback_en;
	wire [link_channels_p - 1:0] core_channel_active;
	wire [link_channels_p - 1:0] im_channel_active;
	wire [(0 &gt; ($clog2(link_channels_p) - 1) ? 0 : $clog2(link_channels_p) - 1):0] core_top_active_channel_bao_r;
	wire [(0 &gt; ($clog2(link_channels_p) - 1) ? 0 : $clog2(link_channels_p) - 1):0] core_top_active_channel_bai_r;
	wire [(0 &gt; ($clog2(link_channels_p) - 1) ? 0 : $clog2(link_channels_p) - 1):0] core_top_active_channel_n;
	wire [(0 &gt; ($clog2(link_channels_p + 1) - 1) ? 0 : $clog2(link_channels_p + 1) - 1):0] active_channel_count;
	bsg_popcount #(.width_p(link_channels_p)) pop(
		.i(core_channel_active),
		.o(active_channel_count)
	);
	assign core_top_active_channel_n = (|core_channel_active ? active_channel_count - 1 : {((0 &gt; ($clog2(link_channels_p) - 1) ? 0 : $clog2(link_channels_p) - 1) &gt;= 0 ? (0 &gt; ($clog2(link_channels_p) - 1) ? 0 : $clog2(link_channels_p) - 1) + 1 : 1 - (0 &gt; ($clog2(link_channels_p) - 1) ? 0 : $clog2(link_channels_p) - 1)) {1&#39;sb0}});
	bsg_dff #(
		.harden_p(1),
		.strength_p(4),
		.width_p((1 &gt; $clog2(link_channels_p) ? 1 : $clog2(link_channels_p)))
	) core_top_active_channel_bai_r_reg(
		.clock_i(core_clk_i),
		.data_i(core_top_active_channel_n),
		.data_o(core_top_active_channel_bai_r)
	);
	bsg_dff #(
		.harden_p(1),
		.strength_p(4),
		.width_p((1 &gt; $clog2(link_channels_p) ? 1 : $clog2(link_channels_p)))
	) core_top_active_channel_bao_r_reg(
		.clock_i(core_clk_i),
		.data_i(core_top_active_channel_n),
		.data_o(core_top_active_channel_bao_r)
	);
	localparam tests_p = 5;
	wire im_calib_done;
	wire im_calib_done_r;
	wire core_calib_done_prefanout_r;
	bsg_launch_sync_sync #(.width_p(1)) out_to_core_sync_calib_done(
		.iclk_i(io_master_clk_i),
		.iclk_reset_i(1&#39;b0),
		.oclk_i(core_clk_i),
		.iclk_data_i(im_calib_done),
		.iclk_data_o(im_calib_done_r),
		.oclk_data_o(core_calib_done_prefanout_r)
	);
	wire [5:0] core_calib_done_vec_r;
	assign core_calib_reset_r_o = ~core_calib_done_vec_r[0];
	genvar k;
	generate
		for (k = 0; k &lt; 6; k = k + 1) begin : cr
			bsg_dff #(
				.harden_p(1),
				.strength_p(4),
				.width_p(1)
			) core_calib_reset_fanout_reg(
				.clock_i(core_clk_i),
				.data_i(core_calib_done_prefanout_r),
				.data_o(core_calib_done_vec_r[k])
			);
		end
	endgenerate
	generate
		if (master_p) begin : mstr
			wire [((tests_p + 1) * link_channels_p) - 1:0] im_test_scoreboard;
			wire [2:0] im_test_index;
			wire im_prepare;
			assign im_slave_reset_tline_n = im_prepare;
			wire im_start_calibration_n;
			reg im_start_calibration_r;
			bsg_wait_after_reset #(.lg_wait_cycles_p(master_lg_wait_after_reset_p)) bwar(
				.clk_i(io_master_clk_i),
				.reset_i(im_reset),
				.ready_r_o(im_start_calibration_n)
			);
			always @(posedge io_master_clk_i) im_start_calibration_r &lt;= im_start_calibration_n;
			bsg_source_sync_channel_control_master_master #(
				.link_channels_p(link_channels_p),
				.tests_p(tests_p),
				.prepare_cycles_p(master_calib_prepare_cycles_p),
				.timeout_cycles_p(master_calib_timeout_cycles_p)
			) master_master(
				.clk_i(io_master_clk_i),
				.reset_i(im_reset),
				.start_i(~im_start_calibration_r &amp; im_start_calibration_n),
				.test_scoreboard_i(im_test_scoreboard),
				.test_index_r_o(im_test_index),
				.prepare_o(im_prepare),
				.done_o(im_calib_done)
			);
			always @(negedge io_master_clk_i)
				if (im_calib_done &amp; ~im_calib_done_r)
					$display(&#34;###### Master calibration COMPLETED with active channels: (%b).&#34;, im_channel_active);
		end
		else begin
			assign im_calib_done = |im_channel_active;
			assign im_slave_reset_tline_n = 1&#39;b0;
		end
	endgenerate
	wire im_channel_reset;
	wire core_channel_reset;
	genvar i;
	genvar j;
	reg im_reset_r;
	generate
		if (master_p) begin : rreg
			always @(posedge io_master_clk_i) im_reset_r &lt;= im_reset;
		end
	endgenerate
	generate
		for (i = 0; i &lt; link_channels_p; i = i + 1) begin : ch
			bsg_launch_sync_sync #(.width_p(1)) blss_channel_active(
				.iclk_i(io_master_clk_i),
				.iclk_reset_i(im_reset),
				.oclk_i(core_clk_i),
				.iclk_data_i(im_channel_active[i]),
				.iclk_data_o(),
				.oclk_data_o(core_channel_active[i])
			);
			if (master_p) begin : m
				wire [tests_p:0] im_tests_gather;
				for (j = 0; j &lt; (tests_p + 1); j = j + 1) begin : mpa
					assign mstr.im_test_scoreboard[(j * link_channels_p) + i] = im_tests_gather[j];
				end
				bsg_source_sync_channel_control_master #(
					.width_p(channel_width_p),
					.lg_token_width_p(master_lg_token_width_p),
					.lg_out_prepare_hold_cycles_p(master_lg_out_prepare_hold_cycles_p),
					.bypass_test_p(master_bypass_test_p),
					.tests_lp(tests_p)
				) control_master(
					.out_clk_i(io_master_clk_i),
					.out_reset_i(im_reset),
					.out_calibration_state_i(mstr.im_test_index),
					.out_calib_prepare_i(mstr.im_prepare),
					.out_channel_blessed_i(im_channel_active[i]),
					.out_override_en_o(im_override_en[i]),
					.out_override_valid_data_o(im_override_valid_data[i]),
					.out_override_is_posedge_i(im_override_is_posedge[i]),
					.in_clk_i(io_clk_tline_i[i]),
					.in_reset_i(io_reset[i]),
					.in_snoop_valid_data_neg_i(io_snoop_valid_data_neg[i]),
					.in_snoop_valid_data_pos_i(io_snoop_valid_data_pos[i]),
					.out_infinite_credits_o(im_infinite_credits_en[i]),
					.out_test_pass_r_o(im_tests_gather)
				);
				assign im_channel_reset = mstr.im_prepare;
				bsg_launch_sync_sync #(.width_p(1)) io_reset_lss(
					.iclk_i(io_master_clk_i),
					.iclk_reset_i(1&#39;b0),
					.oclk_i(io_clk_tline_i[i]),
					.iclk_data_i(im_channel_reset),
					.iclk_data_o(),
					.oclk_data_o(io_reset[i])
				);
				bsg_launch_sync_sync #(.width_p(1)) bssi_reset(
					.iclk_i(io_master_clk_i),
					.iclk_reset_i(1&#39;b0),
					.oclk_i(core_clk_i),
					.iclk_data_i(im_channel_reset),
					.iclk_data_o(),
					.oclk_data_o(core_channel_reset)
				);
				assign io_trigger_mode_en[i] = 1&#39;b0;
				assign io_trigger_mode_alt_en[i] = 1&#39;b0;
				assign core_loopback_en[i] = 1&#39;b0;
				assign im_channel_active[i] = im_tests_gather[tests_p - 1:0] === {tests_p {1&#39;b1}};
				assign im_clk_init[i] = im_reset &amp; ~im_reset_r;
			end
			else begin : s
				bsg_sync_sync #(.width_p(1)) io_reset_ss(
					.oclk_i(io_clk_tline_i[i]),
					.iclk_data_i(async_reset_i),
					.oclk_data_o(io_reset[i])
				);
				assign core_channel_reset = core_reset_i;
				assign im_channel_reset = im_reset;
				bsg_source_sync_channel_control_slave #(
					.width_p(channel_width_p),
					.lg_token_width_p(slave_lg_token_width_p)
				) control_slave(
					.out_clk_i(io_master_clk_i),
					.out_reset_i(im_reset),
					.out_clk_init_r_o(im_clk_init[i]),
					.out_override_en_o(im_override_en[i]),
					.out_override_valid_data_o(im_override_valid_data[i]),
					.out_channel_active_o(im_channel_active[i]),
					.in_clk_i(io_clk_tline_i[i]),
					.in_snoop_valid_data_i(io_snoop_valid_data_pos[i]),
					.in_trigger_mode_en_o(io_trigger_mode_en[i]),
					.in_trigger_mode_alt_en_o(io_trigger_mode_alt_en[i]),
					.out_infinite_credits_o(im_infinite_credits_en[i]),
					.core_clk_i(core_clk_i),
					.core_loopback_en_o(core_loopback_en[i])
				);
			end
			wire token_reset = im_channel_reset;
			bsg_source_sync_output #(
				.lg_start_credits_p(lg_input_fifo_depth_lp),
				.lg_credit_to_token_decimation_p(lg_credit_to_token_decimation_p),
				.channel_width_p(channel_width_p)
			) sso(
				.core_clk_i(core_clk_i),
				.core_reset_i(core_channel_reset),
				.core_data_i((core_loopback_en[i] ? core_ssi_to_asm_data[i * channel_width_p+:channel_width_p] : core_asm_to_sso_data_sbox[i * channel_width_p+:channel_width_p])),
				.core_valid_i((core_loopback_en[i] ? core_ssi_to_asm_valid[i] : core_asm_to_sso_valid_sbox[i])),
				.core_ready_o(core_asm_to_sso_ready[i]),
				.io_master_clk_i(io_master_clk_i),
				.io_reset_i(im_channel_reset),
				.io_clk_init_i(im_clk_init[i]),
				.io_override_en_i(im_override_en[i]),
				.io_override_valid_data_i(im_override_valid_data[i]),
				.io_override_is_posedge_o(im_override_is_posedge[i]),
				.io_clk_r_o(im_clk_tline_o[i]),
				.io_data_r_o(im_data_tline_o[i * channel_width_p+:channel_width_p]),
				.io_valid_r_o(im_valid_tline_o[i]),
				.io_infinite_credits_i(im_infinite_credits_en[i]),
				.token_clk_i(token_clk_tline_i[i]),
				.token_reset_i(token_reset)
			);
			bsg_launch_sync_sync #(.width_p(1)) im_to_io_calib_done(
				.iclk_i(io_master_clk_i),
				.iclk_reset_i(1&#39;b0),
				.oclk_i(io_clk_tline_i[i]),
				.iclk_data_i(im_calib_done),
				.iclk_data_o(),
				.oclk_data_o(io_calib_done[i])
			);
			bsg_source_sync_input #(
				.lg_fifo_depth_p(lg_input_fifo_depth_lp),
				.lg_credit_to_token_decimation_p(lg_credit_to_token_decimation_p),
				.channel_width_p(channel_width_p)
			) ssi(
				.io_clk_i(io_clk_tline_i[i]),
				.io_data_i(io_data_tline_i[i * channel_width_p+:channel_width_p]),
				.io_valid_i(io_valid_tline_i[i]),
				.io_token_r_o(io_token_clk_tline_o[i]),
				.io_reset_i((master_p ? ~io_calib_done[i] : io_reset[i])),
				.io_token_bypass_i(io_reset[i]),
				.io_edge_i(2&#39;b11),
				.io_snoop_pos_r_o(io_snoop_valid_data_pos[i]),
				.io_snoop_neg_r_o(io_snoop_valid_data_neg[i]),
				.io_trigger_mode_en_i(io_trigger_mode_en[i]),
				.io_trigger_mode_alt_en_i(io_trigger_mode_alt_en[i]),
				.core_clk_i(core_clk_i),
				.core_reset_i(core_channel_reset),
				.core_data_o(core_ssi_to_asm_data[i * channel_width_p+:channel_width_p]),
				.core_valid_o(core_ssi_to_asm_valid[i]),
				.core_yumi_i((core_loopback_en[i] ? core_asm_to_sso_ready[i] &amp; core_ssi_to_asm_valid[i] : core_ssi_to_asm_yumi_sbox[i]))
			);
		end
	endgenerate
	bsg_sbox #(
		.num_channels_p(link_channels_p),
		.channel_width_p(channel_width_p),
		.pipeline_indir_p(sbox_pipeline_in_p),
		.pipeline_outdir_p(sbox_pipeline_out_p)
	) sbox(
		.clk_i(core_clk_i),
		.reset_i(core_reset_i),
		.calibration_done_i(core_calib_done_vec_r[1]),
		.channel_active_i(core_channel_active),
		.in_v_i(core_ssi_to_asm_valid),
		.in_data_i(core_ssi_to_asm_data),
		.in_yumi_o(core_ssi_to_asm_yumi_sbox),
		.in_v_o(core_ssi_to_asm_valid_sbox),
		.in_data_o(core_ssi_to_asm_data_sbox),
		.in_yumi_i(core_ssi_to_asm_yumi),
		.out_me_v_i(core_asm_to_sso_valid),
		.out_me_data_i(core_asm_to_sso_data),
		.out_me_ready_o(core_asm_to_sso_ready_sbox),
		.out_me_v_o(core_asm_to_sso_valid_sbox),
		.out_me_data_o(core_asm_to_sso_data_sbox),
		.out_me_ready_i(core_asm_to_sso_ready)
	);
	wire core_nrw_valid_li;
	wire [(core_channels_p * channel_width_p) - 1:0] core_nrw_data_li;
	wire core_nrw_ready_lo;
	wire core_asm_valid_li;
	wire [((core_channels_p * channel_width_p) / bao_narrow_lp) - 1:0] core_asm_data_li;
	wire core_asm_ready_lo;
	wire core_asm_valid_lo;
	wire [(core_channels_p * channel_width_p) - 1:0] core_asm_data_lo;
	wire core_asm_yumi_li;
	function automatic [($clog2(core_channels_p / bao_narrow_lp) &gt; 1 ? $clog2(core_channels_p / bao_narrow_lp) : 1) - 1:0] sv2v_cast_42473;
		input reg [($clog2(core_channels_p / bao_narrow_lp) &gt; 1 ? $clog2(core_channels_p / bao_narrow_lp) : 1) - 1:0] inp;
		sv2v_cast_42473 = inp;
	endfunction
	bsg_assembler_out #(
		.width_p(channel_width_p),
		.num_in_p(core_channels_p / bao_narrow_lp),
		.num_out_p(link_channels_p),
		.out_channel_count_mask_p(channel_mask_p)
	) bao(
		.clk(core_clk_i),
		.reset(core_channel_reset),
		.calibration_done_i(core_calib_done_vec_r[2]),
		.valid_i(core_asm_valid_li),
		.data_i(core_asm_data_li),
		.ready_o(core_asm_ready_lo),
		.in_top_channel_i(sv2v_cast_42473(core_channels_p / bao_narrow_lp) - 1&#39;b1),
		.out_top_channel_i(core_top_active_channel_bao_r),
		.valid_o(core_asm_to_sso_valid),
		.data_o(core_asm_to_sso_data),
		.ready_i(core_asm_to_sso_ready_sbox)
	);
	wire core_valid_tmp;
	assign core_asm_valid_lo = core_valid_tmp &amp; core_calib_done_vec_r[2];
	function automatic [($clog2(core_channels_p) &gt; 1 ? $clog2(core_channels_p) : 1) - 1:0] sv2v_cast_C1E21;
		input reg [($clog2(core_channels_p) &gt; 1 ? $clog2(core_channels_p) : 1) - 1:0] inp;
		sv2v_cast_C1E21 = inp;
	endfunction
	bsg_assembler_in #(
		.width_p(channel_width_p),
		.num_in_p(link_channels_p),
		.num_out_p(core_channels_p),
		.in_channel_count_mask_p(channel_mask_p)
	) bai(
		.clk(core_clk_i),
		.reset(core_channel_reset),
		.calibration_done_i(core_calib_done_vec_r[3]),
		.valid_i(core_ssi_to_asm_valid_sbox),
		.data_i(core_ssi_to_asm_data_sbox),
		.yumi_o(core_ssi_to_asm_yumi),
		.in_top_channel_i(core_top_active_channel_bai_r),
		.out_top_channel_i(sv2v_cast_C1E21(core_channels_p) - 1&#39;b1),
		.valid_o(core_valid_tmp),
		.data_o(core_asm_data_lo),
		.yumi_i(core_asm_yumi_li)
	);
	generate
		if (bao_narrow_lp == 2) begin : nrw
			bsg_fifo_1r1w_narrowed #(
				.width_p(channel_width_p * core_channels_p),
				.els_p(2),
				.width_out_p((channel_width_p * core_channels_p) / bao_narrow_lp)
			) nrw(
				.clk_i(core_clk_i),
				.reset_i(~core_calib_done_vec_r[4]),
				.v_i(core_nrw_valid_li),
				.data_i(core_nrw_data_li),
				.ready_o(core_nrw_ready_lo),
				.v_o(core_asm_valid_li),
				.data_o(core_asm_data_li),
				.yumi_i(core_asm_ready_lo &amp; core_asm_valid_li)
			);
		end
		else begin : not_nrw
			assign core_asm_valid_li = core_nrw_valid_li;
			assign core_asm_data_li = core_nrw_data_li;
			assign core_nrw_ready_lo = core_asm_ready_lo;
		end
	endgenerate
	bsg_fsb #(
		.width_p(channel_width_p * core_channels_p),
		.nodes_p(nodes_p),
		.enabled_at_start_vec_p(enabled_at_start_vec_p),
		.snoop_vec_p(snoop_vec_p)
	) fsb(
		.clk_i(core_clk_i),
		.reset_i(~core_calib_done_vec_r[5]),
		.asm_v_i(core_asm_valid_lo),
		.asm_data_i(core_asm_data_lo),
		.asm_yumi_o(core_asm_yumi_li),
		.asm_v_o(core_nrw_valid_li),
		.asm_data_o(core_nrw_data_li),
		.asm_ready_i(core_nrw_ready_lo),
		.node_v_o(core_node_v_o),
		.node_data_o(core_node_data_o),
		.node_ready_i(core_node_ready_i),
		.node_en_r_o(core_node_en_r_o),
		.node_reset_r_o(core_node_reset_r_o),
		.node_v_i(core_node_v_i),
		.node_data_i(core_node_data_i),
		.node_yumi_o(core_node_yumi_o)
	);
endmodule

</pre>
</body>
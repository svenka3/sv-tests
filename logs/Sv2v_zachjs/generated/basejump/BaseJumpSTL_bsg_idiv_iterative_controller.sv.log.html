<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_idiv_iterative_controller.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_idiv_iterative_controller.v</a>
defines: 
time_elapsed: 0.304s
ram usage: 14860 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_idiv_iterative_controller.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_idiv_iterative_controller.v</a>
module bsg_idiv_iterative_controller (
	clk_i,
	reset_i,
	v_i,
	ready_o,
	zero_divisor_i,
	signed_div_r_i,
	adder_result_is_neg_i,
	opA_is_neg_i,
	opC_is_neg_i,
	opA_sel_o,
	opA_ld_o,
	opA_inv_o,
	opA_clr_l_o,
	opB_sel_o,
	opB_ld_o,
	opB_inv_o,
	opB_clr_l_o,
	opC_sel_o,
	opC_ld_o,
	latch_inputs_o,
	adder_cin_o,
	v_o,
	yumi_i
);
	parameter width_p = 32;
	input clk_i;
	input reset_i;
	input v_i;
	output ready_o;
	input zero_divisor_i;
	input signed_div_r_i;
	input adder_result_is_neg_i;
	input opA_is_neg_i;
	input opC_is_neg_i;
	output reg opA_sel_o;
	output reg opA_ld_o;
	output reg opA_inv_o;
	output reg opA_clr_l_o;
	output reg [2:0] opB_sel_o;
	output reg opB_ld_o;
	output reg opB_inv_o;
	output reg opB_clr_l_o;
	output reg [2:0] opC_sel_o;
	output reg opC_ld_o;
	output reg latch_inputs_o;
	output reg adder_cin_o;
	output wire v_o;
	input yumi_i;
	reg q_neg;
	reg r_neg;
	reg neg_ld;
	reg add_neg_last;
	reg [5:0] state;
	reg [5:0] next_state;
	always @(posedge clk_i) begin
		add_neg_last &lt;= adder_result_is_neg_i;
		if (neg_ld) begin
			q_neg &lt;= (opA_is_neg_i ^ opC_is_neg_i) &amp; signed_div_r_i;
			r_neg &lt;= opC_is_neg_i &amp; signed_div_r_i;
		end
	end
	wire [((width_p + 1) == 1 ? 1 : $clog2(width_p + 1)) - 1:0] calc_cnt;
	localparam [5:0] CALC = 5;
	wire calc_up_li = (state == CALC) &amp;&amp; (calc_cnt &lt; width_p);
	wire calc_done = calc_cnt == width_p;
	bsg_counter_clear_up #(
		.max_val_p(width_p),
		.init_val_p(0),
		.disable_overflow_warning_p(1)
	) calc_counter(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.clear_i(calc_done),
		.up_i(calc_up_li),
		.count_o(calc_cnt)
	);
	localparam [5:0] WAIT = 0;
	always @(posedge clk_i)
		if (reset_i)
			state &lt;= WAIT;
		else
			state &lt;= next_state;
	localparam [5:0] DONE = 9;
	localparam [5:0] NEG0 = 2;
	localparam [5:0] NEG1 = 3;
	localparam [5:0] QUOT = 8;
	localparam [5:0] REMAIN = 7;
	localparam [5:0] REPAIR = 6;
	localparam [5:0] SHIFT = 4;
	localparam [5:0] START = 1;
	always @(*) begin
		opA_sel_o = 1&#39;b0;
		opA_ld_o = 1&#39;b0;
		opA_inv_o = !add_neg_last;
		opA_clr_l_o = 1&#39;b1;
		opB_sel_o = 3&#39;b001;
		opB_ld_o = 1&#39;b1;
		opB_inv_o = 1&#39;b0;
		opB_clr_l_o = 1&#39;b1;
		opC_sel_o = 3&#39;b001;
		opC_ld_o = 1&#39;b1;
		adder_cin_o = !add_neg_last;
		neg_ld = 1&#39;b0;
		latch_inputs_o = 1&#39;b0;
		next_state = WAIT;
		case (state)
			WAIT: begin
				if (v_i)
					next_state = START;
				latch_inputs_o = 1&#39;b1;
			end
			START: begin
				next_state = NEG0;
				opA_ld_o = 1&#39;b1;
				opC_ld_o = 1&#39;b1;
				opA_sel_o = 1&#39;b1;
				opC_sel_o = 3&#39;b100;
				opB_ld_o = 1&#39;b0;
			end
			NEG0: begin
				next_state = NEG1;
				opA_inv_o = 1&#39;b1;
				opB_clr_l_o = 1&#39;b0;
				opB_sel_o = 3&#39;b100;
				opC_ld_o = 1&#39;b0;
				neg_ld = 1&#39;b1;
				adder_cin_o = 1&#39;b1;
				opA_ld_o = opA_is_neg_i &amp; signed_div_r_i;
			end
			NEG1: begin
				next_state = SHIFT;
				opA_clr_l_o = 1&#39;b0;
				opB_inv_o = 1&#39;b1;
				opB_ld_o = 1&#39;b0;
				opC_sel_o = 3&#39;b010;
				adder_cin_o = 1&#39;b1;
				opC_ld_o = opC_is_neg_i &amp; signed_div_r_i;
			end
			SHIFT: begin
				next_state = CALC;
				opA_clr_l_o = 1&#39;b0;
				opB_clr_l_o = 1&#39;b0;
				adder_cin_o = 1&#39;b0;
			end
			CALC: begin
				opB_sel_o = (calc_done ? 3&#39;b010 : 3&#39;b001);
				next_state = (calc_done ? REPAIR : CALC);
			end
			REPAIR: begin
				next_state = REMAIN;
				opA_inv_o = 1&#39;b0;
				opB_sel_o = 3&#39;b010;
				opC_ld_o = 1&#39;b0;
				adder_cin_o = 1&#39;b0;
				opB_ld_o = add_neg_last;
			end
			REMAIN: begin
				next_state = (zero_divisor_i ? DONE : QUOT);
				opA_ld_o = 1&#39;b1;
				opA_clr_l_o = 1&#39;b0;
				opB_sel_o = 3&#39;b100;
				opC_ld_o = 1&#39;b0;
				opB_inv_o = r_neg;
				adder_cin_o = r_neg;
			end
			QUOT: begin
				if (yumi_i)
					next_state = WAIT;
				else
					next_state = DONE;
				opA_clr_l_o = 1&#39;b0;
				opB_inv_o = 1&#39;b1;
				opB_ld_o = 1&#39;b0;
				opC_sel_o = 3&#39;b010;
				adder_cin_o = 1&#39;b1;
				opC_ld_o = q_neg;
			end
			DONE: begin
				if (yumi_i)
					next_state = WAIT;
				else
					next_state = DONE;
				opA_ld_o = 1&#39;b0;
				opB_ld_o = 1&#39;b0;
				opC_ld_o = 1&#39;b0;
			end
		endcase
	end
	assign ready_o = state == WAIT;
	assign v_o = state == DONE;
endmodule

</pre>
</body>
<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v</a>
defines: 
time_elapsed: 0.346s
ram usage: 15656 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v</a>
module bsg_imul_iterative (
	clk_i,
	reset_i,
	v_i,
	ready_o,
	opA_i,
	signed_opA_i,
	opB_i,
	signed_opB_i,
	gets_high_part_i,
	v_o,
	result_o,
	yumi_i
);
	parameter width_p = 32;
	input clk_i;
	input reset_i;
	input v_i;
	output ready_o;
	input [width_p - 1:0] opA_i;
	input signed_opA_i;
	input [width_p - 1:0] opB_i;
	input signed_opB_i;
	input gets_high_part_i;
	output v_o;
	output [width_p - 1:0] result_o;
	input yumi_i;
	localparam lg_width_lp = ((width_p + 1) == 1 ? 1 : $clog2(width_p + 1));
	reg [lg_width_lp - 1:0] shift_counter_r;
	reg gets_high_part_r;
	wire shift_counter_full = (gets_high_part_r ? shift_counter_r == (width_p - 1) : shift_counter_r == width_p);
	reg [2:0] curr_state_r;
	reg [2:0] next_state;
	localparam [2:0] IDLE = 0;
	always @(posedge clk_i)
		if (reset_i)
			curr_state_r &lt;= IDLE;
		else
			curr_state_r &lt;= next_state;
	localparam [2:0] CALC = 3;
	localparam [2:0] DONE = 5;
	localparam [2:0] NEG_A = 1;
	localparam [2:0] NEG_B = 2;
	localparam [2:0] NEG_R = 4;
	always @(*)
		case (curr_state_r)
			IDLE:
				if (v_i)
					next_state = NEG_A;
				else
					next_state = IDLE;
			NEG_A: next_state = NEG_B;
			NEG_B: next_state = CALC;
			CALC:
				if (!shift_counter_full)
					next_state = CALC;
				else
					next_state = NEG_R;
			NEG_R: next_state = DONE;
			DONE:
				if (yumi_i)
					next_state = IDLE;
				else
					next_state = DONE;
			default: next_state = IDLE;
		endcase
	always @(posedge clk_i)
		if (reset_i)
			shift_counter_r &lt;= &#39;b0;
		else if ((curr_state_r != CALC) &amp;&amp; (next_state == CALC))
			shift_counter_r &lt;= &#39;b0;
		else if (curr_state_r == CALC)
			shift_counter_r &lt;= shift_counter_r + 1;
	reg [width_p - 1:0] opA_r;
	reg [width_p - 1:0] opB_r;
	reg [width_p - 1:0] result_r;
	wire [width_p - 1:0] adder_a;
	wire [width_p - 1:0] adder_b;
	wire [width_p:0] adder_result;
	wire [width_p:0] shifted_adder_result;
	assign adder_a = (curr_state_r == NEG_A ? ~opA_r : (curr_state_r == NEG_B ? ~opB_r : (curr_state_r == NEG_R ? ~result_r : result_r)));
	wire adder_neg_op = ((curr_state_r == NEG_A) || (curr_state_r == NEG_B)) || (curr_state_r == NEG_R);
	assign adder_b = (adder_neg_op ? {{width_p - 1 {1&#39;b0}}, 1&#39;b1} : opA_r);
	assign adder_result = {1&#39;b0, adder_a} + {1&#39;b0, adder_b};
	assign shifted_adder_result = adder_result &gt;&gt; 1;
	wire latch_input = v_i &amp; ready_o;
	reg signed_opA_r;
	reg signed_opB_r;
	reg need_neg_result_r;
	wire signed_opA = signed_opA_i &amp; opA_i[width_p - 1];
	wire signed_opB = signed_opB_i &amp; opB_i[width_p - 1];
	always @(posedge clk_i)
		if (reset_i)
			signed_opA_r &lt;= 1&#39;b0;
		else if (latch_input)
			signed_opA_r &lt;= signed_opA;
	always @(posedge clk_i)
		if (reset_i)
			signed_opB_r &lt;= 1&#39;b0;
		else if (latch_input)
			signed_opB_r &lt;= signed_opB;
	always @(posedge clk_i)
		if (reset_i)
			need_neg_result_r &lt;= 1&#39;b0;
		else if (latch_input)
			need_neg_result_r &lt;= signed_opA ^ signed_opB;
	always @(posedge clk_i)
		if (reset_i)
			gets_high_part_r &lt;= 1&#39;b0;
		else if (latch_input)
			gets_high_part_r &lt;= gets_high_part_i;
	always @(posedge clk_i)
		if (reset_i)
			opA_r &lt;= &#39;b0;
		else if (latch_input)
			opA_r &lt;= opA_i;
		else if ((curr_state_r == CALC) &amp;&amp; !gets_high_part_r)
			opA_r &lt;= opA_r &lt;&lt; 1;
		else if ((curr_state_r == NEG_A) &amp;&amp; signed_opA_r)
			opA_r &lt;= adder_result[width_p - 1:0];
	always @(posedge clk_i)
		if (reset_i)
			opB_r &lt;= &#39;b0;
		else if (latch_input)
			opB_r &lt;= opB_i;
		else if (curr_state_r == CALC)
			opB_r &lt;= opB_r &gt;&gt; 1;
		else if ((curr_state_r == NEG_B) &amp;&amp; signed_opB_r)
			opB_r &lt;= adder_result[width_p - 1:0];
	wire shifted_lsb = (opB_r[0] ? adder_result[0] : result_r[0]);
	reg all_sh_lsb_zero_r;
	always @(posedge clk_i)
		if (reset_i)
			all_sh_lsb_zero_r &lt;= 1&#39;b0;
		else if (latch_input)
			all_sh_lsb_zero_r &lt;= 1&#39;b1;
		else if (curr_state_r == CALC)
			all_sh_lsb_zero_r &lt;= all_sh_lsb_zero_r &amp; ~shifted_lsb;
	always @(posedge clk_i)
		if (reset_i)
			result_r &lt;= &#39;b0;
		else if (latch_input)
			result_r &lt;= &#39;b0;
		else if ((curr_state_r == NEG_R) &amp;&amp; need_neg_result_r) begin
			if (gets_high_part_r &amp;&amp; !all_sh_lsb_zero_r)
				result_r &lt;= ~result_r;
			else
				result_r &lt;= adder_result[width_p - 1:0];
		end
		else if ((curr_state_r == CALC) &amp;&amp; opB_r[0]) begin
			if (gets_high_part_r)
				result_r &lt;= shifted_adder_result[width_p - 1:0];
			else
				result_r &lt;= adder_result[width_p - 1:0];
		end
		else if ((curr_state_r == CALC) &amp;&amp; !opB_r[0])
			if (gets_high_part_r)
				result_r &lt;= result_r &gt;&gt; 1;
	assign ready_o = curr_state_r == IDLE;
	assign result_o = result_r;
	assign v_o = curr_state_r == DONE;
endmodule

</pre>
</body>
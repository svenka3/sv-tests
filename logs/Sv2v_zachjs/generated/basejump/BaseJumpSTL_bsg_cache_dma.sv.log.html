<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_dma.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_dma.v</a>
defines: 
time_elapsed: 0.922s
ram usage: 16160 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_dma.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_dma.v</a>
module bsg_cache_dma (
	clk_i,
	reset_i,
	dma_cmd_i,
	dma_way_i,
	dma_addr_i,
	done_o,
	snoop_word_o,
	dma_pkt_o,
	dma_pkt_v_o,
	dma_pkt_yumi_i,
	dma_data_i,
	dma_data_v_i,
	dma_data_ready_o,
	dma_data_o,
	dma_data_v_o,
	dma_data_yumi_i,
	data_mem_v_o,
	data_mem_w_o,
	data_mem_addr_o,
	data_mem_w_mask_o,
	data_mem_data_o,
	data_mem_data_i,
	dma_evict_o
);
	localparam [3:0] e_cache_amo_swap = 4&#39;b0000;
	localparam [3:0] e_cache_amo_add = 4&#39;b0001;
	localparam [3:0] e_cache_amo_xor = 4&#39;b0010;
	localparam [3:0] e_cache_amo_and = 4&#39;b0011;
	localparam [3:0] e_cache_amo_or = 4&#39;b0100;
	localparam [3:0] e_cache_amo_min = 4&#39;b0101;
	localparam [3:0] e_cache_amo_max = 4&#39;b0110;
	localparam [3:0] e_cache_amo_minu = 4&#39;b0111;
	localparam [3:0] e_cache_amo_maxu = 4&#39;b1000;
	localparam amo_support_level_none_lp = 1&#39;sb0;
	localparam amo_support_level_swap_lp = amo_support_level_none_lp | (1 &lt;&lt; e_cache_amo_swap);
	localparam amo_support_level_logical_lp = ((amo_support_level_swap_lp | (1 &lt;&lt; e_cache_amo_xor)) | (1 &lt;&lt; e_cache_amo_and)) | (1 &lt;&lt; e_cache_amo_or);
	localparam amo_support_level_arithmetic_lp = ((((amo_support_level_logical_lp | (1 &lt;&lt; e_cache_amo_add)) | (1 &lt;&lt; e_cache_amo_min)) | (1 &lt;&lt; e_cache_amo_max)) | (1 &lt;&lt; e_cache_amo_minu)) | (1 &lt;&lt; e_cache_amo_maxu);
	localparam [5:0] LB = 6&#39;b000000;
	localparam [5:0] LH = 6&#39;b000001;
	localparam [5:0] LW = 6&#39;b000010;
	localparam [5:0] LD = 6&#39;b000011;
	localparam [5:0] LBU = 6&#39;b000100;
	localparam [5:0] LHU = 6&#39;b000101;
	localparam [5:0] LWU = 6&#39;b000110;
	localparam [5:0] LDU = 6&#39;b000111;
	localparam [5:0] SB = 6&#39;b001000;
	localparam [5:0] SH = 6&#39;b001001;
	localparam [5:0] SW = 6&#39;b001010;
	localparam [5:0] SD = 6&#39;b001011;
	localparam [5:0] LM = 6&#39;b001100;
	localparam [5:0] SM = 6&#39;b001101;
	localparam [5:0] TAGST = 6&#39;b010000;
	localparam [5:0] TAGFL = 6&#39;b010001;
	localparam [5:0] TAGLV = 6&#39;b010010;
	localparam [5:0] TAGLA = 6&#39;b010011;
	localparam [5:0] AFL = 6&#39;b011000;
	localparam [5:0] AFLINV = 6&#39;b011001;
	localparam [5:0] AINV = 6&#39;b011010;
	localparam [5:0] ALOCK = 6&#39;b011011;
	localparam [5:0] AUNLOCK = 6&#39;b011100;
	localparam [5:0] AMOSWAP_W = 6&#39;b100000;
	localparam [5:0] AMOADD_W = 6&#39;b100001;
	localparam [5:0] AMOXOR_W = 6&#39;b100010;
	localparam [5:0] AMOAND_W = 6&#39;b100011;
	localparam [5:0] AMOOR_W = 6&#39;b100100;
	localparam [5:0] AMOMIN_W = 6&#39;b100101;
	localparam [5:0] AMOMAX_W = 6&#39;b100110;
	localparam [5:0] AMOMINU_W = 6&#39;b100111;
	localparam [5:0] AMOMAXU_W = 6&#39;b101000;
	localparam [5:0] AMOSWAP_D = 6&#39;b110000;
	localparam [5:0] AMOADD_D = 6&#39;b110001;
	localparam [5:0] AMOXOR_D = 6&#39;b110010;
	localparam [5:0] AMOAND_D = 6&#39;b110011;
	localparam [5:0] AMOOR_D = 6&#39;b110100;
	localparam [5:0] AMOMIN_D = 6&#39;b110101;
	localparam [5:0] AMOMAX_D = 6&#39;b110110;
	localparam [5:0] AMOMINU_D = 6&#39;b110111;
	localparam [5:0] AMOMAXU_D = 6&#39;b111000;
	localparam [3:0] e_dma_nop = 4&#39;b0000;
	localparam [3:0] e_dma_send_fill_addr = 4&#39;b0001;
	localparam [3:0] e_dma_send_evict_addr = 4&#39;b0010;
	localparam [3:0] e_dma_get_fill_data = 4&#39;b0100;
	localparam [3:0] e_dma_send_evict_data = 4&#39;b1000;
	parameter _sv2v_width_addr_width_p = 24;
	parameter [_sv2v_width_addr_width_p - 1:0] addr_width_p = &#34;inv&#34;;
	parameter _sv2v_width_data_width_p = 24;
	parameter [_sv2v_width_data_width_p - 1:0] data_width_p = &#34;inv&#34;;
	parameter _sv2v_width_block_size_in_words_p = 24;
	parameter [_sv2v_width_block_size_in_words_p - 1:0] block_size_in_words_p = &#34;inv&#34;;
	parameter _sv2v_width_sets_p = 24;
	parameter [_sv2v_width_sets_p - 1:0] sets_p = &#34;inv&#34;;
	parameter _sv2v_width_ways_p = 24;
	parameter [_sv2v_width_ways_p - 1:0] ways_p = &#34;inv&#34;;
	parameter dma_data_width_p = data_width_p;
	parameter lg_block_size_in_words_lp = (block_size_in_words_p == 1 ? 1 : $clog2(block_size_in_words_p));
	parameter lg_sets_lp = (sets_p == 1 ? 1 : $clog2(sets_p));
	parameter lg_ways_lp = (ways_p == 1 ? 1 : $clog2(ways_p));
	parameter data_mask_width_lp = data_width_p &gt;&gt; 3;
	parameter dma_data_mask_width_lp = dma_data_width_p &gt;&gt; 3;
	parameter burst_len_lp = (block_size_in_words_p * data_width_p) / dma_data_width_p;
	parameter lg_burst_len_lp = (burst_len_lp == 1 ? 1 : $clog2(burst_len_lp));
	parameter burst_size_in_words_lp = dma_data_width_p / data_width_p;
	parameter lg_burst_size_in_words_lp = (burst_size_in_words_lp == 1 ? 1 : $clog2(burst_size_in_words_lp));
	parameter data_mem_els_lp = sets_p * burst_len_lp;
	parameter lg_data_mem_els_lp = (data_mem_els_lp == 1 ? 1 : $clog2(data_mem_els_lp));
	parameter bsg_cache_dma_pkt_width_lp = 1 + addr_width_p;
	parameter debug_p = 0;
	input clk_i;
	input reset_i;
	input wire [3:0] dma_cmd_i;
	input [lg_ways_lp - 1:0] dma_way_i;
	input [addr_width_p - 1:0] dma_addr_i;
	output reg done_o;
	output reg [data_width_p - 1:0] snoop_word_o;
	output wire [bsg_cache_dma_pkt_width_lp - 1:0] dma_pkt_o;
	output reg dma_pkt_v_o;
	input dma_pkt_yumi_i;
	input [dma_data_width_p - 1:0] dma_data_i;
	input dma_data_v_i;
	output wire dma_data_ready_o;
	output wire [dma_data_width_p - 1:0] dma_data_o;
	output wire dma_data_v_o;
	input dma_data_yumi_i;
	output reg data_mem_v_o;
	output reg data_mem_w_o;
	output wire [lg_data_mem_els_lp - 1:0] data_mem_addr_o;
	output wire [(ways_p * dma_data_mask_width_lp) - 1:0] data_mem_w_mask_o;
	output wire [(ways_p * dma_data_width_p) - 1:0] data_mem_data_o;
	input [(ways_p * dma_data_width_p) - 1:0] data_mem_data_i;
	output reg dma_evict_o;
	localparam counter_width_lp = ((burst_len_lp + 1) == 1 ? 1 : $clog2(burst_len_lp + 1));
	localparam byte_offset_width_lp = ((data_width_p &gt;&gt; 3) == 1 ? 1 : $clog2(data_width_p &gt;&gt; 3));
	reg [1:0] dma_state_n;
	reg [1:0] dma_state_r;
	reg counter_clear;
	reg counter_up;
	wire [counter_width_lp - 1:0] counter_r;
	bsg_counter_clear_up #(.max_val_p(burst_len_lp)) dma_counter(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.clear_i(counter_clear),
		.up_i(counter_up),
		.count_o(counter_r)
	);
	wire counter_fill_max = counter_r == (burst_len_lp - 1);
	wire counter_evict_max = counter_r == burst_len_lp;
	reg [(1 + addr_width_p) - 1:0] dma_pkt;
	wire in_fifo_v_lo;
	wire [dma_data_width_p - 1:0] in_fifo_data_lo;
	reg in_fifo_yumi_li;
	bsg_fifo_1r1w_small #(
		.width_p(dma_data_width_p),
		.els_p((burst_len_lp &lt; 2 ? 2 : burst_len_lp))
	) in_fifo(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.data_i(dma_data_i),
		.v_i(dma_data_v_i),
		.ready_o(dma_data_ready_o),
		.v_o(in_fifo_v_lo),
		.data_o(in_fifo_data_lo),
		.yumi_i(in_fifo_yumi_li)
	);
	reg out_fifo_v_li;
	wire out_fifo_ready_lo;
	wire [dma_data_width_p - 1:0] out_fifo_data_li;
	bsg_two_fifo #(.width_p(dma_data_width_p)) out_fifo(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(out_fifo_v_li),
		.data_i(out_fifo_data_li),
		.ready_o(out_fifo_ready_lo),
		.v_o(dma_data_v_o),
		.data_o(dma_data_o),
		.yumi_i(dma_data_yumi_i)
	);
	assign dma_pkt_o = dma_pkt;
	wire [ways_p - 1:0] dma_way_mask;
	bsg_decode #(.num_out_p(ways_p)) dma_way_demux(
		.i(dma_way_i),
		.o(dma_way_mask)
	);
	bsg_expand_bitmask #(
		.in_width_p(ways_p),
		.expand_p(dma_data_mask_width_lp)
	) expand0(
		.i(dma_way_mask),
		.o(data_mem_w_mask_o)
	);
	generate
		if (burst_len_lp == 1) assign data_mem_addr_o = dma_addr_i[byte_offset_width_lp + lg_block_size_in_words_lp+:lg_sets_lp];
		else assign data_mem_addr_o = {dma_addr_i[byte_offset_width_lp + lg_block_size_in_words_lp+:lg_sets_lp], counter_r[0+:lg_burst_len_lp]};
	endgenerate
	assign data_mem_data_o = {ways_p {in_fifo_data_lo}};
	bsg_mux #(
		.width_p(dma_data_width_p),
		.els_p(ways_p)
	) write_data_mux(
		.data_i(data_mem_data_i),
		.sel_i(dma_way_i),
		.data_o(out_fifo_data_li)
	);
	localparam [1:0] GET_FILL_DATA = 1;
	localparam [1:0] IDLE = 0;
	localparam [1:0] SEND_EVICT_DATA = 2;
	always @(*) begin
		done_o = 1&#39;b0;
		dma_pkt_v_o = 1&#39;b0;
		dma_pkt[addr_width_p] = 1&#39;b0;
		dma_pkt[addr_width_p - 1-:addr_width_p] = {dma_addr_i[addr_width_p - 1:byte_offset_width_lp + lg_block_size_in_words_lp], {byte_offset_width_lp + lg_block_size_in_words_lp {1&#39;b0}}};
		data_mem_v_o = 1&#39;b0;
		data_mem_w_o = 1&#39;b0;
		in_fifo_yumi_li = 1&#39;b0;
		dma_state_n = IDLE;
		out_fifo_v_li = 1&#39;b0;
		counter_clear = 1&#39;b0;
		counter_up = 1&#39;b0;
		dma_evict_o = 1&#39;b0;
		case (dma_state_r)
			IDLE: begin
				counter_clear = 1&#39;b0;
				counter_up = 1&#39;b0;
				data_mem_v_o = 1&#39;b0;
				dma_pkt_v_o = 1&#39;b0;
				dma_pkt[addr_width_p] = 1&#39;b0;
				done_o = 1&#39;b0;
				dma_state_n = IDLE;
				case (dma_cmd_i)
					e_dma_send_fill_addr: begin
						dma_pkt_v_o = 1&#39;b1;
						dma_pkt[addr_width_p] = 1&#39;b0;
						done_o = dma_pkt_yumi_i;
						dma_state_n = IDLE;
					end
					e_dma_send_evict_addr: begin
						dma_pkt_v_o = 1&#39;b1;
						dma_pkt[addr_width_p] = 1&#39;b1;
						done_o = dma_pkt_yumi_i;
						dma_state_n = IDLE;
					end
					e_dma_get_fill_data: begin
						counter_clear = 1&#39;b1;
						dma_state_n = GET_FILL_DATA;
					end
					e_dma_send_evict_data: begin
						counter_clear = 1&#39;b1;
						counter_up = 1&#39;b1;
						data_mem_v_o = 1&#39;b1;
						dma_state_n = SEND_EVICT_DATA;
					end
					e_dma_nop:
						;
					default:
						;
				endcase
			end
			GET_FILL_DATA: begin
				dma_state_n = (counter_fill_max &amp; in_fifo_v_lo ? IDLE : GET_FILL_DATA);
				data_mem_v_o = in_fifo_v_lo;
				data_mem_w_o = in_fifo_v_lo;
				in_fifo_yumi_li = in_fifo_v_lo;
				counter_up = in_fifo_v_lo &amp; ~counter_fill_max;
				counter_clear = in_fifo_v_lo &amp; counter_fill_max;
				done_o = counter_fill_max &amp; in_fifo_v_lo;
			end
			SEND_EVICT_DATA: begin
				dma_state_n = (counter_evict_max &amp; out_fifo_ready_lo ? IDLE : SEND_EVICT_DATA);
				counter_up = out_fifo_ready_lo &amp; ~counter_evict_max;
				counter_clear = out_fifo_ready_lo &amp; counter_evict_max;
				out_fifo_v_li = 1&#39;b1;
				data_mem_v_o = out_fifo_ready_lo &amp; ~counter_evict_max;
				done_o = counter_evict_max &amp; out_fifo_ready_lo;
				dma_evict_o = 1&#39;b1;
			end
			default: dma_state_n = IDLE;
		endcase
	end
	wire [lg_burst_size_in_words_lp - 1:0] snoop_word_offset;
	wire snoop_word_we;
	wire [data_width_p - 1:0] snoop_word_n;
	assign snoop_word_offset = dma_addr_i[byte_offset_width_lp+:lg_burst_size_in_words_lp];
	generate
		if (burst_len_lp == 1) assign snoop_word_we = (dma_state_r == GET_FILL_DATA) &amp; in_fifo_v_lo;
		else if (burst_len_lp == block_size_in_words_p) assign snoop_word_we = ((dma_state_r == GET_FILL_DATA) &amp; in_fifo_v_lo) &amp; (counter_r[0+:lg_burst_len_lp] == dma_addr_i[byte_offset_width_lp+:lg_burst_len_lp]);
		else assign snoop_word_we = ((dma_state_r == GET_FILL_DATA) &amp; in_fifo_v_lo) &amp; (counter_r[0+:lg_burst_len_lp] == dma_addr_i[byte_offset_width_lp + lg_burst_size_in_words_lp+:lg_burst_len_lp]);
	endgenerate
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(burst_size_in_words_lp)
	) snoop_mux0(
		.data_i(in_fifo_data_lo),
		.sel_i(snoop_word_offset),
		.data_o(snoop_word_n)
	);
	always @(posedge clk_i)
		if (reset_i)
			dma_state_r &lt;= IDLE;
		else begin
			dma_state_r &lt;= dma_state_n;
			if (snoop_word_we)
				snoop_word_o &lt;= snoop_word_n;
		end
	always @(posedge clk_i)
		if (debug_p)
			if (dma_pkt_v_o &amp; dma_pkt_yumi_i)
				$display(&#34;&lt;VCACHE&gt; DMA_PKT we:%0d addr:%8h // %8t&#34;, dma_pkt[addr_width_p], dma_pkt[addr_width_p - 1-:addr_width_p], $time);
endmodule

</pre>
</body>
<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_tag_mem.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_tag_mem.v</a>
defines: 
time_elapsed: 0.553s
ram usage: 15704 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_tag_mem.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_tag_mem.v</a>
module bsg_cache_non_blocking_tag_mem (
	clk_i,
	reset_i,
	v_i,
	tag_mem_pkt_i,
	valid_o,
	lock_o,
	tag_o
);
	localparam [4:0] LB = 5&#39;b00000;
	localparam [4:0] LH = 5&#39;b00001;
	localparam [4:0] LW = 5&#39;b00010;
	localparam [4:0] LD = 5&#39;b00011;
	localparam [4:0] LBU = 5&#39;b00100;
	localparam [4:0] LHU = 5&#39;b00101;
	localparam [4:0] LWU = 5&#39;b00110;
	localparam [4:0] SB = 5&#39;b01000;
	localparam [4:0] SH = 5&#39;b01001;
	localparam [4:0] SW = 5&#39;b01010;
	localparam [4:0] SD = 5&#39;b01011;
	localparam [4:0] SM = 5&#39;b01101;
	localparam [4:0] BLOCK_LD = 5&#39;b01110;
	localparam [4:0] TAGST = 5&#39;b10000;
	localparam [4:0] TAGFL = 5&#39;b10001;
	localparam [4:0] TAGLV = 5&#39;b10010;
	localparam [4:0] TAGLA = 5&#39;b10011;
	localparam [4:0] AFL = 5&#39;b11000;
	localparam [4:0] AFLINV = 5&#39;b11001;
	localparam [4:0] AINV = 5&#39;b11010;
	localparam [4:0] ALOCK = 5&#39;b11011;
	localparam [4:0] AUNLOCK = 5&#39;b11100;
	localparam [2:0] e_tag_read = 0;
	localparam [2:0] e_tag_store = 1;
	localparam [2:0] e_tag_set_tag = 2;
	localparam [2:0] e_tag_set_tag_and_lock = 3;
	localparam [2:0] e_tag_invalidate = 4;
	localparam [2:0] e_tag_lock = 5;
	localparam [2:0] e_tag_unlock = 6;
	localparam [2:0] e_stat_read = 0;
	localparam [2:0] e_stat_clear_dirty = 1;
	localparam [2:0] e_stat_set_lru = 2;
	localparam [2:0] e_stat_set_lru_and_dirty = 3;
	localparam [2:0] e_stat_set_lru_and_clear_dirty = 4;
	localparam [2:0] e_stat_reset = 5;
	localparam [1:0] e_miss_fifo_dequeue = 0;
	localparam [1:0] e_miss_fifo_skip = 1;
	localparam [1:0] e_miss_fifo_invalidate = 2;
	localparam [3:0] MHU_IDLE = 0;
	localparam [3:0] MGMT_OP = 1;
	localparam [3:0] SEND_MGMT_DMA = 2;
	localparam [3:0] WAIT_MGMT_DMA = 3;
	localparam [3:0] READ_TAG1 = 4;
	localparam [3:0] SEND_DMA_REQ1 = 5;
	localparam [3:0] WAIT_DMA_DONE = 6;
	localparam [3:0] DEQUEUE_MODE = 7;
	localparam [3:0] READ_TAG2 = 8;
	localparam [3:0] SEND_DMA_REQ2 = 9;
	localparam [3:0] SCAN_MODE = 10;
	localparam [3:0] RECOVER = 11;
	parameter _sv2v_width_sets_p = 24;
	parameter [_sv2v_width_sets_p - 1:0] sets_p = &#34;inv&#34;;
	parameter _sv2v_width_ways_p = 24;
	parameter [_sv2v_width_ways_p - 1:0] ways_p = &#34;inv&#34;;
	parameter _sv2v_width_tag_width_p = 24;
	parameter [_sv2v_width_tag_width_p - 1:0] tag_width_p = &#34;inv&#34;;
	parameter _sv2v_width_data_width_p = 24;
	parameter [_sv2v_width_data_width_p - 1:0] data_width_p = &#34;inv&#34;;
	parameter lg_ways_lp = (ways_p == 1 ? 1 : $clog2(ways_p));
	parameter lg_sets_lp = (sets_p == 1 ? 1 : $clog2(sets_p));
	parameter debug_p = 0;
	parameter tag_mem_pkt_width_lp = ((((ways_p == 1 ? 1 : $clog2(ways_p)) + (sets_p == 1 ? 1 : $clog2(sets_p))) + data_width_p) + tag_width_p) + 3;
	input clk_i;
	input reset_i;
	input v_i;
	input [tag_mem_pkt_width_lp - 1:0] tag_mem_pkt_i;
	output wire [ways_p - 1:0] valid_o;
	output wire [ways_p - 1:0] lock_o;
	output wire [(ways_p * tag_width_p) - 1:0] tag_o;
	localparam tag_info_width_lp = tag_width_p + 2;
	wire [((((ways_p == 1 ? 1 : $clog2(ways_p)) + (sets_p == 1 ? 1 : $clog2(sets_p))) + data_width_p) + tag_width_p) + 2:0] tag_mem_pkt;
	assign tag_mem_pkt = tag_mem_pkt_i;
	reg w_li;
	reg [(ways_p * (2 + tag_width_p)) - 1:0] mask_li;
	reg [(ways_p * (2 + tag_width_p)) - 1:0] data_li;
	wire [(ways_p * (2 + tag_width_p)) - 1:0] data_lo;
	bsg_mem_1rw_sync_mask_write_bit #(
		.width_p(tag_info_width_lp * ways_p),
		.els_p(sets_p),
		.latch_last_read_p(1)
	) tag_mem0(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(v_i),
		.w_i(w_li),
		.addr_i(tag_mem_pkt[(sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))-:(((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))) &gt;= (data_width_p + (tag_width_p + 3)) ? (((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))) - (data_width_p + (tag_width_p + 3))) + 1 : ((data_width_p + (tag_width_p + 3)) - ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))) + 1)]),
		.w_mask_i(mask_li),
		.data_i(data_li),
		.data_o(data_lo)
	);
	wire [ways_p - 1:0] way_decode;
	bsg_decode #(.num_out_p(ways_p)) way_demux(
		.i(tag_mem_pkt[(ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))-:(((ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))) &gt;= ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 3))) ? (((ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))) - ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 3)))) + 1 : (((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 3))) - ((ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))))) + 1)]),
		.o(way_decode)
	);
	always @(*) begin
		w_li = 1&#39;b0;
		data_li = {ways_p * (2 + tag_width_p) {1&#39;sb0}};
		mask_li = {ways_p * (2 + tag_width_p) {1&#39;sb0}};
		case (tag_mem_pkt[2-:3])
			e_tag_read: begin
				w_li = 1&#39;b0;
				data_li = {ways_p * (2 + tag_width_p) {1&#39;sb0}};
				mask_li = {ways_p * (2 + tag_width_p) {1&#39;sb0}};
			end
			e_tag_store: begin
				w_li = 1&#39;b1;
				begin : sv2v_autoblock_1
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							data_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = tag_mem_pkt[(data_width_p + (tag_width_p + 2)) - (data_width_p - 1)+:tag_width_p];
							data_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = tag_mem_pkt[(data_width_p + (tag_width_p + 2)) - ((data_width_p - 1) - (data_width_p - 1))];
							data_li[(i * (2 + tag_width_p)) + tag_width_p] = tag_mem_pkt[(data_width_p + (tag_width_p + 2)) - ((data_width_p - 1) - (data_width_p - 2))];
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = {tag_width_p {way_decode[i]}};
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = way_decode[i];
							mask_li[(i * (2 + tag_width_p)) + tag_width_p] = way_decode[i];
						end
				end
			end
			e_tag_set_tag: begin
				w_li = 1&#39;b1;
				begin : sv2v_autoblock_2
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							data_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = tag_mem_pkt[tag_width_p + 2-:((tag_width_p + 2) &gt;= 3 ? tag_width_p : 4 - (tag_width_p + 2))];
							data_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b1;
							data_li[(i * (2 + tag_width_p)) + tag_width_p] = 1&#39;b0;
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = {tag_width_p {way_decode[i]}};
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = way_decode[i];
							mask_li[(i * (2 + tag_width_p)) + tag_width_p] = 1&#39;b0;
						end
				end
			end
			e_tag_set_tag_and_lock: begin
				w_li = 1&#39;b1;
				begin : sv2v_autoblock_3
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							data_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = tag_mem_pkt[tag_width_p + 2-:((tag_width_p + 2) &gt;= 3 ? tag_width_p : 4 - (tag_width_p + 2))];
							data_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b1;
							data_li[(i * (2 + tag_width_p)) + tag_width_p] = 1&#39;b1;
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = {tag_width_p {way_decode[i]}};
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = way_decode[i];
							mask_li[(i * (2 + tag_width_p)) + tag_width_p] = way_decode[i];
						end
				end
			end
			e_tag_invalidate: begin
				w_li = 1&#39;b1;
				begin : sv2v_autoblock_4
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							data_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = tag_mem_pkt[tag_width_p + 2-:((tag_width_p + 2) &gt;= 3 ? tag_width_p : 4 - (tag_width_p + 2))];
							data_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b0;
							data_li[(i * (2 + tag_width_p)) + tag_width_p] = 1&#39;b0;
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = {tag_width_p {1&#39;b0}};
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = way_decode[i];
							mask_li[(i * (2 + tag_width_p)) + tag_width_p] = way_decode[i];
						end
				end
			end
			e_tag_lock: begin
				w_li = 1&#39;b1;
				begin : sv2v_autoblock_5
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							data_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = tag_mem_pkt[tag_width_p + 2-:((tag_width_p + 2) &gt;= 3 ? tag_width_p : 4 - (tag_width_p + 2))];
							data_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b0;
							data_li[(i * (2 + tag_width_p)) + tag_width_p] = 1&#39;b1;
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = {tag_width_p {1&#39;b0}};
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b0;
							mask_li[(i * (2 + tag_width_p)) + tag_width_p] = way_decode[i];
						end
				end
			end
			e_tag_unlock: begin
				w_li = 1&#39;b1;
				begin : sv2v_autoblock_6
					integer i;
					for (i = 0; i &lt; ways_p; i = i + 1)
						begin
							data_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = tag_mem_pkt[tag_width_p + 2-:((tag_width_p + 2) &gt;= 3 ? tag_width_p : 4 - (tag_width_p + 2))];
							data_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b0;
							data_li[(i * (2 + tag_width_p)) + tag_width_p] = 1&#39;b0;
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p] = {tag_width_p {1&#39;b0}};
							mask_li[(i * (2 + tag_width_p)) + (tag_width_p + 1)] = 1&#39;b0;
							mask_li[(i * (2 + tag_width_p)) + tag_width_p] = way_decode[i];
						end
				end
			end
			default:
				;
		endcase
	end
	generate
		genvar i;
		for (i = 0; i &lt; ways_p; i = i + 1) begin
			assign valid_o[i] = data_lo[(i * (2 + tag_width_p)) + (tag_width_p + 1)];
			assign lock_o[i] = data_lo[(i * (2 + tag_width_p)) + tag_width_p];
			assign tag_o[i * tag_width_p+:tag_width_p] = data_lo[(i * (2 + tag_width_p)) + (tag_width_p - 1)-:tag_width_p];
		end
	endgenerate
	always @(negedge clk_i)
		if (v_i &amp; debug_p)
			$display(&#34;[tag_mem] way=%x, index=%x, opcode=%0s, t=%t&#34;, tag_mem_pkt[(ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))-:(((ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))) &gt;= ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 3))) ? (((ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))) - ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 3)))) + 1 : (((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 3))) - ((ways_p == 1 ? 1 : $clog2(ways_p)) + ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))))) + 1)], tag_mem_pkt[(sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))-:(((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))) &gt;= (data_width_p + (tag_width_p + 3)) ? (((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2))) - (data_width_p + (tag_width_p + 3))) + 1 : ((data_width_p + (tag_width_p + 3)) - ((sets_p == 1 ? 1 : $clog2(sets_p)) + (data_width_p + (tag_width_p + 2)))) + 1)], tag_mem_pkt[2-:3].name, $time);
endmodule

</pre>
</body>
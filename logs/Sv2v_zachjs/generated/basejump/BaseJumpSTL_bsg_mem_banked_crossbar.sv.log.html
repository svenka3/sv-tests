<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_mem
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_mem/bsg_mem_banked_crossbar.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_mem/bsg_mem_banked_crossbar.v</a>
defines: 
time_elapsed: 0.645s
ram usage: 17856 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_mem <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_mem/bsg_mem_banked_crossbar.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_mem/bsg_mem_banked_crossbar.v</a>
module bsg_mem_banked_crossbar_control_o_by_i (
	clk_i,
	reset_i,
	reverse_pr_i,
	valid_i,
	sel_io_i,
	yumi_o,
	ready_i,
	valid_o,
	grants_oi_one_hot_o
);
	parameter i_els_p = -1;
	parameter o_els_p = -1;
	parameter _sv2v_width_rr_lo_hi_p = 24;
	parameter [_sv2v_width_rr_lo_hi_p - 1:0] rr_lo_hi_p = &#34;inv&#34;;
	parameter lg_o_els_lp = (o_els_p == 1 ? 1 : $clog2(o_els_p));
	input clk_i;
	input reset_i;
	input reverse_pr_i;
	input [i_els_p - 1:0] valid_i;
	input [(i_els_p * lg_o_els_lp) - 1:0] sel_io_i;
	output [i_els_p - 1:0] yumi_o;
	input [o_els_p - 1:0] ready_i;
	output [o_els_p - 1:0] valid_o;
	output [(o_els_p * i_els_p) - 1:0] grants_oi_one_hot_o;
	wire [(i_els_p * o_els_p) - 1:0] sel_io_one_hot;
	wire [(i_els_p * o_els_p) - 1:0] grants_io_one_hot;
	wire [(o_els_p * i_els_p) - 1:0] sel_oi_one_hot;
	genvar i;
	generate
		for (i = 0; i &lt; i_els_p; i = i + 1) begin
			function automatic [o_els_p - 1:0] sv2v_cast_FE339;
				input reg [o_els_p - 1:0] inp;
				sv2v_cast_FE339 = inp;
			endfunction
			assign sel_io_one_hot[i * o_els_p+:o_els_p] = (valid_i[i] ? sv2v_cast_FE339(1 &lt;&lt; sel_io_i[i * lg_o_els_lp+:lg_o_els_lp]) : sv2v_cast_FE339(0));
		end
	endgenerate
	bsg_transpose #(
		.width_p(o_els_p),
		.els_p(i_els_p)
	) transpose0(
		.i(sel_io_one_hot),
		.o(sel_oi_one_hot)
	);
	generate
		for (i = 0; i &lt; o_els_p; i = i + 1) begin : arb
			if (((rr_lo_hi_p == 3) || (rr_lo_hi_p == 4)) || (rr_lo_hi_p == 2)) begin : rr
				bsg_round_robin_arb #(
					.inputs_p(i_els_p),
					.hold_on_sr_p(rr_lo_hi_p == 3),
					.reset_on_sr_p(rr_lo_hi_p == 4)
				) round_robin_arb(
					.clk_i(clk_i),
					.reset_i(reset_i),
					.grants_en_i(ready_i[i]),
					.reqs_i(sel_oi_one_hot[i * i_els_p+:i_els_p]),
					.grants_o(grants_oi_one_hot_o[i * i_els_p+:i_els_p]),
					.sel_one_hot_o(),
					.v_o(valid_o[i]),
					.tag_o(),
					.yumi_i(valid_o[i] &amp; ready_i[i])
				);
			end
			else if (rr_lo_hi_p == 5) begin : dynamic
				wire [(2 * i_els_p) - 1:0] grants_oi_one_hot;
				bsg_arb_fixed #(
					.inputs_p(i_els_p),
					.lo_to_hi_p(1&#39;b0)
				) fixed_arb_low(
					.ready_i(ready_i[i]),
					.reqs_i(sel_oi_one_hot[i * i_els_p+:i_els_p]),
					.grants_o(grants_oi_one_hot[0+:i_els_p])
				);
				bsg_arb_fixed #(
					.inputs_p(i_els_p),
					.lo_to_hi_p(1&#39;b1)
				) fixed_arb_high(
					.ready_i(ready_i[i]),
					.reqs_i(sel_oi_one_hot[i * i_els_p+:i_els_p]),
					.grants_o(grants_oi_one_hot[i_els_p+:i_els_p])
				);
				assign grants_oi_one_hot_o[i * i_els_p+:i_els_p] = (reverse_pr_i ? grants_oi_one_hot[i_els_p+:i_els_p] : grants_oi_one_hot[0+:i_els_p]);
				assign valid_o[i] = |grants_oi_one_hot_o[i * i_els_p+:i_els_p];
			end
			else begin : fixed
				bsg_arb_fixed #(
					.inputs_p(i_els_p),
					.lo_to_hi_p(rr_lo_hi_p &amp; 1&#39;b1)
				) fixed_arb(
					.ready_i(ready_i[i]),
					.reqs_i(sel_oi_one_hot[i * i_els_p+:i_els_p]),
					.grants_o(grants_oi_one_hot_o[i * i_els_p+:i_els_p])
				);
				assign valid_o[i] = |grants_oi_one_hot_o[i * i_els_p+:i_els_p];
			end
		end
	endgenerate
	bsg_transpose #(
		.width_p(i_els_p),
		.els_p(o_els_p)
	) transpose1(
		.i(grants_oi_one_hot_o),
		.o(grants_io_one_hot)
	);
	generate
		for (i = 0; i &lt; i_els_p; i = i + 1) assign yumi_o[i] = valid_i[i] &amp; |grants_io_one_hot[i * o_els_p+:o_els_p];
	endgenerate
endmodule
module bsg_mem_banked_crossbar (
	clk_i,
	reset_i,
	reverse_pr_i,
	v_i,
	w_i,
	addr_i,
	data_i,
	mask_i,
	yumi_o,
	v_o,
	data_o
);
	parameter num_ports_p = -1;
	parameter num_banks_p = -1;
	parameter bank_size_p = -1;
	parameter _sv2v_width_rr_lo_hi_p = 24;
	parameter [_sv2v_width_rr_lo_hi_p - 1:0] rr_lo_hi_p = &#34;inv&#34;;
	parameter addr_hash_width_lp = (num_banks_p == 1 ? 1 : $clog2(num_banks_p));
	parameter bank_addr_width_lp = (bank_size_p == 1 ? 1 : $clog2(bank_size_p));
	parameter addr_width_lp = (num_banks_p == 1 ? bank_addr_width_lp : addr_hash_width_lp + bank_addr_width_lp);
	parameter data_width_p = -1;
	parameter debug_p = 0;
	parameter debug_reads_p = debug_p;
	parameter mask_width_lp = data_width_p &gt;&gt; 3;
	input clk_i;
	input reset_i;
	input reverse_pr_i;
	input [num_ports_p - 1:0] v_i;
	input [num_ports_p - 1:0] w_i;
	input [(num_ports_p * addr_width_lp) - 1:0] addr_i;
	input [(num_ports_p * data_width_p) - 1:0] data_i;
	input [(num_ports_p * mask_width_lp) - 1:0] mask_i;
	output [num_ports_p - 1:0] yumi_o;
	output [num_ports_p - 1:0] v_o;
	output [(num_ports_p * data_width_p) - 1:0] data_o;
	localparam debug_lp = debug_p;
	localparam debug_reads_lp = debug_reads_p;
	wire [(num_ports_p * addr_hash_width_lp) - 1:0] bank_reqs;
	genvar i;
	reg [(num_ports_p * addr_width_lp) - 1:0] addr_r;
	always @(posedge clk_i) addr_r &lt;= addr_i;
	generate
		for (i = 0; i &lt; num_ports_p; i = i + 1) if (debug_lp &gt; 1) always @(negedge clk_i) begin
			if (v_i[i] &amp; yumi_o[i])
				if (w_i[i])
					$display(&#34;%m port %d [%x]=%x (mask_i=%b)&#34;, i, addr_i[i * addr_width_lp+:addr_width_lp] * debug_lp, data_i[i * data_width_p+:data_width_p], mask_i[i * mask_width_lp+:mask_width_lp]);
				else if (debug_reads_lp)
					$display(&#34;%m port %d           = [%x]&#34;, i, addr_i[i * addr_width_lp+:addr_width_lp] * debug_lp);
			if (v_o[i] &amp;&amp; debug_reads_lp)
				$display(&#34;%m port %d  %x = [%x]&#34;, i, data_o[i * data_width_p+:data_width_p], addr_r[i * addr_width_lp+:addr_width_lp] * debug_lp);
		end
	endgenerate
	generate
		if (num_banks_p &gt; 1) for (i = 0; i &lt; num_ports_p; i = i + 1) assign bank_reqs[i * addr_hash_width_lp+:addr_hash_width_lp] = addr_i[(i * addr_width_lp) + bank_addr_width_lp+:addr_hash_width_lp];
		else assign bank_reqs = 1&#39;b0;
	endgenerate
	wire [(num_banks_p * num_ports_p) - 1:0] bank_port_grants_one_hot;
	reg [(num_banks_p * num_ports_p) - 1:0] bank_port_grants_one_hot_r;
	wire [num_banks_p - 1:0] bank_v;
	reg [num_banks_p - 1:0] bank_v_r;
	bsg_mem_banked_crossbar_control_o_by_i #(
		.i_els_p(num_ports_p),
		.o_els_p(num_banks_p),
		._sv2v_width_rr_lo_hi_p(_sv2v_width_rr_lo_hi_p),
		.rr_lo_hi_p(rr_lo_hi_p)
	) crossbar_control(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.reverse_pr_i(reverse_pr_i),
		.valid_i(v_i),
		.sel_io_i(bank_reqs),
		.yumi_o(yumi_o),
		.ready_i({num_banks_p {1&#39;b1}}),
		.valid_o(bank_v),
		.grants_oi_one_hot_o(bank_port_grants_one_hot)
	);
	wire [(num_banks_p * data_width_p) - 1:0] bank_data;
	wire [(num_banks_p * data_width_p) - 1:0] bank_data_out;
	bsg_crossbar_o_by_i #(
		.i_els_p(num_ports_p),
		.o_els_p(num_banks_p),
		.width_p(data_width_p)
	) port_bank_data_crossbar(
		.i(data_i),
		.sel_oi_one_hot_i(bank_port_grants_one_hot),
		.o(bank_data)
	);
	wire [(num_ports_p * bank_addr_width_lp) - 1:0] bank_req_addr;
	generate
		for (i = 0; i &lt; num_ports_p; i = i + 1) assign bank_req_addr[i * bank_addr_width_lp+:bank_addr_width_lp] = addr_i[i * addr_width_lp+:bank_addr_width_lp];
	endgenerate
	wire [(num_banks_p * bank_addr_width_lp) - 1:0] bank_addr;
	bsg_crossbar_o_by_i #(
		.i_els_p(num_ports_p),
		.o_els_p(num_banks_p),
		.width_p(bank_addr_width_lp)
	) port_bank_addr_crossbar(
		.i(bank_req_addr),
		.sel_oi_one_hot_i(bank_port_grants_one_hot),
		.o(bank_addr)
	);
	wire [num_banks_p - 1:0] bank_w;
	reg [num_banks_p - 1:0] bank_w_r;
	bsg_crossbar_o_by_i #(
		.i_els_p(num_ports_p),
		.o_els_p(num_banks_p),
		.width_p(1)
	) port_bank_w_crossbar(
		.i(w_i),
		.sel_oi_one_hot_i(bank_port_grants_one_hot),
		.o(bank_w)
	);
	wire [(num_banks_p * mask_width_lp) - 1:0] bank_mask;
	bsg_crossbar_o_by_i #(
		.i_els_p(num_ports_p),
		.o_els_p(num_banks_p),
		.width_p(mask_width_lp)
	) port_bank_mask_crossbar(
		.i(mask_i),
		.sel_oi_one_hot_i(bank_port_grants_one_hot),
		.o(bank_mask)
	);
	generate
		for (i = 0; i &lt; num_banks_p; i = i + 1) begin : z
			if (debug_lp &gt; 1) always @(negedge clk_i)
				if (bank_v[i])
					if (bank_w[i])
						$display(&#34;%m [%x] &lt;= %d&#34;, bank_addr[i * bank_addr_width_lp+:bank_addr_width_lp] * debug_p, bank_data[i * data_width_p+:data_width_p]);
					else
						$display(&#34;%m &lt;= [%x]&#34;, bank_addr[i * bank_addr_width_lp+:bank_addr_width_lp] * debug_p);
			bsg_mem_1rw_sync_mask_write_byte #(
				.data_width_p(data_width_p),
				.els_p(bank_size_p)
			) m1rw_mask(
				.clk_i(clk_i),
				.reset_i(reset_i),
				.data_i(bank_data[i * data_width_p+:data_width_p]),
				.addr_i(bank_addr[i * bank_addr_width_lp+:bank_addr_width_lp]),
				.v_i(bank_v[i]),
				.w_i(bank_w[i]),
				.write_mask_i(bank_mask[i * mask_width_lp+:mask_width_lp]),
				.data_o(bank_data_out[i * data_width_p+:data_width_p])
			);
		end
	endgenerate
	always @(posedge clk_i) begin
		bank_port_grants_one_hot_r &lt;= bank_port_grants_one_hot;
		bank_w_r &lt;= bank_w;
		bank_v_r &lt;= bank_v;
	end
	wire [(num_ports_p * num_banks_p) - 1:0] port_bank_grants_one_hot;
	bsg_transpose #(
		.width_p(num_ports_p),
		.els_p(num_banks_p)
	) grants_transpose(
		.i(bank_port_grants_one_hot_r),
		.o(port_bank_grants_one_hot)
	);
	bsg_crossbar_o_by_i #(
		.i_els_p(num_banks_p),
		.o_els_p(num_ports_p),
		.width_p(data_width_p)
	) bank_port_data_crossbar(
		.i(bank_data_out),
		.sel_oi_one_hot_i(port_bank_grants_one_hot),
		.o(data_o)
	);
	bsg_crossbar_o_by_i #(
		.i_els_p(num_banks_p),
		.o_els_p(num_ports_p),
		.width_p(1)
	) bank_port_v_crossbar(
		.i(bank_v_r &amp; ~bank_w_r),
		.sel_oi_one_hot_i(port_bank_grants_one_hot),
		.o(v_o)
	);
endmodule

</pre>
</body>
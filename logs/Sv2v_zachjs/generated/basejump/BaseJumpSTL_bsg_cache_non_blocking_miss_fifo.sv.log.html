<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_miss_fifo.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_miss_fifo.v</a>
defines: 
time_elapsed: 0.530s
ram usage: 16656 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_cache <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_miss_fifo.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_miss_fifo.v</a>
module bsg_cache_non_blocking_miss_fifo (
	clk_i,
	reset_i,
	data_i,
	v_i,
	ready_o,
	v_o,
	data_o,
	yumi_i,
	yumi_op_i,
	scan_not_dq_i,
	empty_o,
	rollback_i
);
	localparam [4:0] LB = 5&#39;b00000;
	localparam [4:0] LH = 5&#39;b00001;
	localparam [4:0] LW = 5&#39;b00010;
	localparam [4:0] LD = 5&#39;b00011;
	localparam [4:0] LBU = 5&#39;b00100;
	localparam [4:0] LHU = 5&#39;b00101;
	localparam [4:0] LWU = 5&#39;b00110;
	localparam [4:0] SB = 5&#39;b01000;
	localparam [4:0] SH = 5&#39;b01001;
	localparam [4:0] SW = 5&#39;b01010;
	localparam [4:0] SD = 5&#39;b01011;
	localparam [4:0] SM = 5&#39;b01101;
	localparam [4:0] BLOCK_LD = 5&#39;b01110;
	localparam [4:0] TAGST = 5&#39;b10000;
	localparam [4:0] TAGFL = 5&#39;b10001;
	localparam [4:0] TAGLV = 5&#39;b10010;
	localparam [4:0] TAGLA = 5&#39;b10011;
	localparam [4:0] AFL = 5&#39;b11000;
	localparam [4:0] AFLINV = 5&#39;b11001;
	localparam [4:0] AINV = 5&#39;b11010;
	localparam [4:0] ALOCK = 5&#39;b11011;
	localparam [4:0] AUNLOCK = 5&#39;b11100;
	localparam [2:0] e_tag_read = 0;
	localparam [2:0] e_tag_store = 1;
	localparam [2:0] e_tag_set_tag = 2;
	localparam [2:0] e_tag_set_tag_and_lock = 3;
	localparam [2:0] e_tag_invalidate = 4;
	localparam [2:0] e_tag_lock = 5;
	localparam [2:0] e_tag_unlock = 6;
	localparam [2:0] e_stat_read = 0;
	localparam [2:0] e_stat_clear_dirty = 1;
	localparam [2:0] e_stat_set_lru = 2;
	localparam [2:0] e_stat_set_lru_and_dirty = 3;
	localparam [2:0] e_stat_set_lru_and_clear_dirty = 4;
	localparam [2:0] e_stat_reset = 5;
	localparam [1:0] e_miss_fifo_dequeue = 0;
	localparam [1:0] e_miss_fifo_skip = 1;
	localparam [1:0] e_miss_fifo_invalidate = 2;
	localparam [3:0] MHU_IDLE = 0;
	localparam [3:0] MGMT_OP = 1;
	localparam [3:0] SEND_MGMT_DMA = 2;
	localparam [3:0] WAIT_MGMT_DMA = 3;
	localparam [3:0] READ_TAG1 = 4;
	localparam [3:0] SEND_DMA_REQ1 = 5;
	localparam [3:0] WAIT_DMA_DONE = 6;
	localparam [3:0] DEQUEUE_MODE = 7;
	localparam [3:0] READ_TAG2 = 8;
	localparam [3:0] SEND_DMA_REQ2 = 9;
	localparam [3:0] SCAN_MODE = 10;
	localparam [3:0] RECOVER = 11;
	parameter _sv2v_width_width_p = 24;
	parameter [_sv2v_width_width_p - 1:0] width_p = &#34;inv&#34;;
	parameter _sv2v_width_els_p = 24;
	parameter [_sv2v_width_els_p - 1:0] els_p = &#34;inv&#34;;
	input clk_i;
	input reset_i;
	input [width_p - 1:0] data_i;
	input v_i;
	output wire ready_o;
	output wire v_o;
	output wire [width_p - 1:0] data_o;
	input yumi_i;
	input wire [1:0] yumi_op_i;
	input scan_not_dq_i;
	output wire empty_o;
	input rollback_i;
	localparam lg_els_lp = (els_p == 1 ? 1 : $clog2(els_p));
	localparam rptr_inc_width_lp = $clog2(els_p);
	wire [els_p - 1:0] valid_r;
	reg [els_p - 1:0] valid_n;
	bsg_dff_reset #(.width_p(els_p)) valid_dff(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.data_i(valid_n),
		.data_o(valid_r)
	);
	reg [rptr_inc_width_lp - 1:0] rptr_inc;
	wire [lg_els_lp - 1:0] rptr_r;
	wire [lg_els_lp - 1:0] rptr_n;
	bsg_circular_ptr #(
		.slots_p(els_p),
		.max_add_p(els_p - 1)
	) read_ptr0(
		.clk(clk_i),
		.reset_i(reset_i),
		.add_i(rptr_inc),
		.o(rptr_r),
		.n_o(rptr_n)
	);
	function automatic [lg_els_lp - 1:0] sv2v_cast_4DE5F;
		input reg [lg_els_lp - 1:0] inp;
		sv2v_cast_4DE5F = inp;
	endfunction
	wire [lg_els_lp - 1:0] rptr_plus1 = ((els_p - 1) == rptr_r ? sv2v_cast_4DE5F(0) : sv2v_cast_4DE5F(rptr_r + 1));
	wire [lg_els_lp - 1:0] rptr_plus2 = ((els_p - 1) == rptr_plus1 ? sv2v_cast_4DE5F(0) : sv2v_cast_4DE5F(rptr_plus1 + 1));
	wire wptr_inc;
	wire [lg_els_lp - 1:0] wptr_r;
	bsg_circular_ptr #(
		.slots_p(els_p),
		.max_add_p(1)
	) write_ptr0(
		.clk(clk_i),
		.reset_i(reset_i),
		.add_i(wptr_inc),
		.o(wptr_r),
		.n_o()
	);
	reg cptr_inc;
	wire [lg_els_lp - 1:0] cptr_r;
	bsg_circular_ptr #(
		.slots_p(els_p),
		.max_add_p(1)
	) cp_ptr0(
		.clk(clk_i),
		.reset_i(reset_i),
		.add_i(cptr_inc),
		.o(cptr_r),
		.n_o()
	);
	wire rptr_valid = valid_r[rptr_r];
	wire rptr_plus1_valid = valid_r[rptr_plus1];
	wire rptr_plus2_valid = valid_r[rptr_plus2];
	wire cptr_valid = valid_r[cptr_r];
	wire read_write_same_addr = rptr_n == wptr_r;
	wire enque;
	reg deque;
	reg mem_read_en;
	wire [width_p - 1:0] mem_data_lo;
	reg [lg_els_lp - 1:0] mem_read_addr;
	bsg_mem_1r1w_sync #(
		.width_p(width_p),
		.els_p(els_p),
		.harden_p(1),
		.read_write_same_addr_p(0),
		.disable_collision_warning_p(0)
	) mem_1r1w(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.w_v_i(enque),
		.w_addr_i(wptr_r),
		.w_data_i(data_i),
		.r_v_i(mem_read_en),
		.r_addr_i(mem_read_addr),
		.r_data_o(mem_data_lo)
	);
	reg mem_read_en_r;
	reg [lg_els_lp - 1:0] mem_read_addr_r;
	always @(posedge clk_i)
		if (reset_i) begin
			mem_read_en_r &lt;= 1&#39;b0;
			mem_read_addr_r &lt;= {lg_els_lp {1&#39;sb0}};
		end
		else begin
			mem_read_en_r &lt;= mem_read_en;
			if (mem_read_en)
				mem_read_addr_r &lt;= mem_read_addr;
		end
	reg [width_p - 1:0] data_r;
	reg [width_p - 1:0] data_n;
	reg v_r;
	reg v_n;
	always @(posedge clk_i)
		if (reset_i) begin
			data_r &lt;= {width_p {1&#39;sb0}};
			v_r &lt;= 1&#39;b0;
		end
		else begin
			data_r &lt;= data_n;
			v_r &lt;= v_n;
		end
	assign v_o = v_r;
	assign data_o = data_r;
	reg inval;
	wire [els_p - 1:0] inval_decode;
	wire [els_p - 1:0] enque_decode;
	bsg_decode_with_v #(.num_out_p(els_p)) enque_dec(
		.i(wptr_r),
		.v_i(enque),
		.o(enque_decode)
	);
	bsg_decode_with_v #(.num_out_p(els_p)) inval_dec(
		.i(rptr_r),
		.v_i(inval),
		.o(inval_decode)
	);
	always @(*) begin : sv2v_autoblock_1
		integer i;
		for (i = 0; i &lt; els_p; i = i + 1)
			if (inval_decode[i])
				valid_n[i] = 1&#39;b0;
			else if (enque_decode[i])
				valid_n[i] = 1&#39;b1;
			else
				valid_n[i] = valid_r[i];
	end
	reg enque_r;
	reg deque_r;
	always @(posedge clk_i)
		if (reset_i) begin
			enque_r &lt;= 1&#39;b0;
			deque_r &lt;= 1&#39;b1;
		end
		else begin
			if (cptr_inc | enque)
				enque_r &lt;= enque;
			if (rollback_i)
				deque_r &lt;= ~cptr_valid;
			else if (enque | deque)
				deque_r &lt;= deque;
		end
	wire full = enque_r &amp; (cptr_r == wptr_r);
	wire empty = deque_r &amp; (rptr_r == wptr_r);
	assign empty_o = empty;
	assign ready_o = ~full;
	assign enque = ready_o &amp; v_i;
	assign wptr_inc = enque;
	function automatic [rptr_inc_width_lp - 1:0] sv2v_cast_1689D;
		input reg [rptr_inc_width_lp - 1:0] inp;
		sv2v_cast_1689D = inp;
	endfunction
	always @(*)
		if (rollback_i) begin
			deque = 1&#39;b0;
			cptr_inc = 1&#39;b0;
			inval = 1&#39;b0;
			rptr_inc = (cptr_r &gt;= rptr_r ? sv2v_cast_1689D(cptr_r - rptr_r) : sv2v_cast_1689D((els_p + cptr_r) - rptr_r));
			mem_read_en = cptr_valid;
			mem_read_addr = rptr_n;
			v_n = v_r;
			data_n = data_r;
		end
		else if (v_r) begin
			if (yumi_i) begin
				mem_read_addr = ((rptr_n == mem_read_addr_r) &amp; mem_read_en_r ? rptr_plus2 : rptr_plus1);
				mem_read_en = ~read_write_same_addr &amp; ((rptr_n == mem_read_addr_r) &amp; mem_read_en_r ? rptr_plus2_valid : rptr_plus1_valid);
				v_n = (read_write_same_addr ? enque : mem_read_en_r);
				data_n = (read_write_same_addr ? (enque ? data_i : data_r) : (mem_read_en_r ? mem_data_lo : data_r));
				case (yumi_op_i)
					e_miss_fifo_dequeue: begin
						deque = 1&#39;b1;
						inval = 1&#39;b1;
						cptr_inc = 1&#39;b1;
						rptr_inc = sv2v_cast_1689D(1);
					end
					e_miss_fifo_skip: begin
						deque = 1&#39;b1;
						inval = 1&#39;b0;
						cptr_inc = 1&#39;b0;
						rptr_inc = sv2v_cast_1689D(1);
					end
					e_miss_fifo_invalidate: begin
						deque = 1&#39;b1;
						inval = 1&#39;b1;
						cptr_inc = 1&#39;b0;
						rptr_inc = sv2v_cast_1689D(1);
					end
					default: begin
						deque = 1&#39;b0;
						inval = 1&#39;b0;
						cptr_inc = 1&#39;b0;
						rptr_inc = sv2v_cast_1689D(0);
						mem_read_en = 1&#39;b0;
						mem_read_addr = sv2v_cast_4DE5F(0);
						v_n = v_r;
						data_n = data_r;
					end
				endcase
			end
			else begin
				deque = 1&#39;b0;
				inval = 1&#39;b0;
				cptr_inc = 1&#39;b0;
				rptr_inc = sv2v_cast_1689D(0);
				mem_read_en = rptr_plus1_valid;
				mem_read_addr = rptr_plus1;
				v_n = v_r;
				data_n = data_r;
			end
		end
		else begin
			deque = (empty ? 1&#39;b0 : ~rptr_valid);
			inval = 1&#39;b0;
			cptr_inc = (empty ? 1&#39;b0 : (rptr_valid ? 1&#39;b0 : ~scan_not_dq_i));
			rptr_inc = (empty ? sv2v_cast_1689D(0) : (rptr_valid ? 1&#39;b0 : sv2v_cast_1689D(1)));
			mem_read_en = (mem_read_en_r ? rptr_plus1_valid : rptr_valid);
			mem_read_addr = (mem_read_en_r ? rptr_plus1 : rptr_r);
			v_n = (empty ? enque : mem_read_en_r);
			data_n = (empty ? (enque ? data_i : data_r) : (mem_read_en_r ? mem_data_lo : data_r));
		end
	always @(negedge clk_i)
		if (~reset_i)
			if (rollback_i)
				;
endmodule

</pre>
</body>
<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_dataflow
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_dataflow/bsg_1_to_n_tagged_fifo_shared.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_dataflow/bsg_1_to_n_tagged_fifo_shared.v</a>
defines: 
time_elapsed: 0.442s
ram usage: 14656 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_dataflow <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_dataflow/bsg_1_to_n_tagged_fifo_shared.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_dataflow/bsg_1_to_n_tagged_fifo_shared.v</a>
module bsg_1_to_n_tagged_fifo_shared (
	clk_i,
	reset_i,
	valid_i,
	tag_i,
	data_i,
	yumi_o,
	valid_o,
	yumi_i,
	data_o
);
	parameter _sv2v_width_width_p = 24;
	parameter [_sv2v_width_width_p - 1:0] width_p = &#34;inv&#34;;
	parameter _sv2v_width_num_out_p = 24;
	parameter [_sv2v_width_num_out_p - 1:0] num_out_p = &#34;inv&#34;;
	parameter _sv2v_width_els_p = 24;
	parameter [_sv2v_width_els_p - 1:0] els_p = &#34;inv&#34;;
	parameter _sv2v_width_buffering_p = 24;
	parameter [_sv2v_width_buffering_p - 1:0] buffering_p = &#34;inv&#34;;
	parameter unbuffered_mask_p = 0;
	parameter sram_1rw_not_1r1w_p = 1;
	parameter tag_width_lp = (num_out_p == 1 ? 1 : $clog2(num_out_p));
	input clk_i;
	input reset_i;
	input valid_i;
	input [tag_width_lp - 1:0] tag_i;
	input [width_p - 1:0] data_i;
	output yumi_o;
	output [num_out_p - 1:0] valid_o;
	input [num_out_p - 1:0] yumi_i;
	output [(num_out_p * width_p) - 1:0] data_o;
	localparam ptr_width_lp = (els_p == 1 ? 1 : $clog2(els_p));
	genvar i;
	wire [(num_out_p * ptr_width_lp) - 1:0] rptr_r;
	wire [(num_out_p * ptr_width_lp) - 1:0] wptr_r;
	wire [num_out_p - 1:0] full;
	wire [num_out_p - 1:0] empty;
	wire [num_out_p - 1:0] enque;
	wire [num_out_p - 1:0] deque;
	wire [(num_out_p * (buffering_p == 1 ? 1 : $clog2(buffering_p))) - 1:0] els;
	wire [num_out_p - 1:0] credits_avail;
	wire read_req;
	wire write_req = valid_i;
	wire [tag_width_lp - 1:0] read_req_tag;
	wire [tag_width_lp - 1:0] read_req_tag_r;
	wire [num_out_p - 1:0] read_req_tag_decoded;
	wire big_ram_we;
	wire big_ram_re;
	wire read_ram_re_r;
	wire [num_out_p - 1:0] tag_one_hot_or_not;
	bsg_1_to_n_tagged #(.num_out_p(num_out_p)) b1nt(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.valid_i(valid_i),
		.tag_i(tag_i),
		.yumi_o(yumi_o),
		.valid_o(tag_one_hot_or_not),
		.ready_i(~full)
	);
	assign enque = ~full &amp; tag_one_hot_or_not;
	generate
		for (i = 0; i &lt; num_out_p; i = i + 1) begin : rof
			if (unbuffered_mask_p[i]) begin : unbuf
				assign wptr_r[i * ptr_width_lp+:ptr_width_lp] = 0;
				assign rptr_r[i * ptr_width_lp+:ptr_width_lp] = 0;
				assign full[i] = 1&#39;b0;
				assign empty[i] = 1&#39;b1;
				assign els[i * (buffering_p == 1 ? 1 : $clog2(buffering_p))+:(buffering_p == 1 ? 1 : $clog2(buffering_p))] = 0;
			end
			else begin : bufd
				bsg_fifo_tracker #(.els_p(els_p)) ft(
					.clk_i(clk_i),
					.reset_i(reset_i),
					.enq_i(enque[i]),
					.deq_i(deque[i]),
					.wptr_r_o(wptr_r[i * ptr_width_lp+:ptr_width_lp]),
					.rptr_r_o(rptr_r[i * ptr_width_lp+:ptr_width_lp]),
					.full_o(full[i]),
					.empty_o(empty[i])
				);
				bsg_counter_up_down #(
					.max_val_p(buffering_p),
					.init_val_p(buffering_p)
				) bcudb(
					.clk_i(clk_i),
					.reset_i(reset_i),
					.up_i(yumi_i[i]),
					.down_i(read_req_tag_decoded[i] &amp; big_ram_re),
					.count_o(els[i * (buffering_p == 1 ? 1 : $clog2(buffering_p))+:(buffering_p == 1 ? 1 : $clog2(buffering_p))])
				);
				assign credits_avail[i] = |els[i * (buffering_p == 1 ? 1 : $clog2(buffering_p))+:(buffering_p == 1 ? 1 : $clog2(buffering_p))];
			end
		end
	endgenerate
	wire selected_reader_vec;
	bsg_round_robin_arb #(.inputs_p(num_out_p)) rdr_arb(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.grants_en_i(1&#39;b1),
		.reqs_i(credits_avail &amp; ~empty),
		.grants_o(selected_reader_vec),
		.sel_one_hot_o(),
		.v_o(read_req),
		.tag_o(read_req_tag),
		.yumi_i(big_ram_re &amp; read_req)
	);
	wire [(tag_width_lp + ptr_width_lp) - 1:0] big_ram_wptr = {tag_i, wptr_r[tag_i * ptr_width_lp+:ptr_width_lp]};
	wire [(tag_width_lp + ptr_width_lp) - 1:0] big_ram_rptr = {read_req_tag, rptr_r[read_req_tag * ptr_width_lp+:ptr_width_lp]};
	wire [width_p - 1:0] sram_data_lo;
	wire tag_i_is_unbuffered = unbuffered_mask_p[tag_i];
	generate
		if (sram_1rw_not_1r1w_p) begin : _1rw
			assign big_ram_we = write_req &amp; ~tag_i_is_unbuffered;
			assign big_ram_re = ~write_req &amp; read_req;
			bsg_mem_1rw_sync #(
				.width_p(width_p),
				.els_p(els_p)
			) big_ram(
				.clk_i(clk_i),
				.reset_i(reset_i),
				.data_i(data_i),
				.addr_i((big_ram_we ? wptr_big_ram : rptr_big_ram)),
				.v_i(big_ram_we | big_ram_re),
				.w_i(big_ram_we),
				.data_o(sram_data_lo)
			);
		end
		else begin : _1r1w
			assign big_ram_we = write_req &amp; ~tag_i_is_unbuffered;
			assign big_ram_re = ready_req;
			wire wptr_big_ram;
			wire rptr_big_ram;
			bgs_mem_1r1w_sync #(
				.width_p(width_p),
				.els_p(els_p)
			) big_ram(
				.clk_i(clk_i),
				.reset_i(reset_i),
				.w_v_i(big_ram_we),
				.w_addr_i(wptr_big_ram),
				.w_data_i(data_i),
				.r_v_i(big_ram_re),
				.r_addr_i(rptr_big_ram),
				.r_data_o(sram_data_lo)
			);
		end
	endgenerate
	bsg_dff_reset #(
		.width_p(&#39;x + tag_width_lp),
		.init_val_p(0)
	) dff(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.data_i({big_ram_re, read_req_tag}),
		.data_o({big_ram_re_r, read_req_tag_r})
	);
	wire yumi_lo;
	wire [num_out_p - 1:0] yumi_i_tmp = yumi_i &amp; ~unbuffered_mask_p;
	wire [num_out_p - 1:0] valid_o_tmp;
	wire [(num_out_p * width_p) - 1:0] data_o_tmp;
	wire big_ram_re_r;
	bsg_1_to_n_tagged_fifo #(
		.width_p(width_p),
		.num_out_p(num_out_p),
		.els_p(els_p),
		.unbuffered_mask_p(unbuffered_mask_p)
	) b1ntf(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.valid_i(big_ram_re_r),
		.tag_i(read_req_tag_r),
		.data_i(sram_data_lo),
		.yumi_o(yumi_lo),
		.valid_o(valid_o_tmp),
		.yumi_i(yumi_i_tmp),
		.data_o(data_o_tmp)
	);
	assign valid_o = valid_o_tmp | (unbuffered_mask_p[i] &amp; tag_one_hot_or_not[i]);
	generate
		for (i = 0; i &lt; num_out_p; i = i + 1) begin : rof
			assign data_o[i * width_p+:width_p] = (unbuffered_mask_p[i] ? data_i : data_o_tmp);
		end
	endgenerate
	always @(negedge clk_i)
		;
endmodule

</pre>
</body>
<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_comm_link
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_master.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_master.v</a>
defines: 
time_elapsed: 0.728s
ram usage: 17768 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I/tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_comm_link <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_master.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_comm_link/bsg_source_sync_channel_control_master.v</a>
module bsg_source_sync_channel_control_master (
	out_clk_i,
	out_reset_i,
	out_calibration_state_i,
	out_calib_prepare_i,
	out_channel_blessed_i,
	out_override_en_o,
	out_override_valid_data_o,
	out_override_is_posedge_i,
	out_test_pass_r_o,
	in_clk_i,
	in_reset_i,
	in_snoop_valid_data_neg_i,
	in_snoop_valid_data_pos_i,
	out_infinite_credits_o
);
	parameter width_p = -1;
	parameter lg_token_width_p = 6;
	parameter lg_out_prepare_hold_cycles_p = 6;
	parameter bypass_test_p = 5&#39;b00000;
	parameter tests_lp = 5;
	parameter verbose_lp = 1;
	input out_clk_i;
	input out_reset_i;
	input [$clog2(tests_lp + 1) - 1:0] out_calibration_state_i;
	input out_calib_prepare_i;
	input out_channel_blessed_i;
	output out_override_en_o;
	output [width_p:0] out_override_valid_data_o;
	input out_override_is_posedge_i;
	output [tests_lp:0] out_test_pass_r_o;
	input in_clk_i;
	input in_reset_i;
	input [width_p:0] in_snoop_valid_data_neg_i;
	input [width_p:0] in_snoop_valid_data_pos_i;
	output out_infinite_credits_o;
	localparam counter_min_bits_lp = 24;
	localparam counter_bits_lp = (counter_min_bits_lp &gt; (((width_p + 1) * 2) + 1) ? counter_min_bits_lp : ((width_p + 1) * 2) + 1);
	reg [counter_bits_lp - 1:0] out_ctr_r;
	reg [counter_bits_lp - 1:0] out_ctr_n;
	reg [width_p:0] out_override_valid_data_r;
	reg [width_p:0] out_override_valid_data_n;
	reg out_override_en_r;
	reg out_override_en_n;
	reg out_calib_prepare_i_r;
	reg [tests_lp:0] out_test_pass_r;
	reg [tests_lp:0] out_test_pass_n;
	wire [(((width_p + 1) &gt;&gt; 1) &lt;&lt; 1) - 1:0] inactive_pattern = {(width_p + 1) &gt;&gt; 1 {2&#39;b01}};
	assign out_override_valid_data_o = out_override_valid_data_r;
	assign out_override_en_o = out_override_en_r;
	assign out_test_pass_r_o = out_test_pass_r[tests_lp:0];
	reg [4:0] out_calib_code;
	reg out_activating;
	always @(*) begin
		out_activating = 1&#39;b0;
		case (out_calibration_state_i)
			0: out_calib_code = 5&#39;b01111;
			1: out_calib_code = 5&#39;b00100;
			2: out_calib_code = 5&#39;b00101;
			3: out_calib_code = 5&#39;b00010;
			4: out_calib_code = 5&#39;b00011;
			tests_lp: begin
				out_calib_code = (out_channel_blessed_i ? 5&#39;b00110 : 5&#39;b01001);
				out_activating = out_channel_blessed_i;
			end
			default: out_calib_code = 5&#39;b00001;
		endcase
	end
	wire [width_p:0] out_calib_code_padded;
	generate
		if (width_p &lt;= 4) assign out_calib_code_padded = out_calib_code[4-:1 + width_p];
		else assign out_calib_code_padded = {out_calib_code, inactive_pattern[width_p - 5:0] ^ {width_p - 4 {out_activating}}};
	endgenerate
	reg out_finish_prepare_r;
	reg out_finish_prepare_n;
	function automatic [counter_bits_lp - 1:0] sv2v_cast_2CCCC;
		input reg [counter_bits_lp - 1:0] inp;
		sv2v_cast_2CCCC = inp;
	endfunction
	always @(posedge out_clk_i) begin
		out_calib_prepare_i_r &lt;= out_calib_prepare_i;
		if (out_reset_i)
			out_test_pass_r &lt;= bypass_test_p;
		else
			out_test_pass_r &lt;= out_test_pass_n;
		out_finish_prepare_r &lt;= out_finish_prepare_n;
		if (out_calib_prepare_i ^ out_calib_prepare_i_r)
			out_ctr_r &lt;= sv2v_cast_2CCCC(0);
		else
			out_ctr_r &lt;= out_ctr_n;
		out_override_valid_data_r &lt;= out_override_valid_data_n;
		out_override_en_r &lt;= out_override_en_n;
		if (verbose_lp)
			if (((out_reset_i === 0) &amp; (out_calib_prepare_i !== 1&#39;sbx)) &amp; (out_calib_prepare_i ^ out_calib_prepare_i_r))
				$display(&#34;## Master %m:  %s prepare part for Phase %1d (out_calib_prepare_i = %b, out_calib_prepare_i_r = %b)&#34;, (out_calib_prepare_i ? &#34;entering&#34; : &#34;exiting&#34;), out_calibration_state_i, out_calib_prepare_i, out_calib_prepare_i_r);
	end
	wire [counter_bits_lp - 1:0] out_ctr_r_p1 = out_ctr_r + 1&#39;b1;
	wire [tests_lp:0] out_phase_X_good;
	function automatic [width_p - 1:0] sv2v_cast_89401;
		input reg [width_p - 1:0] inp;
		sv2v_cast_89401 = inp;
	endfunction
	always @(*) begin
		out_finish_prepare_n = (out_reset_i ? 0 : out_finish_prepare_r);
		out_ctr_n = (out_reset_i ? 0 : out_ctr_r);
		out_test_pass_n = out_test_pass_r;
		out_override_en_n = 1&#39;b0;
		out_override_valid_data_n = {1&#39;b0, sv2v_cast_89401(0)};
		if (out_calib_prepare_i) begin
			out_override_en_n = 1&#39;b1;
			out_finish_prepare_n = 1&#39;b1;
			out_test_pass_n[out_calibration_state_i] = 1&#39;b0;
			out_override_valid_data_n = out_calib_code_padded;
			out_ctr_n = out_ctr_r_p1;
			if (out_ctr_r[counter_min_bits_lp - 1:lg_token_width_p] == 1&#39;b1)
				out_override_valid_data_n = {2&#39;b11, {width_p - 3 {1&#39;b0}}, out_calibration_state_i[1:0]};
		end
		else if (out_finish_prepare_r) begin
			out_ctr_n = out_ctr_r_p1;
			out_override_en_n = 1&#39;b1;
			out_override_valid_data_n = out_calib_code_padded;
			if (out_ctr_r[lg_out_prepare_hold_cycles_p] &amp; ~out_calib_prepare_i_r)
				out_finish_prepare_n = 1&#39;b0;
		end
		else begin
			out_test_pass_n[out_calibration_state_i] = out_phase_X_good[out_calibration_state_i];
			if (~(|out_calibration_state_i))
				out_test_pass_n[0] = 1&#39;b1;
			case (out_calibration_state_i)
				2:
					;
				3:
					;
				default:
					;
			endcase
		end
	end
	wire [tests_lp:0] in_phase_X_good;
	bsg_launch_sync_sync #(.width_p(tests_lp + 1)) in_to_out(
		.iclk_i(in_clk_i),
		.iclk_reset_i(1&#39;b0),
		.oclk_i(out_clk_i),
		.iclk_data_i(in_phase_X_good),
		.iclk_data_o(),
		.oclk_data_o(out_phase_X_good)
	);
	wire [tests_lp - 1:0] in_test_enables;
	function automatic [tests_lp - 1:0] sv2v_cast_5646B;
		input reg [tests_lp - 1:0] inp;
		sv2v_cast_5646B = inp;
	endfunction
	wire [tests_lp - 1:0] out_test_enables = sv2v_cast_5646B((1 &lt;&lt; out_calibration_state_i) &amp; {tests_lp {~out_calib_prepare_i}});
	bsg_launch_sync_sync #(.width_p(tests_lp)) out_to_in(
		.iclk_i(out_clk_i),
		.iclk_reset_i(1&#39;b0),
		.oclk_i(in_clk_i),
		.iclk_data_i(out_test_enables),
		.iclk_data_o(),
		.oclk_data_o(in_test_enables)
	);
	reg [width_p:0] in_last_pos_r;
	reg [width_p:0] in_last_neg_r;
	reg [width_p:0] in_last_last_pos_r;
	reg [(2 * (width_p + 1)) - 1:0] in_consec_pos_neg_match_r;
	reg [(2 * (width_p + 1)) - 1:0] in_consec_neg_pos_match_r;
	wire in_pos_neg_match = ({in_last_pos_r, in_last_neg_r} + 1&#39;b1) == {in_snoop_valid_data_pos_i, in_snoop_valid_data_neg_i};
	wire in_neg_pos_match = ({in_last_neg_r, in_last_last_pos_r} + 1&#39;b1) == {in_snoop_valid_data_neg_i, in_last_pos_r};
	assign out_infinite_credits_o = out_test_enables[3] | out_test_enables[4];
	always @(posedge in_clk_i) begin
		if (in_reset_i) begin
			in_last_pos_r &lt;= in_snoop_valid_data_pos_i;
			in_last_neg_r &lt;= in_snoop_valid_data_neg_i;
			in_consec_neg_pos_match_r &lt;= 0;
			in_consec_pos_neg_match_r &lt;= 0;
		end
		if (in_test_enables[2]) begin
			in_last_pos_r &lt;= in_snoop_valid_data_pos_i;
			in_last_neg_r &lt;= in_snoop_valid_data_neg_i;
			in_last_last_pos_r &lt;= in_last_pos_r;
			in_consec_pos_neg_match_r &lt;= (in_pos_neg_match &amp; ~in_reset_i ? (&amp;in_consec_pos_neg_match_r ? in_consec_pos_neg_match_r : in_consec_pos_neg_match_r + 1&#39;b1) : 0);
			in_consec_neg_pos_match_r &lt;= (in_neg_pos_match &amp; ~in_reset_i ? (&amp;in_consec_neg_pos_match_r ? in_consec_neg_pos_match_r : in_consec_neg_pos_match_r + 1&#39;b1) : 0);
			if (in_test_enables[2] !== 1&#39;sbx) begin
				if ((in_consec_pos_neg_match_r &gt; 100) &amp; !in_pos_neg_match)
					$display(&#34;## Phase 1 Mismatch(P) %x %x %x %x&#34;, in_last_pos_r, in_last_neg_r, in_snoop_valid_data_pos_i, in_snoop_valid_data_neg_i);
				if ((in_consec_neg_pos_match_r &gt; 100) &amp; !in_neg_pos_match)
					$display(&#34;## Phase 1 Mismatch(N) %x %x %x %x&#34;, in_last_neg_r, in_last_last_pos_r, in_snoop_valid_data_neg_i, in_last_pos_r);
				if (&amp;in_consec_pos_neg_match_r &amp;&amp; ~in_pos_neg_match)
					$display(&#34;## Phase 1 Pos Lock&#34;);
				if (&amp;in_consec_neg_pos_match_r &amp;&amp; ~in_neg_pos_match)
					$display(&#34;## Phase 1 Neg Lock&#34;);
				if (verbose_lp) begin
					if ((in_consec_pos_neg_match_r &amp; 12&#39;hfff) == 12&#39;hffe)
						$display(&#34;## Posmatch %x; negmatch %x&#34;, in_consec_pos_neg_match_r, in_consec_neg_pos_match_r);
					if ((in_consec_neg_pos_match_r &amp; 12&#39;hfff) == 12&#39;hffe)
						$display(&#34;## Posmatch %x; negmatch %x&#34;, in_consec_pos_neg_match_r, in_consec_neg_pos_match_r);
				end
			end
		end
	end
	assign in_phase_X_good[0] = 1&#39;b1;
	assign in_phase_X_good[1] = bypass_test_p[1];
	assign in_phase_X_good[2] = (&amp;in_consec_neg_pos_match_r | &amp;in_consec_pos_neg_match_r) | bypass_test_p[2];
	assign in_phase_X_good[tests_lp - 1:3] = bypass_test_p[tests_lp - 1:3];
	assign in_phase_X_good[tests_lp] = 1&#39;b1;
endmodule

</pre>
</body>
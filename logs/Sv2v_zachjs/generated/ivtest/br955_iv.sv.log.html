<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Test imported from ivtest
rc: 0 (means success: 1)
tags: ivtest
incdirs: /tmpfs/src/github/sv-tests/third_party/tests/ivtest /tmpfs/src/github/sv-tests/third_party/tests/ivtest/ivltests
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/tests/ivtest/ivltests/br955.v.html" target="file-frame">third_party/tests/ivtest/ivltests/br955.v</a>
defines: 
time_elapsed: 0.247s
ram usage: 10412 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/tests/ivtest -I/tmpfs/src/github/sv-tests/third_party/tests/ivtest/ivltests <a href="../../../../third_party/tests/ivtest/ivltests/br955.v.html" target="file-frame">third_party/tests/ivtest/ivltests/br955.v</a>
module mux_2_to_1 (
	sel_i,
	dat_i,
	dat_o
);
	input sel_i;
	input [1:0] dat_i;
	output dat_o;
	assign dat_o = (sel_i &amp;&amp; dat_i[1]) || (~sel_i &amp;&amp; dat_i[0]);
endmodule
module mux_n_to_1 (
	inputs_i,
	sel_i,
	output_o
);
	parameter sel_w = 4;
	parameter n_inputs = 2 ** sel_w;
	input [n_inputs - 1:0] inputs_i;
	input [sel_w - 1:0] sel_i;
	output output_o;
	genvar i;
	genvar j;
	generate
		if (sel_w == 1) mux_2_to_1 mux_simple(
			.sel_i(sel_i),
			.dat_i(inputs_i),
			.dat_o(output_o)
		);
		else begin
			wire [n_inputs - 2:0] inter_w;
			for (i = 0; i &lt; sel_w; i = i + 1) begin : SELECT_STAGE
				if (i == 0) for (j = 0; j &lt; (n_inputs / 2); j = j + 1) begin : FIRST_STAGE
					mux_2_to_1 mux_first_stage(
						.sel_i(sel_i[i]),
						.dat_i(inputs_i[(2 * j) + 1:2 * j]),
						.dat_o(inter_w[j])
					);
				end
				else for (j = 0; j &lt; (n_inputs / (2 ** (i + 1))); j = j + 1) begin : INTERMEDIARY_STAGE
					mux_2_to_1 mux_intermediary_stages(
						.sel_i(sel_i[i]),
						.dat_i(inter_w[(((n_inputs / (2 ** (i - 1))) * ((2 ** (i - 1)) - 1)) + (2 * j)) + 1:((n_inputs / (2 ** (i - 1))) * ((2 ** (i - 1)) - 1)) + (2 * j)]),
						.dat_o(inter_w[((n_inputs / (2 ** i)) * ((2 ** i) - 1)) + j])
					);
				end
			end
			assign output_o = inter_w[(n_inputs / (2 ** (sel_w - 1))) * ((2 ** (sel_w - 1)) - 1)];
		end
	endgenerate
endmodule
module top;
	parameter sel_wid = 3;
	parameter num_inputs = 2 ** sel_wid;
	reg [num_inputs - 1:0] in;
	reg [sel_wid - 1:0] sel;
	wire out;
	integer lp;
	reg pass;
	mux_n_to_1 #(
		.sel_w(sel_wid),
		.n_inputs(num_inputs)
	) dut(
		.inputs_i(in),
		.sel_i(sel),
		.output_o(out)
	);
	initial begin
		pass = 1&#39;b1;
		for (lp = 0; lp &lt; num_inputs; lp = lp + 1)
			begin
				sel = lp;
				in = 2 ** lp;
				$display(&#34;Checking input %0d;&#34;, sel);
				#(1)
					;
				if (out !== 1&#39;b1) begin
					$display(&#34;  Failed input high (%b), got %b&#34;, in, out);
					pass = 1&#39;b0;
				end
				in = ~in;
				#(1)
					;
				if (out !== 1&#39;b0) begin
					$display(&#34;  Failed input low (%b), got %b&#34;, in, out);
					pass = 1&#39;b0;
				end
			end
		if (pass)
			$display(&#34;PASSED&#34;);
	end
endmodule

</pre>
</body>
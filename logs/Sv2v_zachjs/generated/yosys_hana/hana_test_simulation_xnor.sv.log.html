<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from yosys
rc: 0 (means success: 1)
tags: yosys
incdirs: /tmpfs/src/github/sv-tests/tests/generated/yosys_hana
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/tools/yosys/tests/hana/test_simulation_xnor.v.html" target="file-frame">third_party/tools/yosys/tests/hana/test_simulation_xnor.v</a> <a href="../../../../third_party/tools/yosys/tests/hana/hana_vlib.v.html" target="file-frame">third_party/tools/yosys/tests/hana/hana_vlib.v</a>
defines: 
time_elapsed: 0.776s
ram usage: 21956 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/tests/generated/yosys_hana <a href="../../../../third_party/tools/yosys/tests/hana/test_simulation_xnor.v.html" target="file-frame">third_party/tools/yosys/tests/hana/test_simulation_xnor.v</a> <a href="../../../../third_party/tools/yosys/tests/hana/hana_vlib.v.html" target="file-frame">third_party/tools/yosys/tests/hana/hana_vlib.v</a>
module f1_test (
	in,
	out
);
	input [1:0] in;
	output out;
	assign out = ~(in[0] ^ in[1]);
endmodule
module f2_test (
	in,
	out
);
	input [2:0] in;
	output out;
	assign out = ~((in[0] ^ in[1]) ^ in[2]);
endmodule
module f3_test (
	in,
	out
);
	input [3:0] in;
	output out;
	assign out = ~(((in[0] ^ in[1]) ^ in[2]) ^ in[3]);
endmodule
module f4_test (
	in,
	out
);
	input [3:0] in;
	output out;
	xnor myxnor (out, in[0], in[1], in[2], in[3]);
endmodule
module BUF (
	in,
	out
);
	input in;
	output out;
	assign out = in;
endmodule
module TRIBUF (
	in,
	enable,
	out
);
	input in;
	input enable;
	output out;
	assign out = (enable ? in : 1&#39;bz);
endmodule
module INV (
	in,
	out
);
	input in;
	output out;
	assign out = ~in;
endmodule
module AND2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = &amp;in;
endmodule
module AND3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = &amp;in;
endmodule
module AND4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = &amp;in;
endmodule
module OR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = |in;
endmodule
module OR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = |in;
endmodule
module OR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = |in;
endmodule
module NAND2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~&amp;in;
endmodule
module NAND3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~&amp;in;
endmodule
module NAND4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~&amp;in;
endmodule
module NOR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~|in;
endmodule
module NOR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~|in;
endmodule
module NOR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~|in;
endmodule
module XOR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ^in;
endmodule
module XOR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ^in;
endmodule
module XOR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ^in;
endmodule
module XNOR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~^in;
endmodule
module XNOR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~^in;
endmodule
module XNOR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~^in;
endmodule
module DEC1 (
	in,
	enable,
	out
);
	input in;
	input enable;
	output reg [1:0] out;
	always @(in or enable)
		if (!enable)
			out = 2&#39;b00;
		else
			case (in)
				1&#39;b0: out = 2&#39;b01;
				1&#39;b1: out = 2&#39;b10;
			endcase
endmodule
module DEC2 (
	in,
	enable,
	out
);
	input [1:0] in;
	input enable;
	output reg [3:0] out;
	always @(in or enable)
		if (!enable)
			out = 4&#39;b0000;
		else
			case (in)
				2&#39;b00: out = 4&#39;b0001;
				2&#39;b01: out = 4&#39;b0010;
				2&#39;b10: out = 4&#39;b0100;
				2&#39;b11: out = 4&#39;b1000;
			endcase
endmodule
module DEC3 (
	in,
	enable,
	out
);
	input [2:0] in;
	input enable;
	output reg [7:0] out;
	always @(in or enable)
		if (!enable)
			out = 8&#39;b00000000;
		else
			case (in)
				3&#39;b000: out = 8&#39;b00000001;
				3&#39;b001: out = 8&#39;b00000010;
				3&#39;b010: out = 8&#39;b00000100;
				3&#39;b011: out = 8&#39;b00001000;
				3&#39;b100: out = 8&#39;b00010000;
				3&#39;b101: out = 8&#39;b00100000;
				3&#39;b110: out = 8&#39;b01000000;
				3&#39;b111: out = 8&#39;b10000000;
			endcase
endmodule
module DEC4 (
	in,
	enable,
	out
);
	input [3:0] in;
	input enable;
	output reg [15:0] out;
	always @(in or enable)
		if (!enable)
			out = 16&#39;b0000000000000000;
		else
			case (in)
				4&#39;b0000: out = 16&#39;b0000000000000001;
				4&#39;b0001: out = 16&#39;b0000000000000010;
				4&#39;b0010: out = 16&#39;b0000000000000100;
				4&#39;b0011: out = 16&#39;b0000000000001000;
				4&#39;b0100: out = 16&#39;b0000000000010000;
				4&#39;b0101: out = 16&#39;b0000000000100000;
				4&#39;b0110: out = 16&#39;b0000000001000000;
				4&#39;b0111: out = 16&#39;b0000000010000000;
				4&#39;b1000: out = 16&#39;b0000000100000000;
				4&#39;b1001: out = 16&#39;b0000001000000000;
				4&#39;b1010: out = 16&#39;b0000010000000000;
				4&#39;b1011: out = 16&#39;b0000100000000000;
				4&#39;b1100: out = 16&#39;b0001000000000000;
				4&#39;b1101: out = 16&#39;b0010000000000000;
				4&#39;b1110: out = 16&#39;b0100000000000000;
				4&#39;b1111: out = 16&#39;b1000000000000000;
			endcase
endmodule
module DEC5 (
	in,
	enable,
	out
);
	input [4:0] in;
	input enable;
	output reg [31:0] out;
	always @(in or enable)
		if (!enable)
			out = 32&#39;b00000000000000000000000000000000;
		else
			case (in)
				5&#39;b00000: out = 32&#39;b00000000000000000000000000000001;
				5&#39;b00001: out = 32&#39;b00000000000000000000000000000010;
				5&#39;b00010: out = 32&#39;b00000000000000000000000000000100;
				5&#39;b00011: out = 32&#39;b00000000000000000000000000001000;
				5&#39;b00100: out = 32&#39;b00000000000000000000000000010000;
				5&#39;b00101: out = 32&#39;b00000000000000000000000000100000;
				5&#39;b00110: out = 32&#39;b00000000000000000000000001000000;
				5&#39;b00111: out = 32&#39;b00000000000000000000000010000000;
				5&#39;b01000: out = 32&#39;b00000000000000000000000100000000;
				5&#39;b01001: out = 32&#39;b00000000000000000000001000000000;
				5&#39;b01010: out = 32&#39;b00000000000000000000010000000000;
				5&#39;b01011: out = 32&#39;b00000000000000000000100000000000;
				5&#39;b01100: out = 32&#39;b00000000000000000001000000000000;
				5&#39;b01101: out = 32&#39;b00000000000000000010000000000000;
				5&#39;b01110: out = 32&#39;b00000000000000000100000000000000;
				5&#39;b01111: out = 32&#39;b00000000000000001000000000000000;
				5&#39;b10000: out = 32&#39;b00000000000000010000000000000000;
				5&#39;b10001: out = 32&#39;b00000000000000100000000000000000;
				5&#39;b10010: out = 32&#39;b00000000000001000000000000000000;
				5&#39;b10011: out = 32&#39;b00000000000010000000000000000000;
				5&#39;b10100: out = 32&#39;b00000000000100000000000000000000;
				5&#39;b10101: out = 32&#39;b00000000001000000000000000000000;
				5&#39;b10110: out = 32&#39;b00000000010000000000000000000000;
				5&#39;b10111: out = 32&#39;b00000000100000000000000000000000;
				5&#39;b11000: out = 32&#39;b00000001000000000000000000000000;
				5&#39;b11001: out = 32&#39;b00000010000000000000000000000000;
				5&#39;b11010: out = 32&#39;b00000100000000000000000000000000;
				5&#39;b11011: out = 32&#39;b00001000000000000000000000000000;
				5&#39;b11100: out = 32&#39;b00010000000000000000000000000000;
				5&#39;b11101: out = 32&#39;b00100000000000000000000000000000;
				5&#39;b11110: out = 32&#39;b01000000000000000000000000000000;
				5&#39;b11111: out = 32&#39;b10000000000000000000000000000000;
			endcase
endmodule
module DEC6 (
	in,
	enable,
	out
);
	input [5:0] in;
	input enable;
	output reg [63:0] out;
	always @(in or enable)
		if (!enable)
			out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000000;
		else
			case (in)
				6&#39;b000000: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000001;
				6&#39;b000001: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000010;
				6&#39;b000010: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000100;
				6&#39;b000011: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000001000;
				6&#39;b000100: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000010000;
				6&#39;b000101: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000100000;
				6&#39;b000110: out = 64&#39;b0000000000000000000000000000000000000000000000000000000001000000;
				6&#39;b000111: out = 64&#39;b0000000000000000000000000000000000000000000000000000000010000000;
				6&#39;b001000: out = 64&#39;b0000000000000000000000000000000000000000000000000000000100000000;
				6&#39;b001001: out = 64&#39;b0000000000000000000000000000000000000000000000000000001000000000;
				6&#39;b001010: out = 64&#39;b0000000000000000000000000000000000000000000000000000010000000000;
				6&#39;b001011: out = 64&#39;b0000000000000000000000000000000000000000000000000000100000000000;
				6&#39;b001100: out = 64&#39;b0000000000000000000000000000000000000000000000000001000000000000;
				6&#39;b001101: out = 64&#39;b0000000000000000000000000000000000000000000000000010000000000000;
				6&#39;b001110: out = 64&#39;b0000000000000000000000000000000000000000000000000100000000000000;
				6&#39;b001111: out = 64&#39;b0000000000000000000000000000000000000000000000001000000000000000;
				6&#39;b010000: out = 64&#39;b0000000000000000000000000000000000000000000000010000000000000000;
				6&#39;b010001: out = 64&#39;b0000000000000000000000000000000000000000000000100000000000000000;
				6&#39;b010010: out = 64&#39;b0000000000000000000000000000000000000000000001000000000000000000;
				6&#39;b010011: out = 64&#39;b0000000000000000000000000000000000000000000010000000000000000000;
				6&#39;b010100: out = 64&#39;b0000000000000000000000000000000000000000000100000000000000000000;
				6&#39;b010101: out = 64&#39;b0000000000000000000000000000000000000000001000000000000000000000;
				6&#39;b010110: out = 64&#39;b0000000000000000000000000000000000000000010000000000000000000000;
				6&#39;b010111: out = 64&#39;b0000000000000000000000000000000000000000100000000000000000000000;
				6&#39;b011000: out = 64&#39;b0000000000000000000000000000000000000001000000000000000000000000;
				6&#39;b011001: out = 64&#39;b0000000000000000000000000000000000000010000000000000000000000000;
				6&#39;b011010: out = 64&#39;b0000000000000000000000000000000000000100000000000000000000000000;
				6&#39;b011011: out = 64&#39;b0000000000000000000000000000000000001000000000000000000000000000;
				6&#39;b011100: out = 64&#39;b0000000000000000000000000000000000010000000000000000000000000000;
				6&#39;b011101: out = 64&#39;b0000000000000000000000000000000000100000000000000000000000000000;
				6&#39;b011110: out = 64&#39;b0000000000000000000000000000000001000000000000000000000000000000;
				6&#39;b011111: out = 64&#39;b0000000000000000000000000000000010000000000000000000000000000000;
				6&#39;b100000: out = 64&#39;b0000000000000000000000000000000100000000000000000000000000000000;
				6&#39;b100001: out = 64&#39;b0000000000000000000000000000001000000000000000000000000000000000;
				6&#39;b100010: out = 64&#39;b0000000000000000000000000000010000000000000000000000000000000000;
				6&#39;b100011: out = 64&#39;b0000000000000000000000000000100000000000000000000000000000000000;
				6&#39;b100100: out = 64&#39;b0000000000000000000000000001000000000000000000000000000000000000;
				6&#39;b100101: out = 64&#39;b0000000000000000000000000010000000000000000000000000000000000000;
				6&#39;b100110: out = 64&#39;b0000000000000000000000000100000000000000000000000000000000000000;
				6&#39;b100111: out = 64&#39;b0000000000000000000000001000000000000000000000000000000000000000;
				6&#39;b101000: out = 64&#39;b0000000000000000000000010000000000000000000000000000000000000000;
				6&#39;b101001: out = 64&#39;b0000000000000000000000100000000000000000000000000000000000000000;
				6&#39;b101010: out = 64&#39;b0000000000000000000001000000000000000000000000000000000000000000;
				6&#39;b101011: out = 64&#39;b0000000000000000000010000000000000000000000000000000000000000000;
				6&#39;b101100: out = 64&#39;b0000000000000000000100000000000000000000000000000000000000000000;
				6&#39;b101101: out = 64&#39;b0000000000000000001000000000000000000000000000000000000000000000;
				6&#39;b101110: out = 64&#39;b0000000000000000010000000000000000000000000000000000000000000000;
				6&#39;b101111: out = 64&#39;b0000000000000000100000000000000000000000000000000000000000000000;
				6&#39;b110000: out = 64&#39;b0000000000000001000000000000000000000000000000000000000000000000;
				6&#39;b110001: out = 64&#39;b0000000000000010000000000000000000000000000000000000000000000000;
				6&#39;b110010: out = 64&#39;b0000000000000100000000000000000000000000000000000000000000000000;
				6&#39;b110011: out = 64&#39;b0000000000001000000000000000000000000000000000000000000000000000;
				6&#39;b110100: out = 64&#39;b0000000000010000000000000000000000000000000000000000000000000000;
				6&#39;b110101: out = 64&#39;b0000000000100000000000000000000000000000000000000000000000000000;
				6&#39;b110110: out = 64&#39;b0000000001000000000000000000000000000000000000000000000000000000;
				6&#39;b110111: out = 64&#39;b0000000010000000000000000000000000000000000000000000000000000000;
				6&#39;b111000: out = 64&#39;b0000000100000000000000000000000000000000000000000000000000000000;
				6&#39;b111001: out = 64&#39;b0000001000000000000000000000000000000000000000000000000000000000;
				6&#39;b111010: out = 64&#39;b0000010000000000000000000000000000000000000000000000000000000000;
				6&#39;b111011: out = 64&#39;b0000100000000000000000000000000000000000000000000000000000000000;
				6&#39;b111100: out = 64&#39;b0001000000000000000000000000000000000000000000000000000000000000;
				6&#39;b111101: out = 64&#39;b0010000000000000000000000000000000000000000000000000000000000000;
				6&#39;b111110: out = 64&#39;b0100000000000000000000000000000000000000000000000000000000000000;
				6&#39;b111111: out = 64&#39;b1000000000000000000000000000000000000000000000000000000000000000;
			endcase
endmodule
module MUX2 (
	in,
	select,
	out
);
	input [1:0] in;
	input select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
		endcase
endmodule
module MUX4 (
	in,
	select,
	out
);
	input [3:0] in;
	input [1:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
		endcase
endmodule
module MUX8 (
	in,
	select,
	out
);
	input [7:0] in;
	input [2:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
		endcase
endmodule
module MUX16 (
	in,
	select,
	out
);
	input [15:0] in;
	input [3:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
			8: out = in[8];
			9: out = in[9];
			10: out = in[10];
			11: out = in[11];
			12: out = in[12];
			13: out = in[13];
			14: out = in[14];
			15: out = in[15];
		endcase
endmodule
module MUX32 (
	in,
	select,
	out
);
	input [31:0] in;
	input [4:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
			8: out = in[8];
			9: out = in[9];
			10: out = in[10];
			11: out = in[11];
			12: out = in[12];
			13: out = in[13];
			14: out = in[14];
			15: out = in[15];
			16: out = in[16];
			17: out = in[17];
			18: out = in[18];
			19: out = in[19];
			20: out = in[20];
			21: out = in[21];
			22: out = in[22];
			23: out = in[23];
			24: out = in[24];
			25: out = in[25];
			26: out = in[26];
			27: out = in[27];
			28: out = in[28];
			29: out = in[29];
			30: out = in[30];
			31: out = in[31];
		endcase
endmodule
module MUX64 (
	in,
	select,
	out
);
	input [63:0] in;
	input [5:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
			8: out = in[8];
			9: out = in[9];
			10: out = in[10];
			11: out = in[11];
			12: out = in[12];
			13: out = in[13];
			14: out = in[14];
			15: out = in[15];
			16: out = in[16];
			17: out = in[17];
			18: out = in[18];
			19: out = in[19];
			20: out = in[20];
			21: out = in[21];
			22: out = in[22];
			23: out = in[23];
			24: out = in[24];
			25: out = in[25];
			26: out = in[26];
			27: out = in[27];
			28: out = in[28];
			29: out = in[29];
			30: out = in[30];
			31: out = in[31];
			32: out = in[32];
			33: out = in[33];
			34: out = in[34];
			35: out = in[35];
			36: out = in[36];
			37: out = in[37];
			38: out = in[38];
			39: out = in[39];
			40: out = in[40];
			41: out = in[41];
			42: out = in[42];
			43: out = in[43];
			44: out = in[44];
			45: out = in[45];
			46: out = in[46];
			47: out = in[47];
			48: out = in[48];
			49: out = in[49];
			50: out = in[50];
			51: out = in[51];
			52: out = in[52];
			53: out = in[53];
			54: out = in[54];
			55: out = in[55];
			56: out = in[56];
			57: out = in[57];
			58: out = in[58];
			59: out = in[59];
			60: out = in[60];
			61: out = in[61];
			62: out = in[62];
			63: out = in[63];
		endcase
endmodule
module ADD1 (
	in1,
	in2,
	cin,
	out,
	cout
);
	input in1;
	input in2;
	input cin;
	output out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD2 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD4 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD8 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD16 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD32 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD64 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module SUB1 (
	in1,
	in2,
	cin,
	out,
	cout
);
	input in1;
	input in2;
	input cin;
	output out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB2 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB4 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB8 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB16 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB32 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB64 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module MUL1 (
	in1,
	in2,
	out
);
	parameter SIZE = 1;
	input in1;
	input in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL2 (
	in1,
	in2,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL4 (
	in1,
	in2,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL8 (
	in1,
	in2,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL16 (
	in1,
	in2,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL32 (
	in1,
	in2,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL64 (
	in1,
	in2,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module DIV1 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 1;
	input in1;
	input in2;
	output out;
	output rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV2 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV4 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV8 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV16 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV32 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV64 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module FF (
	d,
	clk,
	q
);
	input d;
	input clk;
	output reg q;
	always @(posedge clk) q &lt;= d;
endmodule
module RFF (
	d,
	clk,
	reset,
	q
);
	input d;
	input clk;
	input reset;
	output reg q;
	always @(posedge clk or posedge reset)
		if (reset)
			q &lt;= 0;
		else
			q &lt;= d;
endmodule
module SFF (
	d,
	clk,
	set,
	q
);
	input d;
	input clk;
	input set;
	output reg q;
	always @(posedge clk or posedge set)
		if (set)
			q &lt;= 1;
		else
			q &lt;= d;
endmodule
module RSFF (
	d,
	clk,
	set,
	reset,
	q
);
	input d;
	input clk;
	input set;
	input reset;
	output reg q;
	always @(posedge clk or posedge reset or posedge set)
		if (reset)
			q &lt;= 0;
		else if (set)
			q &lt;= 1;
		else
			q &lt;= d;
endmodule
module SRFF (
	d,
	clk,
	set,
	reset,
	q
);
	input d;
	input clk;
	input set;
	input reset;
	output reg q;
	always @(posedge clk or posedge set or posedge reset)
		if (set)
			q &lt;= 1;
		else if (reset)
			q &lt;= 0;
		else
			q &lt;= d;
endmodule
module LATCH (
	d,
	enable,
	q
);
	input d;
	input enable;
	output reg q;
	always @(d or enable)
		if (enable)
			q &lt;= d;
endmodule
module RLATCH (
	d,
	reset,
	enable,
	q
);
	input d;
	input reset;
	input enable;
	output reg q;
	always @(d or enable or reset)
		if (enable)
			if (reset)
				q &lt;= 0;
			else
				q &lt;= d;
endmodule
module LSHIFT1 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 1;
	input in;
	input shift;
	input val;
	output reg out;
	always @(in or shift or val)
		if (shift)
			out = val;
		else
			out = in;
endmodule
module LSHIFT2 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	input [SIZE - 1:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT4 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	input [2:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT8 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in;
	input [3:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT16 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in;
	input [4:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT32 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in;
	input [5:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT64 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in;
	input [6:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT1 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 1;
	input in;
	input shift;
	input val;
	output reg out;
	always @(in or shift or val)
		if (shift)
			out = val;
		else
			out = in;
endmodule
module RSHIFT2 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	input [SIZE - 1:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT4 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	input [2:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT8 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in;
	input [3:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT16 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in;
	input [4:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT32 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in;
	input [5:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT64 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in;
	input [6:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module CMP1 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 1;
	input in1;
	input in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP2 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP4 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP8 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP16 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP32 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP64 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module VCC (out);
	output supply1 out;
endmodule
module GND (out);
	output supply0 out;
endmodule
module INC1 (
	in,
	out
);
	parameter SIZE = 1;
	input in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC8 (
	in,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC16 (
	in,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC32 (
	in,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC64 (
	in,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule

</pre>
</body>
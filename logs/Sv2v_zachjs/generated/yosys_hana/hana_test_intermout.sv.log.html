<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from yosys
rc: 0 (means success: 1)
tags: yosys
incdirs: /tmpfs/src/github/sv-tests/tests/generated/yosys_hana
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/tools/yosys/tests/hana/test_intermout.v.html" target="file-frame">third_party/tools/yosys/tests/hana/test_intermout.v</a> <a href="../../../../third_party/tools/yosys/tests/hana/hana_vlib.v.html" target="file-frame">third_party/tools/yosys/tests/hana/hana_vlib.v</a>
defines: 
time_elapsed: 1.127s
ram usage: 24348 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/tests/generated/yosys_hana <a href="../../../../third_party/tools/yosys/tests/hana/test_intermout.v.html" target="file-frame">third_party/tools/yosys/tests/hana/test_intermout.v</a> <a href="../../../../third_party/tools/yosys/tests/hana/hana_vlib.v.html" target="file-frame">third_party/tools/yosys/tests/hana/hana_vlib.v</a>
module f1_test (
	a,
	b,
	c,
	d,
	z
);
	input a;
	input b;
	input c;
	input d;
	output z;
	reg temp1;
	reg temp2;
	always @(a or b or c or d) begin
		temp1 = a ^ b;
		temp2 = c ^ d;
		z = temp1 ^ temp2;
	end
endmodule
module f2_test (
	in1,
	in2,
	out
);
	input in1;
	input in2;
	output reg out;
	always @(in1 or in2)
		if (in1 &gt; in2)
			out = in1;
		else
			out = in2;
endmodule
module f3_test (
	a,
	b,
	c
);
	input b;
	input c;
	output reg a;
	always @(b or c) begin
		a = b;
		a = c;
	end
endmodule
module f4_test (
	ctrl,
	in1,
	in2,
	out
);
	input ctrl;
	input in1;
	input in2;
	output reg out;
	always @(ctrl or in1 or in2)
		if (ctrl)
			out = in1 &amp; in2;
		else
			out = in1 | in2;
endmodule
module f5_NonBlockingEx (
	clk,
	merge,
	er,
	xmit,
	fddi,
	claim
);
	input clk;
	input merge;
	input er;
	input xmit;
	input fddi;
	output reg claim;
	reg fcr;
	always @(posedge clk) begin
		fcr = er | xmit;
		if (merge)
			claim = fcr &amp; fddi;
		else
			claim = fddi;
	end
endmodule
module f6_FlipFlop (
	clk,
	cs,
	ns
);
	input clk;
	input [31:0] cs;
	output [31:0] ns;
	integer is;
	always @(posedge clk) is &lt;= cs;
	assign ns = is;
endmodule
module f7_FlipFlop (
	clock,
	cs,
	ns
);
	input clock;
	input [3:0] cs;
	output reg [3:0] ns;
	reg [3:0] temp;
	always @(posedge clock) begin
		temp = cs;
		ns = temp;
	end
endmodule
module f8_inc (
	clock,
	counter
);
	input clock;
	output reg [3:0] counter;
	always @(posedge clock) counter &lt;= counter + 1;
endmodule
module f9_NegEdgeClock (
	q,
	d,
	clk,
	reset
);
	input d;
	input clk;
	input reset;
	output reg q;
	always @(negedge clk or negedge reset)
		if (!reset)
			q &lt;= 1&#39;b0;
		else
			q &lt;= d;
endmodule
module f10_MyCounter (
	clock,
	preset,
	updown,
	presetdata,
	counter
);
	input clock;
	input preset;
	input updown;
	input [1:0] presetdata;
	output reg [1:0] counter;
	always @(posedge clock)
		if (preset)
			counter &lt;= presetdata;
		else if (updown)
			counter &lt;= counter + 1;
		else
			counter &lt;= counter - 1;
endmodule
module f11_test (
	en,
	in,
	out
);
	input en;
	input [1:0] in;
	output reg [2:0] out;
	always @(en or in)
		if (en)
			out = in + 1;
endmodule
module f12_test (
	in,
	out
);
	input in;
	output out;
	assign out = in;
endmodule
module f13_test (
	in,
	out
);
	input in;
	output out;
	wire w1;
	wire w2;
	assign w1 = in;
	assign w2 = w1;
	assign out = w2;
endmodule
module f14_test (
	in,
	out
);
	input in;
	output out;
	wire w1;
	wire w2;
	wire w3;
	wire w4;
	assign w1 = in;
	assign w2 = w1;
	assign w4 = w3;
	assign out = w4;
	f14_mybuf _f14_mybuf(
		w2,
		w3
	);
endmodule
module f14_mybuf (
	in,
	out
);
	input in;
	output out;
	wire w1;
	wire w2;
	wire w3;
	wire w4;
	assign w1 = in;
	assign w2 = w1;
	assign out = w2;
endmodule
module f15_test (
	in1,
	in2,
	out
);
	input in1;
	input in2;
	output out;
	wire w1;
	wire w2;
	wire w3;
	wire w4;
	wire w5;
	wire w6;
	wire w7;
	wire w8;
	wire w9;
	wire w10;
	assign w1 = in1;
	assign w2 = w1;
	assign w5 = in2;
	assign w6 = w5;
	assign w10 = w9;
	assign out = w10;
	f15_mybuf _f15_mybuf0(
		w2,
		w3
	);
	f15_mybuf _f15_mybuf1(
		w3,
		w4
	);
	f15_mybuf _f15_mybuf2(
		w6,
		w7
	);
	f15_mybuf _f15_mybuf3(
		w7,
		w4
	);
	f15_mybuf _f15_mybuf4(
		w4,
		w8
	);
	f15_mybuf _f15_mybuf5(
		w8,
		w9
	);
endmodule
module f15_mybuf (
	in,
	out
);
	input in;
	output out;
	wire w1;
	wire w2;
	wire w3;
	wire w4;
	assign w1 = in;
	assign w2 = w1;
	assign out = w2;
endmodule
module f16_test (
	out,
	in1,
	in2,
	vin1,
	vin2,
	vout1
);
	output out;
	input in1;
	input in2;
	input [1:0] vin1;
	input [2:0] vin2;
	output [3:0] vout1;
	assign out = in1 + in2;
	assign vout1 = vin1 + vin2;
endmodule
module f17_test (
	in1,
	in2,
	vin1,
	vin2,
	out,
	vout,
	vin3,
	vin4,
	vout1
);
	input in1;
	input in2;
	input [1:0] vin1;
	input [3:0] vin2;
	input [1:0] vin3;
	input [3:0] vin4;
	output vout;
	output vout1;
	output out;
	assign out = in1 &amp;&amp; in2;
	assign vout = vin1 &amp;&amp; vin2;
	assign vout1 = vin3 || vin4;
endmodule
module f18_test (
	out,
	in,
	vout,
	vin
);
	output out;
	input in;
	output [1:0] vout;
	input [1:0] vin;
	assign out = ~in;
	assign vout = ~vin;
endmodule
module f19_buffer (
	in,
	out,
	vin,
	vout
);
	input in;
	output out;
	input [1:0] vin;
	output [1:0] vout;
	assign out = in;
	assign vout = vin;
endmodule
module f20_test (
	in1,
	in2,
	out,
	vin1,
	vin2,
	vin3,
	vin4,
	vout1,
	vout2,
	en1,
	ven1,
	ven2
);
	input in1;
	input in2;
	input en1;
	input ven1;
	input [1:0] ven2;
	output out;
	input [1:0] vin1;
	input [1:0] vin2;
	input [1:0] vin3;
	input [1:0] vin4;
	output [1:0] vout1;
	output [1:0] vout2;
	assign out = (en1 ? in1 : in2);
	assign vout1 = (ven1 ? vin1 : vin2);
	assign vout2 = (ven2 ? vin3 : vin4);
endmodule
module f21_test (
	in,
	out,
	en,
	vin1,
	vout1,
	en1
);
	input in;
	input en;
	input en1;
	output out;
	input [1:0] vin1;
	output [1:0] vout1;
	assign out = (en ? in : 1&#39;bz);
	assign vout1 = (en1 ? vin1 : 2&#39;bzz);
endmodule
module f22_test (
	in,
	out,
	vin,
	vout,
	vin1,
	vout1,
	vin2,
	vout2
);
	input in;
	input [3:0] vin;
	input [3:0] vin1;
	input [3:0] vin2;
	output [3:0] vout;
	output [3:0] vout1;
	output [3:0] vout2;
	output out;
	assign out = in &lt;&lt; 1;
	assign vout = vin &lt;&lt; 2;
	assign vout1 = vin1 &gt;&gt; 2;
	assign vout2 = vin2 &gt;&gt;&gt; 2;
endmodule
module f23_test (
	out,
	vout
);
	output out;
	output [7:0] vout;
	assign out = 1&#39;b1;
	assign vout = 9;
endmodule
module f24_test (
	out,
	in1,
	in2,
	vin1,
	vin2,
	vout1
);
	output out;
	input in1;
	input in2;
	input [1:0] vin1;
	input [2:0] vin2;
	output [3:0] vout1;
	assign out = in1 / in2;
	assign vout1 = vin1 / vin2;
endmodule
module f25_test (
	out,
	vout,
	in,
	vin
);
	output out;
	output vout;
	input in;
	input [3:0] vin;
	assign out = !in;
	assign vout = !vin;
endmodule
module f26_test (
	out,
	in1,
	in2,
	vin1,
	vin2,
	vout1
);
	output out;
	input in1;
	input in2;
	input [1:0] vin1;
	input [2:0] vin2;
	output [3:0] vout1;
	assign out = in1 % in2;
	assign vout1 = vin1 % vin2;
endmodule
module f27_test (
	out,
	in1,
	in2,
	vin1,
	vin2,
	vout1
);
	output out;
	input in1;
	input in2;
	input [1:0] vin1;
	input [2:0] vin2;
	output [3:0] vout1;
	assign out = in1 * in2;
	assign vout1 = vin1 * vin2;
endmodule
module f28_test (
	out,
	vin,
	out1,
	vin1
);
	output out;
	input [1:0] vin;
	output out1;
	input [3:0] vin1;
	assign out = &amp;vin;
	assign out1 = &amp;vin1;
endmodule
module f29_Reduction (
	A1,
	A2,
	A3,
	A4,
	A5,
	A6,
	Y1,
	Y2,
	Y3,
	Y4,
	Y5,
	Y6
);
	input [1:0] A1;
	input [1:0] A2;
	input [1:0] A3;
	input [1:0] A4;
	input [1:0] A5;
	input [1:0] A6;
	output Y1;
	output Y2;
	output Y3;
	output Y4;
	output Y5;
	output Y6;
	assign Y1 = &amp;A1;
	assign Y2 = |A2;
	assign Y3 = ~&amp;A3;
	assign Y4 = ~|A4;
	assign Y5 = ^A5;
	assign Y6 = ~^A6;
endmodule
module f30_test (
	out,
	in1,
	in2,
	vin1,
	vin2,
	vout1
);
	output out;
	input in1;
	input in2;
	input [1:0] vin1;
	input [2:0] vin2;
	output [3:0] vout1;
	assign out = in1 - in2;
	assign vout1 = vin1 - vin2;
endmodule
module f31_test (
	out,
	in,
	vout,
	vin
);
	output out;
	input in;
	output [31:0] vout;
	input [31:0] vin;
	assign out = -in;
	assign vout = -vin;
endmodule
module f32_test (
	out,
	in
);
	output out;
	input in;
	assign out = +in;
endmodule
module f33_test (
	vin0,
	vout0
);
	input [2:0] vin0;
	output reg [7:0] vout0;
	wire [7:0] myreg0;
	wire [7:0] myreg1;
	wire [7:0] myreg2;
	integer i;
	assign myreg0 = vout0 &lt;&lt; vin0;
	assign myreg1 = myreg2 &gt;&gt; i;
endmodule
module BUF (
	in,
	out
);
	input in;
	output out;
	assign out = in;
endmodule
module TRIBUF (
	in,
	enable,
	out
);
	input in;
	input enable;
	output out;
	assign out = (enable ? in : 1&#39;bz);
endmodule
module INV (
	in,
	out
);
	input in;
	output out;
	assign out = ~in;
endmodule
module AND2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = &amp;in;
endmodule
module AND3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = &amp;in;
endmodule
module AND4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = &amp;in;
endmodule
module OR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = |in;
endmodule
module OR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = |in;
endmodule
module OR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = |in;
endmodule
module NAND2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~&amp;in;
endmodule
module NAND3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~&amp;in;
endmodule
module NAND4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~&amp;in;
endmodule
module NOR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~|in;
endmodule
module NOR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~|in;
endmodule
module NOR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~|in;
endmodule
module XOR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ^in;
endmodule
module XOR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ^in;
endmodule
module XOR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ^in;
endmodule
module XNOR2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~^in;
endmodule
module XNOR3 (
	in,
	out
);
	parameter SIZE = 3;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~^in;
endmodule
module XNOR4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output out;
	assign out = ~^in;
endmodule
module DEC1 (
	in,
	enable,
	out
);
	input in;
	input enable;
	output reg [1:0] out;
	always @(in or enable)
		if (!enable)
			out = 2&#39;b00;
		else
			case (in)
				1&#39;b0: out = 2&#39;b01;
				1&#39;b1: out = 2&#39;b10;
			endcase
endmodule
module DEC2 (
	in,
	enable,
	out
);
	input [1:0] in;
	input enable;
	output reg [3:0] out;
	always @(in or enable)
		if (!enable)
			out = 4&#39;b0000;
		else
			case (in)
				2&#39;b00: out = 4&#39;b0001;
				2&#39;b01: out = 4&#39;b0010;
				2&#39;b10: out = 4&#39;b0100;
				2&#39;b11: out = 4&#39;b1000;
			endcase
endmodule
module DEC3 (
	in,
	enable,
	out
);
	input [2:0] in;
	input enable;
	output reg [7:0] out;
	always @(in or enable)
		if (!enable)
			out = 8&#39;b00000000;
		else
			case (in)
				3&#39;b000: out = 8&#39;b00000001;
				3&#39;b001: out = 8&#39;b00000010;
				3&#39;b010: out = 8&#39;b00000100;
				3&#39;b011: out = 8&#39;b00001000;
				3&#39;b100: out = 8&#39;b00010000;
				3&#39;b101: out = 8&#39;b00100000;
				3&#39;b110: out = 8&#39;b01000000;
				3&#39;b111: out = 8&#39;b10000000;
			endcase
endmodule
module DEC4 (
	in,
	enable,
	out
);
	input [3:0] in;
	input enable;
	output reg [15:0] out;
	always @(in or enable)
		if (!enable)
			out = 16&#39;b0000000000000000;
		else
			case (in)
				4&#39;b0000: out = 16&#39;b0000000000000001;
				4&#39;b0001: out = 16&#39;b0000000000000010;
				4&#39;b0010: out = 16&#39;b0000000000000100;
				4&#39;b0011: out = 16&#39;b0000000000001000;
				4&#39;b0100: out = 16&#39;b0000000000010000;
				4&#39;b0101: out = 16&#39;b0000000000100000;
				4&#39;b0110: out = 16&#39;b0000000001000000;
				4&#39;b0111: out = 16&#39;b0000000010000000;
				4&#39;b1000: out = 16&#39;b0000000100000000;
				4&#39;b1001: out = 16&#39;b0000001000000000;
				4&#39;b1010: out = 16&#39;b0000010000000000;
				4&#39;b1011: out = 16&#39;b0000100000000000;
				4&#39;b1100: out = 16&#39;b0001000000000000;
				4&#39;b1101: out = 16&#39;b0010000000000000;
				4&#39;b1110: out = 16&#39;b0100000000000000;
				4&#39;b1111: out = 16&#39;b1000000000000000;
			endcase
endmodule
module DEC5 (
	in,
	enable,
	out
);
	input [4:0] in;
	input enable;
	output reg [31:0] out;
	always @(in or enable)
		if (!enable)
			out = 32&#39;b00000000000000000000000000000000;
		else
			case (in)
				5&#39;b00000: out = 32&#39;b00000000000000000000000000000001;
				5&#39;b00001: out = 32&#39;b00000000000000000000000000000010;
				5&#39;b00010: out = 32&#39;b00000000000000000000000000000100;
				5&#39;b00011: out = 32&#39;b00000000000000000000000000001000;
				5&#39;b00100: out = 32&#39;b00000000000000000000000000010000;
				5&#39;b00101: out = 32&#39;b00000000000000000000000000100000;
				5&#39;b00110: out = 32&#39;b00000000000000000000000001000000;
				5&#39;b00111: out = 32&#39;b00000000000000000000000010000000;
				5&#39;b01000: out = 32&#39;b00000000000000000000000100000000;
				5&#39;b01001: out = 32&#39;b00000000000000000000001000000000;
				5&#39;b01010: out = 32&#39;b00000000000000000000010000000000;
				5&#39;b01011: out = 32&#39;b00000000000000000000100000000000;
				5&#39;b01100: out = 32&#39;b00000000000000000001000000000000;
				5&#39;b01101: out = 32&#39;b00000000000000000010000000000000;
				5&#39;b01110: out = 32&#39;b00000000000000000100000000000000;
				5&#39;b01111: out = 32&#39;b00000000000000001000000000000000;
				5&#39;b10000: out = 32&#39;b00000000000000010000000000000000;
				5&#39;b10001: out = 32&#39;b00000000000000100000000000000000;
				5&#39;b10010: out = 32&#39;b00000000000001000000000000000000;
				5&#39;b10011: out = 32&#39;b00000000000010000000000000000000;
				5&#39;b10100: out = 32&#39;b00000000000100000000000000000000;
				5&#39;b10101: out = 32&#39;b00000000001000000000000000000000;
				5&#39;b10110: out = 32&#39;b00000000010000000000000000000000;
				5&#39;b10111: out = 32&#39;b00000000100000000000000000000000;
				5&#39;b11000: out = 32&#39;b00000001000000000000000000000000;
				5&#39;b11001: out = 32&#39;b00000010000000000000000000000000;
				5&#39;b11010: out = 32&#39;b00000100000000000000000000000000;
				5&#39;b11011: out = 32&#39;b00001000000000000000000000000000;
				5&#39;b11100: out = 32&#39;b00010000000000000000000000000000;
				5&#39;b11101: out = 32&#39;b00100000000000000000000000000000;
				5&#39;b11110: out = 32&#39;b01000000000000000000000000000000;
				5&#39;b11111: out = 32&#39;b10000000000000000000000000000000;
			endcase
endmodule
module DEC6 (
	in,
	enable,
	out
);
	input [5:0] in;
	input enable;
	output reg [63:0] out;
	always @(in or enable)
		if (!enable)
			out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000000;
		else
			case (in)
				6&#39;b000000: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000001;
				6&#39;b000001: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000010;
				6&#39;b000010: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000000100;
				6&#39;b000011: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000001000;
				6&#39;b000100: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000010000;
				6&#39;b000101: out = 64&#39;b0000000000000000000000000000000000000000000000000000000000100000;
				6&#39;b000110: out = 64&#39;b0000000000000000000000000000000000000000000000000000000001000000;
				6&#39;b000111: out = 64&#39;b0000000000000000000000000000000000000000000000000000000010000000;
				6&#39;b001000: out = 64&#39;b0000000000000000000000000000000000000000000000000000000100000000;
				6&#39;b001001: out = 64&#39;b0000000000000000000000000000000000000000000000000000001000000000;
				6&#39;b001010: out = 64&#39;b0000000000000000000000000000000000000000000000000000010000000000;
				6&#39;b001011: out = 64&#39;b0000000000000000000000000000000000000000000000000000100000000000;
				6&#39;b001100: out = 64&#39;b0000000000000000000000000000000000000000000000000001000000000000;
				6&#39;b001101: out = 64&#39;b0000000000000000000000000000000000000000000000000010000000000000;
				6&#39;b001110: out = 64&#39;b0000000000000000000000000000000000000000000000000100000000000000;
				6&#39;b001111: out = 64&#39;b0000000000000000000000000000000000000000000000001000000000000000;
				6&#39;b010000: out = 64&#39;b0000000000000000000000000000000000000000000000010000000000000000;
				6&#39;b010001: out = 64&#39;b0000000000000000000000000000000000000000000000100000000000000000;
				6&#39;b010010: out = 64&#39;b0000000000000000000000000000000000000000000001000000000000000000;
				6&#39;b010011: out = 64&#39;b0000000000000000000000000000000000000000000010000000000000000000;
				6&#39;b010100: out = 64&#39;b0000000000000000000000000000000000000000000100000000000000000000;
				6&#39;b010101: out = 64&#39;b0000000000000000000000000000000000000000001000000000000000000000;
				6&#39;b010110: out = 64&#39;b0000000000000000000000000000000000000000010000000000000000000000;
				6&#39;b010111: out = 64&#39;b0000000000000000000000000000000000000000100000000000000000000000;
				6&#39;b011000: out = 64&#39;b0000000000000000000000000000000000000001000000000000000000000000;
				6&#39;b011001: out = 64&#39;b0000000000000000000000000000000000000010000000000000000000000000;
				6&#39;b011010: out = 64&#39;b0000000000000000000000000000000000000100000000000000000000000000;
				6&#39;b011011: out = 64&#39;b0000000000000000000000000000000000001000000000000000000000000000;
				6&#39;b011100: out = 64&#39;b0000000000000000000000000000000000010000000000000000000000000000;
				6&#39;b011101: out = 64&#39;b0000000000000000000000000000000000100000000000000000000000000000;
				6&#39;b011110: out = 64&#39;b0000000000000000000000000000000001000000000000000000000000000000;
				6&#39;b011111: out = 64&#39;b0000000000000000000000000000000010000000000000000000000000000000;
				6&#39;b100000: out = 64&#39;b0000000000000000000000000000000100000000000000000000000000000000;
				6&#39;b100001: out = 64&#39;b0000000000000000000000000000001000000000000000000000000000000000;
				6&#39;b100010: out = 64&#39;b0000000000000000000000000000010000000000000000000000000000000000;
				6&#39;b100011: out = 64&#39;b0000000000000000000000000000100000000000000000000000000000000000;
				6&#39;b100100: out = 64&#39;b0000000000000000000000000001000000000000000000000000000000000000;
				6&#39;b100101: out = 64&#39;b0000000000000000000000000010000000000000000000000000000000000000;
				6&#39;b100110: out = 64&#39;b0000000000000000000000000100000000000000000000000000000000000000;
				6&#39;b100111: out = 64&#39;b0000000000000000000000001000000000000000000000000000000000000000;
				6&#39;b101000: out = 64&#39;b0000000000000000000000010000000000000000000000000000000000000000;
				6&#39;b101001: out = 64&#39;b0000000000000000000000100000000000000000000000000000000000000000;
				6&#39;b101010: out = 64&#39;b0000000000000000000001000000000000000000000000000000000000000000;
				6&#39;b101011: out = 64&#39;b0000000000000000000010000000000000000000000000000000000000000000;
				6&#39;b101100: out = 64&#39;b0000000000000000000100000000000000000000000000000000000000000000;
				6&#39;b101101: out = 64&#39;b0000000000000000001000000000000000000000000000000000000000000000;
				6&#39;b101110: out = 64&#39;b0000000000000000010000000000000000000000000000000000000000000000;
				6&#39;b101111: out = 64&#39;b0000000000000000100000000000000000000000000000000000000000000000;
				6&#39;b110000: out = 64&#39;b0000000000000001000000000000000000000000000000000000000000000000;
				6&#39;b110001: out = 64&#39;b0000000000000010000000000000000000000000000000000000000000000000;
				6&#39;b110010: out = 64&#39;b0000000000000100000000000000000000000000000000000000000000000000;
				6&#39;b110011: out = 64&#39;b0000000000001000000000000000000000000000000000000000000000000000;
				6&#39;b110100: out = 64&#39;b0000000000010000000000000000000000000000000000000000000000000000;
				6&#39;b110101: out = 64&#39;b0000000000100000000000000000000000000000000000000000000000000000;
				6&#39;b110110: out = 64&#39;b0000000001000000000000000000000000000000000000000000000000000000;
				6&#39;b110111: out = 64&#39;b0000000010000000000000000000000000000000000000000000000000000000;
				6&#39;b111000: out = 64&#39;b0000000100000000000000000000000000000000000000000000000000000000;
				6&#39;b111001: out = 64&#39;b0000001000000000000000000000000000000000000000000000000000000000;
				6&#39;b111010: out = 64&#39;b0000010000000000000000000000000000000000000000000000000000000000;
				6&#39;b111011: out = 64&#39;b0000100000000000000000000000000000000000000000000000000000000000;
				6&#39;b111100: out = 64&#39;b0001000000000000000000000000000000000000000000000000000000000000;
				6&#39;b111101: out = 64&#39;b0010000000000000000000000000000000000000000000000000000000000000;
				6&#39;b111110: out = 64&#39;b0100000000000000000000000000000000000000000000000000000000000000;
				6&#39;b111111: out = 64&#39;b1000000000000000000000000000000000000000000000000000000000000000;
			endcase
endmodule
module MUX2 (
	in,
	select,
	out
);
	input [1:0] in;
	input select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
		endcase
endmodule
module MUX4 (
	in,
	select,
	out
);
	input [3:0] in;
	input [1:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
		endcase
endmodule
module MUX8 (
	in,
	select,
	out
);
	input [7:0] in;
	input [2:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
		endcase
endmodule
module MUX16 (
	in,
	select,
	out
);
	input [15:0] in;
	input [3:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
			8: out = in[8];
			9: out = in[9];
			10: out = in[10];
			11: out = in[11];
			12: out = in[12];
			13: out = in[13];
			14: out = in[14];
			15: out = in[15];
		endcase
endmodule
module MUX32 (
	in,
	select,
	out
);
	input [31:0] in;
	input [4:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
			8: out = in[8];
			9: out = in[9];
			10: out = in[10];
			11: out = in[11];
			12: out = in[12];
			13: out = in[13];
			14: out = in[14];
			15: out = in[15];
			16: out = in[16];
			17: out = in[17];
			18: out = in[18];
			19: out = in[19];
			20: out = in[20];
			21: out = in[21];
			22: out = in[22];
			23: out = in[23];
			24: out = in[24];
			25: out = in[25];
			26: out = in[26];
			27: out = in[27];
			28: out = in[28];
			29: out = in[29];
			30: out = in[30];
			31: out = in[31];
		endcase
endmodule
module MUX64 (
	in,
	select,
	out
);
	input [63:0] in;
	input [5:0] select;
	output reg out;
	always @(in or select)
		case (select)
			0: out = in[0];
			1: out = in[1];
			2: out = in[2];
			3: out = in[3];
			4: out = in[4];
			5: out = in[5];
			6: out = in[6];
			7: out = in[7];
			8: out = in[8];
			9: out = in[9];
			10: out = in[10];
			11: out = in[11];
			12: out = in[12];
			13: out = in[13];
			14: out = in[14];
			15: out = in[15];
			16: out = in[16];
			17: out = in[17];
			18: out = in[18];
			19: out = in[19];
			20: out = in[20];
			21: out = in[21];
			22: out = in[22];
			23: out = in[23];
			24: out = in[24];
			25: out = in[25];
			26: out = in[26];
			27: out = in[27];
			28: out = in[28];
			29: out = in[29];
			30: out = in[30];
			31: out = in[31];
			32: out = in[32];
			33: out = in[33];
			34: out = in[34];
			35: out = in[35];
			36: out = in[36];
			37: out = in[37];
			38: out = in[38];
			39: out = in[39];
			40: out = in[40];
			41: out = in[41];
			42: out = in[42];
			43: out = in[43];
			44: out = in[44];
			45: out = in[45];
			46: out = in[46];
			47: out = in[47];
			48: out = in[48];
			49: out = in[49];
			50: out = in[50];
			51: out = in[51];
			52: out = in[52];
			53: out = in[53];
			54: out = in[54];
			55: out = in[55];
			56: out = in[56];
			57: out = in[57];
			58: out = in[58];
			59: out = in[59];
			60: out = in[60];
			61: out = in[61];
			62: out = in[62];
			63: out = in[63];
		endcase
endmodule
module ADD1 (
	in1,
	in2,
	cin,
	out,
	cout
);
	input in1;
	input in2;
	input cin;
	output out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD2 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD4 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD8 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD16 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD32 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module ADD64 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 + in2) + cin;
endmodule
module SUB1 (
	in1,
	in2,
	cin,
	out,
	cout
);
	input in1;
	input in2;
	input cin;
	output out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB2 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB4 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB8 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB16 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB32 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module SUB64 (
	in1,
	in2,
	cin,
	out,
	cout
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	input cin;
	output [SIZE - 1:0] out;
	output cout;
	assign {cout, out} = (in1 - in2) - cin;
endmodule
module MUL1 (
	in1,
	in2,
	out
);
	parameter SIZE = 1;
	input in1;
	input in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL2 (
	in1,
	in2,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL4 (
	in1,
	in2,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL8 (
	in1,
	in2,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL16 (
	in1,
	in2,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL32 (
	in1,
	in2,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module MUL64 (
	in1,
	in2,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [(2 * SIZE) - 1:0] out;
	assign out = in1 * in2;
endmodule
module DIV1 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 1;
	input in1;
	input in2;
	output out;
	output rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV2 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV4 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV8 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV16 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV32 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module DIV64 (
	in1,
	in2,
	out,
	rem
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output [SIZE - 1:0] out;
	output [SIZE - 1:0] rem;
	assign out = in1 / in2;
	assign rem = in1 % in2;
endmodule
module FF (
	d,
	clk,
	q
);
	input d;
	input clk;
	output reg q;
	always @(posedge clk) q &lt;= d;
endmodule
module RFF (
	d,
	clk,
	reset,
	q
);
	input d;
	input clk;
	input reset;
	output reg q;
	always @(posedge clk or posedge reset)
		if (reset)
			q &lt;= 0;
		else
			q &lt;= d;
endmodule
module SFF (
	d,
	clk,
	set,
	q
);
	input d;
	input clk;
	input set;
	output reg q;
	always @(posedge clk or posedge set)
		if (set)
			q &lt;= 1;
		else
			q &lt;= d;
endmodule
module RSFF (
	d,
	clk,
	set,
	reset,
	q
);
	input d;
	input clk;
	input set;
	input reset;
	output reg q;
	always @(posedge clk or posedge reset or posedge set)
		if (reset)
			q &lt;= 0;
		else if (set)
			q &lt;= 1;
		else
			q &lt;= d;
endmodule
module SRFF (
	d,
	clk,
	set,
	reset,
	q
);
	input d;
	input clk;
	input set;
	input reset;
	output reg q;
	always @(posedge clk or posedge set or posedge reset)
		if (set)
			q &lt;= 1;
		else if (reset)
			q &lt;= 0;
		else
			q &lt;= d;
endmodule
module LATCH (
	d,
	enable,
	q
);
	input d;
	input enable;
	output reg q;
	always @(d or enable)
		if (enable)
			q &lt;= d;
endmodule
module RLATCH (
	d,
	reset,
	enable,
	q
);
	input d;
	input reset;
	input enable;
	output reg q;
	always @(d or enable or reset)
		if (enable)
			if (reset)
				q &lt;= 0;
			else
				q &lt;= d;
endmodule
module LSHIFT1 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 1;
	input in;
	input shift;
	input val;
	output reg out;
	always @(in or shift or val)
		if (shift)
			out = val;
		else
			out = in;
endmodule
module LSHIFT2 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	input [SIZE - 1:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT4 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	input [2:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT8 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in;
	input [3:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT16 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in;
	input [4:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT32 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in;
	input [5:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module LSHIFT64 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in;
	input [6:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &lt;&lt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &gt;&gt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT1 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 1;
	input in;
	input shift;
	input val;
	output reg out;
	always @(in or shift or val)
		if (shift)
			out = val;
		else
			out = in;
endmodule
module RSHIFT2 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	input [SIZE - 1:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT4 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	input [2:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT8 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in;
	input [3:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT16 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in;
	input [4:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT32 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in;
	input [5:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module RSHIFT64 (
	in,
	shift,
	val,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in;
	input [6:0] shift;
	input val;
	output reg [SIZE - 1:0] out;
	always @(in or shift or val) begin
		out = in &gt;&gt; shift;
		if (val)
			out = out | ({SIZE - 1 {1&#39;b1}} &lt;&lt; ((SIZE - 1) - shift));
	end
endmodule
module CMP1 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 1;
	input in1;
	input in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP2 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP4 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP8 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP16 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP32 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module CMP64 (
	in1,
	in2,
	equal,
	unequal,
	greater,
	lesser
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in1;
	input [SIZE - 1:0] in2;
	output reg equal;
	output reg unequal;
	output reg greater;
	output reg lesser;
	always @(in1 or in2)
		if (in1 == in2) begin
			equal = 1;
			unequal = 0;
			greater = 0;
			lesser = 0;
		end
		else begin
			equal = 0;
			unequal = 1;
			if (in1 &lt; in2) begin
				greater = 0;
				lesser = 1;
			end
			else begin
				greater = 1;
				lesser = 0;
			end
		end
endmodule
module VCC (out);
	output supply1 out;
endmodule
module GND (out);
	output supply0 out;
endmodule
module INC1 (
	in,
	out
);
	parameter SIZE = 1;
	input in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC2 (
	in,
	out
);
	parameter SIZE = 2;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC4 (
	in,
	out
);
	parameter SIZE = 4;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC8 (
	in,
	out
);
	parameter SIZE = 8;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC16 (
	in,
	out
);
	parameter SIZE = 16;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC32 (
	in,
	out
);
	parameter SIZE = 32;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule
module INC64 (
	in,
	out
);
	parameter SIZE = 64;
	input [SIZE - 1:0] in;
	output [SIZE:0] out;
	assign out = in + 1;
endmodule

</pre>
</body>
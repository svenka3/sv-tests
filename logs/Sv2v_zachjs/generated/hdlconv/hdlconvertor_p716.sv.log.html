<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from hdlconv
rc: 0 (means success: 1)
tags: hdlconv
incdirs: /tmpfs/src/github/sv-tests/third_party/tests/hdlconvertor/tests/sv_test/std2017
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/tests/hdlconvertor/tests/sv_test/std2017/p716.sv.html" target="file-frame">third_party/tests/hdlconvertor/tests/sv_test/std2017/p716.sv</a>
defines: 
time_elapsed: 0.125s
ram usage: 9940 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/tests/hdlconvertor/tests/sv_test/std2017 <a href="../../../../third_party/tests/hdlconvertor/tests/sv_test/std2017/p716.sv.html" target="file-frame">third_party/tests/hdlconvertor/tests/sv_test/std2017/p716.sv</a>
module child (
	o,
	i
);
	output o;
	input [0:4] i;
endmodule
module parent (
	o,
	i
);
	output [31:0] o;
	input [159:0] i;
	child c[31:0](
		o,
		i
	);
endmodule
module MxN_pipeline (
	in,
	out,
	clk
);
	parameter M = 3;
	parameter N = 4;
	input [M - 1:0] in;
	output [M - 1:0] out;
	input clk;
	wire [(1 &gt;= N ? (M * (2 - N)) + (N - 1) : M * N):(1 &gt;= N ? N : 1)] Ins;
	wire [(1 &gt;= N ? (M * (2 - N)) + (N - 1) : M * N):(1 &gt;= N ? N : 1)] Outs;
	DFF dff[(1 &gt;= N ? (M * (2 - N)) + (N - 1) : M * N):(1 &gt;= N ? N : 1)](
		Outs,
		Ins,
		clk
	);
	generate
		genvar I;
		for (I = M - 1; I &gt;= 0; I = I - 1) begin
			genvar J;
			for (J = 1; J &lt;= N; J = J + 1) case (J)
				1: begin
					assign out[I] = Outs[(I * (1 &gt;= N ? 2 - N : N)) + (1 &gt;= N ? 1 : N)];
					assign Ins[(I * (1 &gt;= N ? 2 - N : N)) + (1 &gt;= N ? J : N - (J - 1))] = Outs[(I * (1 &gt;= N ? 2 - N : N)) + (1 &gt;= N ? 2 : N - 1)];
				end
				default: assign Ins[(I * (1 &gt;= N ? 2 - N : N)) + (1 &gt;= N ? J : N - (J - 1))] = Outs[(I * (1 &gt;= N ? 2 - N : N)) + (1 &gt;= N ? J + 1 : N - J)];
				N: assign Ins[(I * (1 &gt;= N ? 2 - N : N)) + (1 &gt;= N ? N : N - (N - 1))] = in[I];
			endcase
		end
	endgenerate
endmodule

</pre>
</body>
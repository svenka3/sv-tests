<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from hdlconv
rc: 0 (means success: 1)
tags: hdlconv
incdirs: /tmpfs/src/github/sv-tests/third_party/tests/hdlconvertor/tests/verilog
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/tests/hdlconvertor/tests/verilog/fifo_rx.v.html" target="file-frame">third_party/tests/hdlconvertor/tests/verilog/fifo_rx.v</a>
defines: 
time_elapsed: 0.327s
ram usage: 11472 KB
</pre>
<pre class="log">

zachjs-sv2v -I/tmpfs/src/github/sv-tests/third_party/tests/hdlconvertor/tests/verilog <a href="../../../../third_party/tests/hdlconvertor/tests/verilog/fifo_rx.v.html" target="file-frame">third_party/tests/hdlconvertor/tests/verilog/fifo_rx.v</a>
module fifo_rx (
	clock,
	reset,
	wr_en,
	rd_en,
	data_in,
	f_full,
	f_empty,
	open_slot_fct,
	overflow_credit_error,
	data_out,
	counter
);
	parameter integer DWIDTH = 9;
	parameter integer AWIDTH = 6;
	input clock;
	input reset;
	input wr_en;
	input rd_en;
	input [DWIDTH - 1:0] data_in;
	output reg f_full;
	output reg f_empty;
	output reg open_slot_fct;
	output reg overflow_credit_error;
	output [DWIDTH - 1:0] data_out;
	output reg [AWIDTH - 1:0] counter;
	reg [AWIDTH - 1:0] wr_ptr;
	reg [AWIDTH - 1:0] rd_ptr;
	reg [AWIDTH - 1:0] credit_counter;
	reg [1:0] state_data_write;
	reg [1:0] next_state_data_write;
	reg [1:0] state_data_read;
	reg [1:0] next_state_data_read;
	reg [1:0] state_open_slot;
	reg [1:0] next_state_open_slot;
	reg [10:0] counter_wait;
	always @(*) begin
		next_state_open_slot = state_open_slot;
		case (state_open_slot)
			2&#39;d0:
				if ((((((((rd_ptr == 6&#39;d7) || (rd_ptr == 6&#39;d15)) || (rd_ptr == 6&#39;d23)) || (rd_ptr == 6&#39;d31)) || (rd_ptr == 6&#39;d39)) || (rd_ptr == 6&#39;d47)) || (rd_ptr == 6&#39;d55)) || (rd_ptr == 6&#39;d63))
					next_state_open_slot = 2&#39;d1;
				else
					next_state_open_slot = 2&#39;d0;
			2&#39;d1:
				if (counter_wait != 11&#39;d300)
					next_state_open_slot = 2&#39;d1;
				else
					next_state_open_slot = 2&#39;d2;
			2&#39;d2:
				if ((((((((rd_ptr == 6&#39;d7) || (rd_ptr == 6&#39;d15)) || (rd_ptr == 6&#39;d23)) || (rd_ptr == 6&#39;d31)) || (rd_ptr == 6&#39;d39)) || (rd_ptr == 6&#39;d47)) || (rd_ptr == 6&#39;d55)) || (rd_ptr == 6&#39;d63))
					next_state_open_slot = 2&#39;d2;
				else
					next_state_open_slot = 2&#39;d0;
			default: next_state_open_slot = 2&#39;d0;
		endcase
	end
	always @(*) begin
		next_state_data_write = state_data_write;
		case (state_data_write)
			2&#39;d0:
				if (wr_en &amp;&amp; !f_full)
					next_state_data_write = 2&#39;d1;
				else
					next_state_data_write = 2&#39;d0;
			2&#39;d1:
				if (wr_en)
					next_state_data_write = 2&#39;d1;
				else
					next_state_data_write = 2&#39;d2;
			2&#39;d2: next_state_data_write = 2&#39;d0;
			default: next_state_data_write = 2&#39;d0;
		endcase
	end
	always @(*) begin
		next_state_data_read = state_data_read;
		case (state_data_read)
			2&#39;d0:
				if (rd_en &amp;&amp; !f_empty)
					next_state_data_read = 2&#39;d1;
				else
					next_state_data_read = 2&#39;d0;
			2&#39;d1:
				if (rd_en)
					next_state_data_read = 2&#39;d1;
				else
					next_state_data_read = 2&#39;d2;
			2&#39;d2: next_state_data_read = 2&#39;d0;
			default: next_state_data_read = 2&#39;d0;
		endcase
	end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			state_open_slot &lt;= 2&#39;d0;
			open_slot_fct &lt;= 1&#39;b0;
			counter_wait &lt;= 11&#39;d0;
		end
		else begin
			state_open_slot &lt;= next_state_open_slot;
			case (state_open_slot)
				2&#39;d0:
					if ((((((((rd_ptr == 6&#39;d7) || (rd_ptr == 6&#39;d15)) || (rd_ptr == 6&#39;d23)) || (rd_ptr == 6&#39;d31)) || (rd_ptr == 6&#39;d39)) || (rd_ptr == 6&#39;d47)) || (rd_ptr == 6&#39;d55)) || (rd_ptr == 6&#39;d63)) begin
						open_slot_fct &lt;= 1&#39;b1;
						counter_wait &lt;= counter_wait + 11&#39;d1;
					end
					else
						open_slot_fct &lt;= 1&#39;b0;
				2&#39;d1: begin
					if (counter_wait != 11&#39;d300)
						counter_wait &lt;= counter_wait + 11&#39;d1;
					else
						counter_wait &lt;= counter_wait;
					open_slot_fct &lt;= 1&#39;b1;
				end
				2&#39;d2: begin
					counter_wait &lt;= 11&#39;d0;
					open_slot_fct &lt;= 1&#39;b0;
				end
				default: open_slot_fct &lt;= open_slot_fct;
			endcase
		end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			state_data_write &lt;= 2&#39;d0;
			wr_ptr &lt;= {AWIDTH {1&#39;b0}};
		end
		else begin
			state_data_write &lt;= next_state_data_write;
			case (state_data_write)
				2&#39;d0: wr_ptr &lt;= wr_ptr;
				2&#39;d1: wr_ptr &lt;= wr_ptr;
				2&#39;d2: wr_ptr &lt;= wr_ptr + 6&#39;d1;
				default: wr_ptr &lt;= wr_ptr;
			endcase
		end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			f_full &lt;= 1&#39;b0;
			f_empty &lt;= 1&#39;b0;
			overflow_credit_error &lt;= 1&#39;b0;
			counter &lt;= {AWIDTH {1&#39;b0}};
		end
		else begin
			if (state_data_write == 2&#39;d2)
				counter &lt;= counter + 6&#39;d1;
			else if ((counter &gt; 6&#39;d0) &amp;&amp; (state_data_read == 2&#39;d2))
				counter &lt;= counter - 6&#39;d1;
			else
				counter &lt;= counter;
			if (counter &gt; 6&#39;d56)
				overflow_credit_error &lt;= 1&#39;b1;
			else
				overflow_credit_error &lt;= 1&#39;b0;
			if (counter == 6&#39;d56)
				f_full &lt;= 1&#39;b1;
			else
				f_full &lt;= 1&#39;b0;
			if (counter == 6&#39;d0)
				f_empty &lt;= 1&#39;b1;
			else
				f_empty &lt;= 1&#39;b0;
		end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			rd_ptr &lt;= {AWIDTH {1&#39;b0}};
			state_data_read &lt;= 2&#39;d0;
		end
		else begin
			state_data_read &lt;= next_state_data_read;
			case (state_data_read)
				2&#39;d0:
					if (rd_en)
						rd_ptr &lt;= rd_ptr + 6&#39;d1;
					else
						rd_ptr &lt;= rd_ptr;
				2&#39;d1: rd_ptr &lt;= rd_ptr;
				2&#39;d2: rd_ptr &lt;= rd_ptr;
				default: rd_ptr &lt;= rd_ptr;
			endcase
		end
	mem_data mem_dta_fifo_rx(
		.clock(clock),
		.reset(reset),
		.data_in(data_in),
		.wr_ptr(wr_ptr),
		.rd_ptr(rd_ptr),
		.data_out(data_out)
	);
endmodule

</pre>
</body>
<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="http://llhd.io/" target="_blank">moore</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
rc: 0 (means success: 1)
tags: basejump
incdirs: /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v</a>
defines: 
time_elapsed: 0.022s
ram usage: 12776 KB
</pre>
<pre class="log">

moore -I /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_noc -I /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -I /tmpfs/src/github/sv-tests/third_party/cores/basejump_stl/bsg_misc -e bsg_imul_iterative <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_non_blocking_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_imul_iterative.v</a>
proc %bsg_imul_iterative.always_ff.698.0 (i1$ %clk_i, i1$ %reset_i, i3$ %next_state) -&gt; (i3$ %curr_state_r) {
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %clk_i.prb1 = prb i1$ %clk_i
    %0 = const i1 0
    %1 = eq i1 %clk_i.prb, %0
    %2 = neq i1 %clk_i.prb1, %0
    %posedge = and i1 %1, %2
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %3 = neq i1 %reset_i.prb, %0
    %4 = const time 0s 1d
    br %3, %if_false, %if_true
if_true:
    %5 = const i3 0
    drv i3$ %curr_state_r, %5, %4
    br %init
if_false:
    %next_state.prb = prb i3$ %next_state
    drv i3$ %curr_state_r, %next_state.prb, %4
    br %init
}

proc %bsg_imul_iterative.always_comb.859.0 (i1$ %v_i, i32$ %yumi_i, i1$ %shift_counter_full, i3$ %curr_state_r) -&gt; (i3$ %next_state) {
body:
    %curr_state_r.prb = prb i3$ %curr_state_r
    %0 = const i3 0
    %1 = eq i3 %curr_state_r.prb, %0
    %2 = const i3 1
    %3 = const time 0s 1e
    %4 = const i1 0
    br %1, %5, %case_body
check:
    wait %body, %v_i, %yumi_i, %shift_counter_full, %curr_state_r
case_body:
    %v_i.prb = prb i1$ %v_i
    %6 = neq i1 %v_i.prb, %4
    br %6, %if_false, %if_true
5:
    %7 = eq i3 %curr_state_r.prb, %2
    %8 = const i3 2
    br %7, %9, %case_body1
if_true:
    drv i3$ %next_state, %2, %3
    br %check
if_false:
    drv i3$ %next_state, %0, %3
    br %check
case_body1:
    drv i3$ %next_state, %8, %3
    br %check
9:
    %10 = eq i3 %curr_state_r.prb, %8
    %11 = const i3 3
    br %10, %12, %case_body2
case_body2:
    drv i3$ %next_state, %11, %3
    br %check
12:
    %13 = eq i3 %curr_state_r.prb, %11
    %14 = const i3 4
    br %13, %15, %case_body3
case_body3:
    %shift_counter_full.prb = prb i1$ %shift_counter_full
    %16 = neq i1 %shift_counter_full.prb, %4
    %17 = not i1 %16
    %18 = neq i1 %17, %4
    br %18, %if_false1, %if_true1
15:
    %19 = eq i3 %curr_state_r.prb, %14
    %20 = const i3 5
    br %19, %21, %case_body4
if_true1:
    drv i3$ %next_state, %11, %3
    br %check
if_false1:
    drv i3$ %next_state, %14, %3
    br %check
case_body4:
    drv i3$ %next_state, %20, %3
    br %check
21:
    %22 = eq i3 %curr_state_r.prb, %20
    br %22, %23, %case_body5
case_body5:
    %yumi_i.prb = prb i32$ %yumi_i
    %24 = const i32 0
    %25 = neq i32 %yumi_i.prb, %24
    br %25, %if_false2, %if_true2
23:
    drv i3$ %next_state, %0, %3
    br %check
if_true2:
    drv i3$ %next_state, %0, %3
    br %check
if_false2:
    drv i3$ %next_state, %20, %3
    br %check
}

proc %bsg_imul_iterative.always_ff.928.0 (i1$ %clk_i, i1$ %reset_i, i3$ %curr_state_r, i3$ %next_state) -&gt; (i6$ %shift_counter_r) {
0:
    %1 = prb i6$ %shift_counter_r
    %shift_counter_r.shadow = var i6 %1
    br %init
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %2 = prb i6$ %shift_counter_r
    st i6* %shift_counter_r.shadow, %2
    %clk_i.prb1 = prb i1$ %clk_i
    %3 = const i1 0
    %4 = eq i1 %clk_i.prb, %3
    %5 = neq i1 %clk_i.prb1, %3
    %posedge = and i1 %4, %5
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %6 = neq i1 %reset_i.prb, %3
    %7 = const time 0s 1d
    %8 = const i6 0
    br %6, %if_false, %if_true
if_true:
    drv i6$ %shift_counter_r, %8, %7
    br %0
if_false:
    %curr_state_r.prb = prb i3$ %curr_state_r
    %9 = const i3 3
    %10 = neq i3 %curr_state_r.prb, %9
    %11 = neq i1 %10, %3
    %next_state.prb = prb i3$ %next_state
    %12 = eq i3 %next_state.prb, %9
    %13 = neq i1 %12, %3
    %14 = and i1 %11, %13
    %15 = neq i1 %14, %3
    br %15, %if_false1, %if_true1
if_true1:
    drv i6$ %shift_counter_r, %8, %7
    br %0
if_false1:
    %16 = eq i3 %curr_state_r.prb, %9
    %17 = neq i1 %16, %3
    br %17, %0, %if_true2
if_true2:
    %18 = const i32 0
    %shift_counter_r.shadow.ld = ld i6* %shift_counter_r.shadow
    %zext = inss i32 %18, i6 %shift_counter_r.shadow.ld, 0, 6
    %19 = const i32 1
    %20 = add i32 %zext, %19
    %21 = exts i6, i32 %20, 0, 6
    drv i6$ %shift_counter_r, %21, %7
    br %0
}

proc %bsg_imul_iterative.always_ff.1192.0 (i1$ %clk_i, i1$ %reset_i, i1$ %latch_input, i1$ %signed_opA) -&gt; (i1$ %signed_opA_r) {
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %clk_i.prb1 = prb i1$ %clk_i
    %0 = const i1 0
    %1 = eq i1 %clk_i.prb, %0
    %2 = neq i1 %clk_i.prb1, %0
    %posedge = and i1 %1, %2
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %3 = neq i1 %reset_i.prb, %0
    %4 = const time 0s 1d
    br %3, %if_false, %if_true
if_true:
    drv i1$ %signed_opA_r, %0, %4
    br %init
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %5 = neq i1 %latch_input.prb, %0
    br %5, %init, %if_true1
if_true1:
    %signed_opA.prb = prb i1$ %signed_opA
    drv i1$ %signed_opA_r, %signed_opA.prb, %4
    br %init
}

proc %bsg_imul_iterative.always_ff.1229.0 (i1$ %clk_i, i1$ %reset_i, i1$ %latch_input, i1$ %signed_opB) -&gt; (i1$ %signed_opB_r) {
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %clk_i.prb1 = prb i1$ %clk_i
    %0 = const i1 0
    %1 = eq i1 %clk_i.prb, %0
    %2 = neq i1 %clk_i.prb1, %0
    %posedge = and i1 %1, %2
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %3 = neq i1 %reset_i.prb, %0
    %4 = const time 0s 1d
    br %3, %if_false, %if_true
if_true:
    drv i1$ %signed_opB_r, %0, %4
    br %init
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %5 = neq i1 %latch_input.prb, %0
    br %5, %init, %if_true1
if_true1:
    %signed_opB.prb = prb i1$ %signed_opB
    drv i1$ %signed_opB_r, %signed_opB.prb, %4
    br %init
}

proc %bsg_imul_iterative.always_ff.1270.0 (i1$ %clk_i, i1$ %reset_i, i1$ %latch_input, i1$ %signed_opA, i1$ %signed_opB) -&gt; (i1$ %need_neg_result_r) {
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %clk_i.prb1 = prb i1$ %clk_i
    %0 = const i1 0
    %1 = eq i1 %clk_i.prb, %0
    %2 = neq i1 %clk_i.prb1, %0
    %posedge = and i1 %1, %2
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %3 = neq i1 %reset_i.prb, %0
    %4 = const time 0s 1d
    br %3, %if_false, %if_true
if_true:
    drv i1$ %need_neg_result_r, %0, %4
    br %init
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %5 = neq i1 %latch_input.prb, %0
    br %5, %init, %if_true1
if_true1:
    %signed_opA.prb = prb i1$ %signed_opA
    %signed_opB.prb = prb i1$ %signed_opB
    %6 = xor i1 %signed_opA.prb, %signed_opB.prb
    drv i1$ %need_neg_result_r, %6, %4
    br %init
}

proc %bsg_imul_iterative.always_ff.1307.0 (i1$ %clk_i, i1$ %reset_i, i32$ %gets_high_part_i, i1$ %latch_input) -&gt; (i1$ %gets_high_part_r) {
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %clk_i.prb1 = prb i1$ %clk_i
    %0 = const i1 0
    %1 = eq i1 %clk_i.prb, %0
    %2 = neq i1 %clk_i.prb1, %0
    %posedge = and i1 %1, %2
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %3 = neq i1 %reset_i.prb, %0
    %4 = const time 0s 1d
    br %3, %if_false, %if_true
if_true:
    drv i1$ %gets_high_part_r, %0, %4
    br %init
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %5 = neq i1 %latch_input.prb, %0
    br %5, %init, %if_true1
if_true1:
    %gets_high_part_i.prb = prb i32$ %gets_high_part_i
    %6 = exts i1, i32 %gets_high_part_i.prb, 0, 1
    drv i1$ %gets_high_part_r, %6, %4
    br %init
}

proc %bsg_imul_iterative.always_ff.1409.0 (i1$ %clk_i, i1$ %reset_i, i32$ %opA_i, i1$ %gets_high_part_r, i3$ %curr_state_r, i33$ %adder_result, i1$ %latch_input, i1$ %signed_opA_r) -&gt; (i32$ %opA_r) {
0:
    %1 = prb i32$ %opA_r
    %opA_r.shadow = var i32 %1
    br %init
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %2 = prb i32$ %opA_r
    st i32* %opA_r.shadow, %2
    %clk_i.prb1 = prb i1$ %clk_i
    %3 = const i1 0
    %4 = eq i1 %clk_i.prb, %3
    %5 = neq i1 %clk_i.prb1, %3
    %posedge = and i1 %4, %5
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %6 = neq i1 %reset_i.prb, %3
    %7 = const time 0s 1d
    %8 = const i32 0
    br %6, %if_false, %if_true
if_true:
    drv i32$ %opA_r, %8, %7
    br %0
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %9 = neq i1 %latch_input.prb, %3
    br %9, %if_false1, %if_true1
if_true1:
    %opA_i.prb = prb i32$ %opA_i
    drv i32$ %opA_r, %opA_i.prb, %7
    br %0
if_false1:
    %curr_state_r.prb = prb i3$ %curr_state_r
    %10 = const i3 3
    %11 = eq i3 %curr_state_r.prb, %10
    %12 = neq i1 %11, %3
    %gets_high_part_r.prb = prb i1$ %gets_high_part_r
    %13 = neq i1 %gets_high_part_r.prb, %3
    %14 = not i1 %13
    %15 = neq i1 %14, %3
    %16 = and i1 %12, %15
    %17 = neq i1 %16, %3
    br %17, %if_false2, %if_true2
if_true2:
    %opA_r.shadow.ld = ld i32* %opA_r.shadow
    %18 = exts i31, i32 %opA_r.shadow.ld, 0, 31
    %19 = inss i32 %8, i31 %18, 1, 31
    %20 = inss i32 %19, i1 %3, 0, 1
    drv i32$ %opA_r, %20, %7
    br %0
if_false2:
    %21 = const i3 1
    %22 = eq i3 %curr_state_r.prb, %21
    %23 = neq i1 %22, %3
    %signed_opA_r.prb = prb i1$ %signed_opA_r
    %24 = neq i1 %signed_opA_r.prb, %3
    %25 = and i1 %23, %24
    %26 = neq i1 %25, %3
    br %26, %0, %if_true3
if_true3:
    %adder_result.prb = prb i33$ %adder_result
    %27 = exts i32, i33 %adder_result.prb, 0, 32
    drv i32$ %opA_r, %27, %7
    br %0
}

proc %bsg_imul_iterative.always_ff.1506.0 (i1$ %clk_i, i1$ %reset_i, i32$ %opB_i, i3$ %curr_state_r, i33$ %adder_result, i1$ %latch_input, i1$ %signed_opB_r) -&gt; (i32$ %opB_r) {
0:
    %1 = prb i32$ %opB_r
    %opB_r.shadow = var i32 %1
    br %init
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %2 = prb i32$ %opB_r
    st i32* %opB_r.shadow, %2
    %clk_i.prb1 = prb i1$ %clk_i
    %3 = const i1 0
    %4 = eq i1 %clk_i.prb, %3
    %5 = neq i1 %clk_i.prb1, %3
    %posedge = and i1 %4, %5
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %6 = neq i1 %reset_i.prb, %3
    %7 = const time 0s 1d
    %8 = const i32 0
    br %6, %if_false, %if_true
if_true:
    drv i32$ %opB_r, %8, %7
    br %0
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %9 = neq i1 %latch_input.prb, %3
    br %9, %if_false1, %if_true1
if_true1:
    %opB_i.prb = prb i32$ %opB_i
    drv i32$ %opB_r, %opB_i.prb, %7
    br %0
if_false1:
    %curr_state_r.prb = prb i3$ %curr_state_r
    %10 = const i3 3
    %11 = eq i3 %curr_state_r.prb, %10
    %12 = neq i1 %11, %3
    br %12, %if_false2, %if_true2
if_true2:
    %opB_r.shadow.ld = ld i32* %opB_r.shadow
    %13 = exts i31, i32 %opB_r.shadow.ld, 1, 31
    %14 = inss i32 %8, i31 %13, 0, 31
    drv i32$ %opB_r, %14, %7
    br %0
if_false2:
    %15 = const i3 2
    %16 = eq i3 %curr_state_r.prb, %15
    %17 = neq i1 %16, %3
    %signed_opB_r.prb = prb i1$ %signed_opB_r
    %18 = neq i1 %signed_opB_r.prb, %3
    %19 = and i1 %17, %18
    %20 = neq i1 %19, %3
    br %20, %0, %if_true3
if_true3:
    %adder_result.prb = prb i33$ %adder_result
    %21 = exts i32, i33 %adder_result.prb, 0, 32
    drv i32$ %opB_r, %21, %7
    br %0
}

proc %bsg_imul_iterative.always_ff.1597.0 (i1$ %clk_i, i1$ %reset_i, i3$ %curr_state_r, i1$ %latch_input, i1$ %shifted_lsb) -&gt; (i1$ %all_sh_lsb_zero_r) {
0:
    %1 = prb i1$ %all_sh_lsb_zero_r
    %all_sh_lsb_zero_r.shadow = var i1 %1
    br %init
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %2 = prb i1$ %all_sh_lsb_zero_r
    st i1* %all_sh_lsb_zero_r.shadow, %2
    %clk_i.prb1 = prb i1$ %clk_i
    %3 = const i1 0
    %4 = eq i1 %clk_i.prb, %3
    %5 = neq i1 %clk_i.prb1, %3
    %posedge = and i1 %4, %5
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %6 = neq i1 %reset_i.prb, %3
    %7 = const time 0s 1d
    br %6, %if_false, %if_true
if_true:
    drv i1$ %all_sh_lsb_zero_r, %3, %7
    br %0
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %8 = neq i1 %latch_input.prb, %3
    br %8, %if_false1, %if_true1
if_true1:
    %9 = const i1 1
    drv i1$ %all_sh_lsb_zero_r, %9, %7
    br %0
if_false1:
    %curr_state_r.prb = prb i3$ %curr_state_r
    %10 = const i3 3
    %11 = eq i3 %curr_state_r.prb, %10
    %12 = neq i1 %11, %3
    br %12, %0, %if_true2
if_true2:
    %all_sh_lsb_zero_r.shadow.ld = ld i1* %all_sh_lsb_zero_r.shadow
    %shifted_lsb.prb = prb i1$ %shifted_lsb
    %13 = not i1 %shifted_lsb.prb
    %14 = and i1 %all_sh_lsb_zero_r.shadow.ld, %13
    drv i1$ %all_sh_lsb_zero_r, %14, %7
    br %0
}

proc %bsg_imul_iterative.always_ff.1799.0 (i1$ %clk_i, i1$ %reset_i, i1$ %gets_high_part_r, i3$ %curr_state_r, i32$ %opB_r, i33$ %adder_result, i33$ %shifted_adder_result, i1$ %latch_input, i1$ %need_neg_result_r, i1$ %all_sh_lsb_zero_r) -&gt; (i32$ %result_r) {
0:
    %1 = prb i32$ %result_r
    %result_r.shadow = var i32 %1
    br %init
init:
    %clk_i.prb = prb i1$ %clk_i
    wait %check, %clk_i
check:
    %2 = prb i32$ %result_r
    st i32* %result_r.shadow, %2
    %clk_i.prb1 = prb i1$ %clk_i
    %3 = const i1 0
    %4 = eq i1 %clk_i.prb, %3
    %5 = neq i1 %clk_i.prb1, %3
    %posedge = and i1 %4, %5
    br %posedge, %init, %event
event:
    %reset_i.prb = prb i1$ %reset_i
    %6 = neq i1 %reset_i.prb, %3
    %7 = const time 0s 1d
    %8 = const i32 0
    br %6, %if_false, %if_true
if_true:
    drv i32$ %result_r, %8, %7
    br %0
if_false:
    %latch_input.prb = prb i1$ %latch_input
    %9 = neq i1 %latch_input.prb, %3
    br %9, %if_false1, %if_true1
if_true1:
    drv i32$ %result_r, %8, %7
    br %0
if_false1:
    %curr_state_r.prb = prb i3$ %curr_state_r
    %10 = const i3 4
    %11 = eq i3 %curr_state_r.prb, %10
    %12 = neq i1 %11, %3
    %need_neg_result_r.prb = prb i1$ %need_neg_result_r
    %13 = neq i1 %need_neg_result_r.prb, %3
    %14 = and i1 %12, %13
    %15 = neq i1 %14, %3
    %gets_high_part_r.prb = prb i1$ %gets_high_part_r
    %adder_result.prb = prb i33$ %adder_result
    br %15, %if_false2, %if_true2
if_true2:
    %16 = neq i1 %gets_high_part_r.prb, %3
    %all_sh_lsb_zero_r.prb = prb i1$ %all_sh_lsb_zero_r
    %17 = neq i1 %all_sh_lsb_zero_r.prb, %3
    %18 = not i1 %17
    %19 = neq i1 %18, %3
    %20 = and i1 %16, %19
    %21 = neq i1 %20, %3
    br %21, %if_false3, %if_true3
if_false2:
    %22 = const i3 3
    %23 = eq i3 %curr_state_r.prb, %22
    %24 = neq i1 %23, %3
    %opB_r.prb = prb i32$ %opB_r
    %25 = exts i1, i32 %opB_r.prb, 0, 1
    %26 = neq i1 %25, %3
    %27 = and i1 %24, %26
    %28 = neq i1 %27, %3
    %29 = neq i1 %gets_high_part_r.prb, %3
    br %28, %if_false4, %if_true4
if_true3:
    %result_r.shadow.ld = ld i32* %result_r.shadow
    %30 = not i32 %result_r.shadow.ld
    drv i32$ %result_r, %30, %7
    br %0
if_false3:
    %31 = exts i32, i33 %adder_result.prb, 0, 32
    drv i32$ %result_r, %31, %7
    br %0
if_true4:
    br %29, %if_false5, %if_true5
if_false4:
    %32 = not i1 %26
    %33 = neq i1 %32, %3
    %34 = and i1 %24, %33
    %35 = neq i1 %34, %3
    br %35, %0, %if_true6
if_true5:
    %shifted_adder_result.prb = prb i33$ %shifted_adder_result
    %36 = exts i32, i33 %shifted_adder_result.prb, 0, 32
    drv i32$ %result_r, %36, %7
    br %0
if_false5:
    %37 = exts i32, i33 %adder_result.prb, 0, 32
    drv i32$ %result_r, %37, %7
    br %0
if_true6:
    br %29, %0, %if_true7
if_true7:
    %result_r.shadow.ld1 = ld i32* %result_r.shadow
    %38 = exts i31, i32 %result_r.shadow.ld1, 1, 31
    %39 = inss i32 %8, i31 %38, 0, 31
    drv i32$ %result_r, %39, %7
    br %0
}

entity @bsg_imul_iterative (i1$ %clk_i, i1$ %reset_i, i1$ %v_i, i32$ %opA_i, i32$ %signed_opA_i, i32$ %opB_i, i32$ %signed_opB_i, i32$ %gets_high_part_i, i32$ %yumi_i) -&gt; (i1$ %ready_o, i32$ %v_o, i32$ %result_o) {
    %0 = const i6 0
    %shift_counter_r = sig i6 %0
    %1 = const i1 0
    %gets_high_part_r = sig i1 %1
    %shift_counter_full = sig i1 %1
    %gets_high_part_r.prb = prb i1$ %gets_high_part_r
    %2 = neq i1 %gets_high_part_r.prb, %1
    %3 = const i32 0
    %shift_counter_r.prb = prb i6$ %shift_counter_r
    %zext = inss i32 %3, i6 %shift_counter_r.prb, 0, 6
    %4 = const i32 31
    %5 = eq i32 %zext, %4
    %6 = const i32 32
    %7 = eq i32 %zext, %6
    %8 = [i1 %7, %5]
    %9 = mux [2 x i1] %8, i1 %2
    %10 = sig i1 %1
    %11 = const time 0s 1d
    drv i1$ %10, %9, %11
    con i1$ %shift_counter_full, %10
    %12 = const i3 0
    %curr_state_r = sig i3 %12
    %next_state = sig i3 %12
    %opA_r = sig i32 %3
    %opB_r = sig i32 %3
    %result_r = sig i32 %3
    %adder_a = sig i32 %3
    %adder_b = sig i32 %3
    %13 = const i33 0
    %adder_result = sig i33 %13
    %shifted_adder_result = sig i33 %13
    %adder_neg_op = sig i1 %1
    %curr_state_r.prb = prb i3$ %curr_state_r
    %14 = const i3 1
    %15 = eq i3 %curr_state_r.prb, %14
    %16 = neq i1 %15, %1
    %17 = const i3 2
    %18 = eq i3 %curr_state_r.prb, %17
    %19 = neq i1 %18, %1
    %20 = or i1 %16, %19
    %21 = neq i1 %20, %1
    %22 = const i3 4
    %23 = eq i3 %curr_state_r.prb, %22
    %24 = neq i1 %23, %1
    %25 = or i1 %21, %24
    %26 = sig i1 %1
    drv i1$ %26, %25, %11
    con i1$ %adder_neg_op, %26
    %latch_input = sig i1 %1
    %v_i.prb = prb i1$ %v_i
    %ready_o.prb = prb i1$ %ready_o
    %27 = and i1 %v_i.prb, %ready_o.prb
    %28 = sig i1 %1
    drv i1$ %28, %27, %11
    con i1$ %latch_input, %28
    %signed_opA_r = sig i1 %1
    %signed_opB_r = sig i1 %1
    %need_neg_result_r = sig i1 %1
    %signed_opA = sig i1 %1
    %signed_opA_i.prb = prb i32$ %signed_opA_i
    %opA_i.prb = prb i32$ %opA_i
    %29 = exts i1, i32 %opA_i.prb, 31, 1
    %30 = inss i32 %3, i1 %29, 0, 1
    %31 = exts i1, i32 %30, 0, 1
    %zext1 = inss i32 %3, i1 %31, 0, 1
    %32 = and i32 %signed_opA_i.prb, %zext1
    %33 = sig i32 %3
    drv i32$ %33, %32, %11
    con i1$ %signed_opA, %33
    %signed_opB = sig i1 %1
    %signed_opB_i.prb = prb i32$ %signed_opB_i
    %opB_i.prb = prb i32$ %opB_i
    %34 = exts i1, i32 %opB_i.prb, 31, 1
    %35 = inss i32 %3, i1 %34, 0, 1
    %36 = exts i1, i32 %35, 0, 1
    %zext2 = inss i32 %3, i1 %36, 0, 1
    %37 = and i32 %signed_opB_i.prb, %zext2
    %38 = sig i32 %3
    drv i32$ %38, %37, %11
    con i1$ %signed_opB, %38
    %shifted_lsb = sig i1 %1
    %opB_r.prb = prb i32$ %opB_r
    %39 = exts i1, i32 %opB_r.prb, 0, 1
    %40 = neq i1 %39, %1
    %adder_result.prb = prb i33$ %adder_result
    %41 = exts i1, i33 %adder_result.prb, 0, 1
    %result_r.prb = prb i32$ %result_r
    %42 = exts i1, i32 %result_r.prb, 0, 1
    %43 = [i1 %42, %41]
    %44 = mux [2 x i1] %43, i1 %40
    %45 = sig i1 %1
    drv i1$ %45, %44, %11
    con i1$ %shifted_lsb, %45
    %all_sh_lsb_zero_r = sig i1 %1
    %opA_r.prb = prb i32$ %opA_r
    %46 = not i32 %opA_r.prb
    %zext3 = inss i32 %3, i1 %18, 0, 1
    %47 = [i32 %zext3, %46]
    %48 = mux [2 x i32] %47, i1 %16
    %49 = neq i32 %48, %3
    %50 = not i32 %opB_r.prb
    %zext4 = inss i32 %3, i1 %23, 0, 1
    %51 = [i32 %zext4, %50]
    %52 = mux [2 x i32] %51, i1 %49
    %53 = neq i32 %52, %3
    %54 = not i32 %result_r.prb
    %55 = [i32 %result_r.prb, %54]
    %56 = mux [2 x i32] %55, i1 %53
    %57 = const time 0s 1e
    drv i32$ %adder_a, %56, %57
    %adder_neg_op.prb = prb i1$ %adder_neg_op
    %58 = neq i1 %adder_neg_op.prb, %1
    %59 = const i32 1
    %60 = [i32 %opA_r.prb, %59]
    %61 = mux [2 x i32] %60, i1 %58
    drv i32$ %adder_b, %61, %57
    %adder_a.prb = prb i32$ %adder_a
    %62 = inss i33 %13, i32 %adder_a.prb, 0, 32
    %concat = inss i33 %62, i1 %1, 32, 1
    %adder_b.prb = prb i32$ %adder_b
    %63 = inss i33 %13, i32 %adder_b.prb, 0, 32
    %concat1 = inss i33 %63, i1 %1, 32, 1
    %64 = add i33 %concat, %concat1
    drv i33$ %adder_result, %64, %57
    %65 = exts i32, i33 %adder_result.prb, 1, 32
    %66 = inss i33 %13, i32 %65, 0, 32
    drv i33$ %shifted_adder_result, %66, %57
    %67 = eq i3 %curr_state_r.prb, %12
    drv i1$ %ready_o, %67, %57
    drv i32$ %result_o, %result_r.prb, %57
    %68 = const i3 5
    %69 = eq i3 %curr_state_r.prb, %68
    %zext5 = inss i32 %3, i1 %69, 0, 1
    drv i32$ %v_o, %zext5, %57
    inst %bsg_imul_iterative.always_ff.698.0 (i1$ %clk_i, i1$ %reset_i, i3$ %next_state) -&gt; (i3$ %curr_state_r)
    inst %bsg_imul_iterative.always_comb.859.0 (i1$ %v_i, i32$ %yumi_i, i1$ %shift_counter_full, i3$ %curr_state_r) -&gt; (i3$ %next_state)
    inst %bsg_imul_iterative.always_ff.928.0 (i1$ %clk_i, i1$ %reset_i, i3$ %curr_state_r, i3$ %next_state) -&gt; (i6$ %shift_counter_r)
    inst %bsg_imul_iterative.always_ff.1192.0 (i1$ %clk_i, i1$ %reset_i, i1$ %latch_input, i1$ %signed_opA) -&gt; (i1$ %signed_opA_r)
    inst %bsg_imul_iterative.always_ff.1229.0 (i1$ %clk_i, i1$ %reset_i, i1$ %latch_input, i1$ %signed_opB) -&gt; (i1$ %signed_opB_r)
    inst %bsg_imul_iterative.always_ff.1270.0 (i1$ %clk_i, i1$ %reset_i, i1$ %latch_input, i1$ %signed_opA, i1$ %signed_opB) -&gt; (i1$ %need_neg_result_r)
    inst %bsg_imul_iterative.always_ff.1307.0 (i1$ %clk_i, i1$ %reset_i, i32$ %gets_high_part_i, i1$ %latch_input) -&gt; (i1$ %gets_high_part_r)
    inst %bsg_imul_iterative.always_ff.1409.0 (i1$ %clk_i, i1$ %reset_i, i32$ %opA_i, i1$ %gets_high_part_r, i3$ %curr_state_r, i33$ %adder_result, i1$ %latch_input, i1$ %signed_opA_r) -&gt; (i32$ %opA_r)
    inst %bsg_imul_iterative.always_ff.1506.0 (i1$ %clk_i, i1$ %reset_i, i32$ %opB_i, i3$ %curr_state_r, i33$ %adder_result, i1$ %latch_input, i1$ %signed_opB_r) -&gt; (i32$ %opB_r)
    inst %bsg_imul_iterative.always_ff.1597.0 (i1$ %clk_i, i1$ %reset_i, i3$ %curr_state_r, i1$ %latch_input, i1$ %shifted_lsb) -&gt; (i1$ %all_sh_lsb_zero_r)
    inst %bsg_imul_iterative.always_ff.1799.0 (i1$ %clk_i, i1$ %reset_i, i1$ %gets_high_part_r, i3$ %curr_state_r, i32$ %opB_r, i33$ %adder_result, i33$ %shifted_adder_result, i1$ %latch_input, i1$ %need_neg_result_r, i1$ %all_sh_lsb_zero_r) -&gt; (i32$ %result_r)
}

</pre>
</body>